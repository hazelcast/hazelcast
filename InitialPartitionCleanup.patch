Index: hazelcast/src/test/java/com/hazelcast/partition/PartitionStateGeneratorTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hazelcast/src/test/java/com/hazelcast/partition/PartitionStateGeneratorTest.java	(date 1388228573000)
+++ hazelcast/src/test/java/com/hazelcast/partition/PartitionStateGeneratorTest.java	(revision )
@@ -153,7 +153,7 @@
             println("PARTITION-COUNT= " + partitionCount + ", MEMBER-COUNT= "
                     + members[0] + ", GROUP-COUNT= " + groups.size());
             println();
-            PartitionImpl[] state = generator.initialize(memberGroupFactory.createMemberGroups(memberList), partitionCount);
+            Address[][] state = generator.initialize(memberGroupFactory.createMemberGroups(memberList), partitionCount);
             checkTestResult(state, groups, partitionCount);
             int previousMemberCount = memberCount;
             for (int j = 1; j < members.length; j++) {
@@ -174,7 +174,8 @@
                     }
                     groups = memberGroupFactory.createMemberGroups(memberList);
                     println("PARTITION-COUNT= " + partitionCount + ", MEMBER-COUNT= " + memberCount + ", GROUP-COUNT= " + groups.size());
-                    state = generator.reArrange(memberGroupFactory.createMemberGroups(memberList), state);
+                    //todo
+                    state = generator.reArrange(memberGroupFactory.createMemberGroups(memberList), toPartitionView(state));
                     checkTestResult(state, groups, partitionCount);
                     previousMemberCount = memberCount;
                 }
@@ -182,28 +183,75 @@
         }
     }
 
-    private static void shift(PartitionImpl[] state, List<Member> members) {
+    private DummyPartitionView[] toPartitionView(Address[][] state){
+        DummyPartitionView[] result = new DummyPartitionView[state.length];
+        for(int partitionId=0;partitionId<state.length;partitionId++){
+            DummyPartitionView partitionView = new DummyPartitionView(state[partitionId]);
+            result[partitionId]=partitionView;
+        }
+        return result;
+    }
+
+    private class DummyPartitionView implements PartitionView{
+        private Address[] replicas;
+
+        private DummyPartitionView(Address[] replicas) {
+            this.replicas = replicas;
+        }
+
+        @Override
+        public int getPartitionId() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public Address getOwner() {
+            return replicas[0];
+        }
+
+        @Override
+        public Address getReplicaAddress(int index) {
+           return replicas[index];
+        }
+
+        @Override
+        public boolean isBackup(Address address) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean isOwnerOrBackup(Address address) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public int getReplicaIndexOf(Address address) {
+            throw new UnsupportedOperationException();
+        }
+    }
+
+    private static void shift(Address[][] state, List<Member> members) {
         Set<Address> addresses = new HashSet<Address>();
         for (Member member : members) {
             addresses.add(((MemberImpl) member).getAddress());
         }
-        for (PartitionImpl partition : state) {
-            for (int i = 0; i < state.length; i++) {
-                if (partition.getReplicaAddress(i) != null &&
-                        !addresses.contains(partition.getReplicaAddress(i))) {
+        for (int partitionId=0;partitionId<state.length;partitionId++) {
+            Address[] replicas = state[partitionId];
+            for (int i = 0; i < replicas.length; i++) {
+                if (replicas[i] != null && !addresses.contains(replicas[i])) {
                     Address[] validAddresses = new Address[PartitionImpl.MAX_REPLICA_COUNT - i];
                     int k = 0;
                     for (int a = i + 1; a < PartitionImpl.MAX_REPLICA_COUNT; a++) {
-                        Address address = partition.getReplicaAddress(a);
+                        Address address = replicas[a];
                         if (address != null && addresses.contains(address)) {
                             validAddresses[k++] = address;
                         }
                     }
                     for (int a = 0; a < k; a++) {
-                        partition.setReplicaAddress(i + a, validAddresses[a]);
+                        replicas[i+a]=validAddresses[a];
                     }
                     for (int a = i + k; a < PartitionImpl.MAX_REPLICA_COUNT; a++) {
-                        partition.setReplicaAddress(a, null);
+                        replicas[a]=null;
                     }
                     break;
                 }
@@ -252,7 +300,7 @@
         return members;
     }
 
-    private void checkTestResult(final PartitionImpl[] state, final Collection<MemberGroup> groups, final int partitionCount) {
+    private void checkTestResult(final Address[][] state, final Collection<MemberGroup> groups, final int partitionCount) {
         Iterator<MemberGroup> iter = groups.iterator();
         while (iter.hasNext()) {
             if (iter.next().size() == 0) {
@@ -263,11 +311,12 @@
         final Map<MemberGroup, GroupPartitionState> groupPartitionStates = new HashMap<MemberGroup, GroupPartitionState>();
         final Set<Address> set = new HashSet<Address>();
         final int avgPartitionPerGroup = partitionCount / groups.size();
-        for (PartitionImpl p : state) {
+        for(int partitionId=0;partitionId<partitionCount;partitionId++){
+            Address[] replicas = state[partitionId];
             for (int i = 0; i < replicaCount; i++) {
-                Address owner = p.getReplicaAddress(i);
+                Address owner = replicas[i];
                 Assert.assertNotNull(owner);
-                Assert.assertFalse("Duplicate owner of partition: " + p.getPartitionId(),
+                Assert.assertFalse("Duplicate owner of partition: " + partitionId,
                         set.contains(owner));
                 set.add(owner);
                 MemberGroup group = null;
@@ -284,8 +333,8 @@
                     groupState.group = group;
                     groupPartitionStates.put(group, groupState);
                 }
-                groupState.groupPartitions[i].add(p.getPartitionId());
-                groupState.getNodePartitions(owner)[i].add(p.getPartitionId());
+                groupState.groupPartitions[i].add(partitionId);
+                groupState.getNodePartitions(owner)[i].add(partitionId);
             }
             set.clear();
         }
Index: hazelcast/src/main/java/com/hazelcast/partition/PartitionServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hazelcast/src/main/java/com/hazelcast/partition/PartitionServiceImpl.java	(date 1388228573000)
+++ hazelcast/src/main/java/com/hazelcast/partition/PartitionServiceImpl.java	(revision )
@@ -17,10 +17,7 @@
 package com.hazelcast.partition;
 
 import com.hazelcast.config.PartitionGroupConfig;
-import com.hazelcast.core.HazelcastException;
-import com.hazelcast.core.Member;
-import com.hazelcast.core.MigrationEvent;
-import com.hazelcast.core.MigrationListener;
+import com.hazelcast.core.*;
 import com.hazelcast.instance.MemberImpl;
 import com.hazelcast.instance.Node;
 import com.hazelcast.logging.ILogger;
@@ -222,10 +219,14 @@
                 PartitionStateGenerator psg = partitionStateGenerator;
                 logger.info("Initializing cluster partition table first arrangement...");
                 final Set<Member> members = node.getClusterService().getMembers();
-                PartitionImpl[] newState = psg.initialize(memberGroupFactory.createMemberGroups(members), partitionCount);
+                Address[][] newState = psg.initialize(memberGroupFactory.createMemberGroups(members), partitionCount);
+
+                //todo: why is there a null check?
                 if (newState != null) {
-                    for (PartitionImpl partition : newState) {
-                        partitions[partition.getPartitionId()].setPartitionInfo(partition);
+                    for (int partitionId = 0; partitionId < partitionCount; partitionId++) {
+                        PartitionImpl partition = partitions[partitionId];
+                        Address[] replicas = newState[partitionId];
+                        partition.setPartitionInfo(replicas);
                     }
                     initialized = true;
                     sendPartitionRuntimeState(true);
@@ -1033,19 +1034,19 @@
                     migrationQueue.clear();
                     final PartitionStateGenerator psg = partitionStateGenerator;
                     final Set<Member> members = node.getClusterService().getMembers();
-                    final PartitionImpl[] newState = psg.reArrange(memberGroupFactory.createMemberGroups(members), partitions);
+                    final Address[][] newState = psg.reArrange(memberGroupFactory.createMemberGroups(members), partitions);
                     int migrationCount = 0;
                     int lostCount = 0;
                     lastRepartitionTime.set(Clock.currentTimeMillis());
-                    for (PartitionImpl newPartition : newState) {
-                        int partitionId = newPartition.getPartitionId();
+                    for (int partitionId=0;partitionId<partitionCount;partitionId++) {
+                        Address[] replicas = newState[partitionId];
                         PartitionImpl currentPartition = partitions[partitionId];
                         Address currentOwner = currentPartition.getOwner();
-                        Address newOwner = newPartition.getOwner();
+                        Address newOwner = replicas[0];
 
                         if (currentOwner == null) {  // assign new owner for lost partition
                             lostCount++;
-                            currentPartition.setPartitionInfo(newPartition);
+                            currentPartition.setPartitionInfo(replicas);
                             MigrationInfo migrationInfo = new MigrationInfo(partitionId, null, newOwner);
                             sendMigrationEvent(migrationInfo, MigrationStatus.STARTED);
                             sendMigrationEvent(migrationInfo, MigrationStatus.COMPLETED);
@@ -1053,10 +1054,10 @@
                         } else if (newOwner != null && !currentOwner.equals(newOwner)) {
                             migrationCount++;
                             MigrationInfo info = new MigrationInfo(partitionId, currentOwner, newOwner);
-                            final Migrator migrator = new Migrator(info, new BackupMigrationTask(newPartition));
+                            final Migrator migrator = new Migrator(info, new BackupMigrationTask(partitionId, replicas));
                             migrationQueue.offer(migrator);
                         } else {
-                            currentPartition.setPartitionInfo(newPartition);
+                            currentPartition.setPartitionInfo(replicas);
                         }
                     }
                     sendPartitionRuntimeState(false);
@@ -1078,18 +1079,20 @@
     }
 
     private class BackupMigrationTask implements Runnable {
-        final PartitionImpl newPartition;
+        final Address[] replicas;
+        final int partitionid;
 
-        BackupMigrationTask(PartitionImpl newPartition) {
-            this.newPartition = newPartition;
+        BackupMigrationTask(int partitionId, Address[] replicas) {
+            this.partitionid = partitionId;
+            this.replicas = replicas;
         }
 
         public void run() {
             lock.lock();
             try {
-                final PartitionImpl currentPartition = partitions[newPartition.getPartitionId()];
+                final PartitionImpl currentPartition = partitions[partitionid];
                 for (int index = 1; index < PartitionView.MAX_REPLICA_COUNT; index++) {
-                    currentPartition.setReplicaAddress(index, newPartition.getReplicaAddress(index));
+                    currentPartition.setReplicaAddress(index, replicas[index]);
                 }
             } finally {
                 lock.unlock();
@@ -1099,7 +1102,8 @@
         @Override
         public String toString() {
             final StringBuilder sb = new StringBuilder("BackupMigrationTask{");
-            sb.append("newPartition=").append(newPartition);
+            sb.append("partitonId=").append(partitionid);
+            sb.append("replicas=").append(Arrays.toString(replicas));
             sb.append('}');
             return sb.toString();
         }
Index: hazelcast/src/main/java/com/hazelcast/partition/PartitionImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hazelcast/src/main/java/com/hazelcast/partition/PartitionImpl.java	(date 1388228573000)
+++ hazelcast/src/main/java/com/hazelcast/partition/PartitionImpl.java	(revision )
@@ -89,6 +89,12 @@
         }
     }
 
+    void setPartitionInfo(Address[] replicas) {
+        for (int i = 0; i < MAX_REPLICA_COUNT; i++) {
+            setReplicaAddress(i, replicas[i]);
+        }
+    }
+
     @Override
     public boolean isBackup(Address address) {
         for (int i = 1; i < MAX_REPLICA_COUNT; i++) {
Index: hazelcast/src/main/java/com/hazelcast/partition/PartitionStateGeneratorImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hazelcast/src/main/java/com/hazelcast/partition/PartitionStateGeneratorImpl.java	(date 1388228573000)
+++ hazelcast/src/main/java/com/hazelcast/partition/PartitionStateGeneratorImpl.java	(revision )
@@ -34,21 +34,38 @@
     private static final int AGGRESSIVE_INDEX_THRESHOLD = 3;
     private static final int MIN_AVG_OWNER_DIFF = 3;
 
-
-    public PartitionImpl[] initialize(Collection<MemberGroup> memberGroups, int partitionCount) {
+    public Address[][] initialize(Collection<MemberGroup> memberGroups, int partitionCount) {
         final LinkedList<NodeGroup> nodeGroups = createNodeGroups(memberGroups);
         if (nodeGroups.size() == 0) {
             return null;
         }
-        return arrange(nodeGroups, partitionCount, new EmptyStateInitializer());
+        PartitionImpl[] newState = arrange(nodeGroups, partitionCount, new EmptyStateInitializer());
+        return toReplicaArray(partitionCount, newState);
     }
 
-    public PartitionImpl[] reArrange(final Collection<MemberGroup> memberGroups, final PartitionView[] currentState) {
+    private Address[][] toReplicaArray(int partitionCount, PartitionImpl[] newState) {
+        Address[][] result = new Address[partitionCount][];
+        for(int partitionId=0;partitionId<partitionCount;partitionId++){
+            PartitionImpl partition = newState[partitionId];
+            if(partition.getPartitionId()!=partitionId){
+                throw new RuntimeException();
+            }
+            Address[] replicas = new Address[PartitionView.MAX_REPLICA_COUNT];
+            result[partitionId]=replicas;
+            for(int replicaIndex =0;replicaIndex<replicas.length;replicaIndex++){
+               replicas[replicaIndex]=partition.getReplicaAddress(replicaIndex);
+            }
+        }
+        return result;
+    }
+
+    public Address[][] reArrange(final Collection<MemberGroup> memberGroups, final PartitionView[] currentState) {
         final LinkedList<NodeGroup> nodeGroups = createNodeGroups(memberGroups);
         if (nodeGroups.size() == 0) {
             return null;
         }
-        return arrange(nodeGroups, currentState.length, new CopyStateInitializer(currentState));
+        PartitionImpl[] newState = arrange(nodeGroups, currentState.length, new CopyStateInitializer(currentState));
+        return toReplicaArray(currentState.length, newState);
     }
 
     private PartitionImpl[] arrange(final LinkedList<NodeGroup> groups, final int partitionCount,
Index: hazelcast/src/main/java/com/hazelcast/partition/PartitionStateGenerator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hazelcast/src/main/java/com/hazelcast/partition/PartitionStateGenerator.java	(date 1388228573000)
+++ hazelcast/src/main/java/com/hazelcast/partition/PartitionStateGenerator.java	(revision )
@@ -16,11 +16,13 @@
 
 package com.hazelcast.partition;
 
+import com.hazelcast.nio.Address;
+
 import java.util.Collection;
 
 public interface PartitionStateGenerator {
 
-    PartitionImpl[] initialize(final Collection<MemberGroup> groups, final int partitionCount);
+    Address[][] initialize(final Collection<MemberGroup> groups, final int partitionCount);
 
-    PartitionImpl[] reArrange(final Collection<MemberGroup> groups, final PartitionView[] currentState);
+    Address[][] reArrange(final Collection<MemberGroup> groups, final PartitionView[] currentState);
 }
