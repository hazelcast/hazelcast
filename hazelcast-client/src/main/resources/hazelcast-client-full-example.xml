<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Copyright (c) 2008-2019, Hazelcast, Inc. All Rights Reserved.
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~ http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<!--
  This is a full example hazelcast-client.xml that includes all the
  configuration elements and attributes of a Hazelcast client.

  To use this, rename it to hazelcast-client.xml and place it in
  the directory where you start your Hazelcast client.

  To learn how to configure Hazelcast, please see the schema at
  https://hazelcast.com/schema/client-config/hazelcast-client-config-4.0.xsd
  or the Reference Manual at https://hazelcast.org/documentation/
-->

<!--suppress XmlDefaultAttributeValue -->
<hazelcast-client xmlns="http://www.hazelcast.com/schema/client-config"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                  xsi:schemaLocation="http://www.hazelcast.com/schema/client-config
                  http://www.hazelcast.com/schema/client-config/hazelcast-client-config-4.0.xsd">

    <!--
        You can use the <import> element to load different Hazelcast declarative configuration files you prepared.
        You can import as many XML files as you want and hence compose your Hazelcast configuration
        out of those XML files. If you want to use the <import> element, it should be placed at the top of your
        Hazelcast XML file right after the <hazelcast-client> element, and it should have the required attribute "resource".

        Below is an example where the configuration files you want to include are located at your
        Hazelcast working directory:
        <import resource="your-client-configuration-file.xml"/>

        Below are examples showing a classpath or filesystem location:
        <import resource="file:///etc/hazelcast/your-client-configuration-file-1.xml"/>
        <import resource="classpath:your-client-configuration-file-2.xml"/>

        Below is an example showing property placeholders:
        <import resource="${environment}-your-client-configuration-file.xml"/>

    -->
    <import resource="your-client-configuration-XML-file"/>

    <!--
        The <config-replacers> allow to use variables (placeholders) within the configuration file and use an external
        class to retrieve correct values (replacements).

        It can be used for masking sensitive strings such as passwords for instance.

        Format of a variable is:
        $ PREFIX { STRING_TO_BE_REPLACED }      e.g. $ENC{nnPgTqJCcCQ=:23000:B4y/nlp6M0t3q6YiKImW+w==}

        The PREFIX value depends on the replacer implementation (e.g. "ENC" is used for the EncryptionReplacer)
        The STRING_TO_BE_REPLACED is the value which is provided to replacer implementation.
    -->
    <config-replacers fail-if-value-missing="false">
        <replacer class-name="com.hazelcast.config.replacer.EncryptionReplacer">
            <properties>
                <property name="passwordFile">password.txt</property>
                <property name="passwordUserProperties">false</property>
                <property name="cipherAlgorithm">DES</property>
                <property name="keyLengthBits">64</property>
                <property name="secretKeyAlgorithm">DES</property>
                <property name="secretKeyFactoryAlgorithm">PBKDF2WithHmacSHA1</property>
            </properties>
        </replacer>
    </config-replacers>

    <!--
        Specifies the name and password for a cluster group you connect to.
        Cluster groups allow you to create separate sub-clusters with different names.
        The password is only checked when security is enabled on Hazelcast members (Enterprise edition feature).
    -->
    <group>
        <name>dev</name>
        <password>dev-pass</password>
    </group>

    <!--
        When Hazelcast instances are created, they are put in a global registry with their creation names.
        <instance-name> elements gives you the ability to get a specific Hazelcast instance from this registry
        by giving the instance's name.
    -->
    <instance-name>CLIENT_NAME</instance-name>

    <!--
        ===== HAZELCAST LICENSE CONFIGURATION =====

        If you have an Enterprise or Enterprise HD license, you can enter it here.
        You can also set your license key programmatically; please refer to
        http://docs.hazelcast.org/docs/latest/manual/html-single/index.html#setting-the-license-key

        Please note that providing the license key is not required in client
        configuration, it is kept only for backward compatibility.
    -->
    <license-key>HAZELCAST_ENTERPRISE_LICENSE_KEY</license-key>
    <!--
        The <properties> element lets you add properties to some of the Hazelcast elements used to configure some of
        the Hazelcast client modules.
        You can define the name and value of these properties using the sub-element <property>.
        Please check the source of the ClientProperty class for the complete list of the client properties and their
        documentation.
    -->
    <properties>
        <property name="hazelcast.client.shuffle.member.list">true</property>
        <property name="hazelcast.client.heartbeat.timeout">60000</property>
        <property name="hazelcast.client.heartbeat.interval">5000</property>
        <property name="hazelcast.client.event.thread.count">5</property>
        <property name="hazelcast.client.event.queue.capacity">1000000</property>
        <property name="hazelcast.client.invocation.timeout.seconds">120</property>
    </properties>
    <!--
        The <client-labels> element lets you define labels in your Java client, similar to the way it can be done for the
        members. Through the client labels, you can assign special roles for your clients and use these roles to perform
        some actions specific to those client connections.

        You can also group your clients using the client labels. These client groups can be blacklisted in the Hazelcast
        Management Center so that they can be prevented from connecting to a cluster. See the related section in the
        Hazelcast Management Center Reference Manual for more information on this topic.

        You can define the labels with the <label> sub-element.
    -->
    <client-labels>
        <label>admin</label>
        <label>foo</label>
    </client-labels>

    <!--
        ===== HAZELCAST NETWORK CONFIGURATION =====

        The configuration to build your Hazelcast's network includes configuration for port, interface, discovery
        mechanism, SSL, encryption, etc. The configuration element's name is <network>.
        It has the following sub-elements:
        * <cluster-members>:
            This configuration lets you define the members in your cluster the client is connecting to. The members
            can be configured with the <address> sub-element.
        * <outbound-ports>:
            By default, Hazelcast lets the system pick up an ephemeral port during socket bind operation. But security
            policies/firewalls may require you to restrict outbound ports to be used by Hazelcast-enabled applications.
            You can specify these ports using <ports> under the element <outbound-ports>. You can give a single
            port number, comma separated multiple ports or port ranges. See the example below.
            <outbound-ports>
                <ports>33000-35000</ports>
                <ports>37000,37001,37002,37003</ports>
                <ports>38000,38500-38600</ports>
            </outbound-ports>
        * <smart-routing>:
            If true, client will route the key based operations to owner of the key at the best effort. Note that it
            uses a cached version of com.hazelcast.core.PartitionService#getPartitions() and doesn't guarantee that
            the operation will always be executed on the owner. The cached table is updated every second.
        * <redo-operation>:
            If true, client will redo the operations that were executing on the server and client lost the connection.
            This can be because of network, or simply because the member died. However it is not clear whether the
            application is performed or not. For idempotent operations this is harmless, but for non idempotent ones
            retrying can cause to undesirable effects. Note that the redo can perform on any member. If false, the
            operation will throw a RuntimeException that is wrapping a java.io.IOException.
        * <connection-timeout>:
            Connection timeout is the timeout value in milliseconds for members to accept client connection requests.
            The following are the example configurations. Its default value is 5000.
        * <connection-attempt-limit>:
            While the client is trying to connect initially to one of the members in the <cluster-members>, that
            member might not  be available at that moment. Instead of giving up, throwing an exception and stopping
            the client, the client retries as many the times configured by this setting. This is also the case
            when the previously established connection between the client and that member goes down.
        * <connection-attempt-period>:
            Connection attempt period is the duration in milliseconds between the connection attempts defined by
            <connection-attempt-limit>.
        * <socket-options>:
            You can configure the network socket options using this setting. It has the following sub-elements:
            - <tcp-no-delay>: Enables/disables the TCP_NODELAY socket option. Its default value is true.
            - <keep-alive>: Enables/disables the SO_KEEPALIVE socket option. Its default value is true.
            - <reuse-address>: Enables/disables the SO_REUSEADDR socket option. Its default value is true.
            - <linger-seconds>:
                Enables/disables SO_LINGER with the specified linger time in seconds.
                Its default value is 3.
            - <buffer-size>:
                Sets the SO_SNDBUF and SO_RCVBUF options to the specified value in KB for this Socket.
                Its default value is 128.
        * <socket-interceptor>:
            Lets you add custom hooks to join and perform connection procedures (like identity checking using
            Kerberos, etc.). This feature is available only in Hazelcast Enterprise. To be able to use it, you
            should first implement SocketInterceptor interface. Its configuration contains the class you
            implemented and socket interceptor properties. By default, it is disabled. The following is an example:
            <socket-interceptor enabled="true">
                <class-name>
                    com.hazelcast.examples.MySocketInterceptor
                </class-name>
                <properties>
                    <property name="kerberos-host">kerb-host-name</property>
                    <property name="kerberos-config-file">kerb.conf</property>
                </properties>
            </socket-interceptor>
        * <ssl>:
            Lets you configure SSL using the SSL context factory. This feature is available only in Hazelcast
            Enterprise. To be able to use it, encryption should NOT be enabled and you should first implement
            your SSLContextFactory class. Its configuration contains the factory class and SSL properties.
            By default, it is disabled. The following is an example:
            <ssl enabled="true">
                <factory-class-name>
                    com.hazelcast.nio.ssl.BasicSSLContextFactory
                </factory-class-name>
                <properties>
                    <property name="keyStore">keyStore</property>
                    <property name="keyStorePassword">keyStorePassword</property>
                    <property name="keyManagerAlgorithm">SunX509</property>
                    <property name="trustManagerAlgorithm">SunX509</property>
                    <property name="protocol">TLS</property>
                    <property name="mutualAuthentication">REQUIRED</property>
                </properties>
            </ssl>
        * <aws>:
            Set its "enabled" attribute to true for cluster discovery within Amazon EC2.
            Please refer to https://github.com/hazelcast/hazelcast-aws/#configuration for the configuration details.
        * <gcp>:
            Set its "enabled" attribute to true for cluster discovery within the Google Cloud Platform.
            Please refer to https://github.com/hazelcast/hazelcast-gcp/#configuration for the configuration details.
        * <azure>:
            Set its "enabled" attribute to true for cluster discovery within Microsoft Azure.
            Please refer to https://github.com/hazelcast/hazelcast-azure/#configuring-at-hazelcast-side for
            the configuration details.
        * <kubernetes>:
            Set its "enabled" attribute to true for cluster discovery in the Kubernetes environment.
            Please refer to https://github.com/hazelcast/hazelcast-kubernetes#hazelcast-configuration for
            the configuration details.
        * <eureka>:
            Set its "enabled" attribute to true for cluster discovery with using Eureka Service Registry.
            Please refer to https://github.com/hazelcast/hazelcast-eureka#hazelcast-configuration for
            the configuration details.
        * <hazelcast-cloud>:
            Set its "enabled" attribute to true for cluster discovery in the Hazelcast Cloud infrastructure. You need to
            define the mandatory <discovery-token> used by the discovery mechanism.
        * <discovery-strategies>:
            Set its "enabled" attribute to true for cluster discovery in various cloud infrastructures. You also need to set the
            value of "hazelcast.discovery.enabled" property to true. See the description of the <properties> element
            to learn how to do this.
            You can define multiple discovery strategies using the <discovery-strategy> sub-element and its
            properties. Please refer to
            http://docs.hazelcast.org/docs/latest/manual/html-single/index.html#discovering-cluster-members
            to see the properties you can use.
            The following is an example for EC2 cloud.
            <discovery-strategies>
                <discovery-strategy class="com.hazelcast.jclouds.JCloudsDiscoveryStrategy" enabled="true">
                <properties>
                    <property name="provider">aws-ec2</property>
                    <property name="identity">AWS_IDENTITY</property>
                    <property name="credential">AWS_CREDENTIAL</property>
                </properties>
                </discovery-strategy>
            </discovery-strategies>
        * <icmp-ping>:
            ICMP can be used in addition to the other detectors. It operates at OSI layer 3 and detects network
            and hardware issues more quickly. This detector needs to be turned on by setting the "enabled" attribute
            to true. It is turned off by default.

            It has the following sub-elements:
            * <timeout-milliseconds>:
                Number of milliseconds until a ping attempt is considered failed if there was no reply.
                Its default value is 1000 milliseconds.
            * <interval-milliseconds>:
                Interval, in milliseconds, between each ping attempt. 1000ms (1 sec) is also the minimum interval allowed.
                Its default value is 1000 milliseconds.
            * <max-attempts>:
                Maximum number of ping attempts before the member gets suspected by the detector. Its default value is 3.
            * <ttl>:
                Maximum number of hops the packets should go through. Its default value is 255. You can set to 0 to use
                your system’s default TTL.
            * <echo-fail-fast-on-startup>:
                Cluster Member will fail to start if it is unable to action an ICMP ping command when ICMP is enabled.
                Failure is usually due to OS level restrictions.
    -->
    <network>
        <cluster-members>
            <address>127.0.0.1</address>
            <address>127.0.0.2</address>
        </cluster-members>
        <outbound-ports>
            <ports>34600</ports>
            <ports>34700-34710</ports>
        </outbound-ports>
        <smart-routing>true</smart-routing>
        <redo-operation>true</redo-operation>
        <connection-timeout>60000</connection-timeout>
        <connection-attempt-period>3000</connection-attempt-period>
        <connection-attempt-limit>2</connection-attempt-limit>
        <socket-options>
            <tcp-no-delay>false</tcp-no-delay>
            <keep-alive>true</keep-alive>
            <reuse-address>true</reuse-address>
            <linger-seconds>3</linger-seconds>
            <buffer-size>128</buffer-size>
        </socket-options>
        <socket-interceptor enabled="true">
            <class-name>com.hazelcast.examples.MySocketInterceptor</class-name>
            <properties>
                <property name="foo">bar</property>
            </properties>
        </socket-interceptor>

        <ssl enabled="false">
            <factory-class-name>com.hazelcast.nio.ssl.BasicSSLContextFactory</factory-class-name>
            <properties>
                <property name="protocol">TLS</property>

                <property name="trustStore">/opt/hazelcast-client.truststore</property>
                <property name="trustStorePassword">secret.123456</property>
                <property name="trustStoreType">JKS</property>

                <!-- Following properties are only needed when the mutual authentication is used. -->
                <property name="keyStore">/opt/hazelcast-client.keystore</property>
                <property name="keyStorePassword">keystorePassword123</property>
                <property name="keyStoreType">JKS</property>
            </properties>
        </ssl>
        <aws enabled="true" connection-timeout-seconds="11">
            <inside-aws>true</inside-aws>
            <access-key>TEST_ACCESS_KEY</access-key>
            <secret-key>TEST_SECRET_KEY</secret-key>
            <region>us-east-1</region>
            <host-header>ec2.amazonaws.com</host-header>
            <security-group-name>hazelcast-sg</security-group-name>
            <tag-key>type</tag-key>
            <tag-value>hz-nodes</tag-value>
        </aws>
        <gcp enabled="false">
            <zones>us-east1-b,us-east1-c</zones>
        </gcp>
        <azure enabled="false">
            <client-id>CLIENT_ID</client-id>
            <client-secret>CLIENT_SECRET</client-secret>
            <tenant-id>TENANT_ID</tenant-id>
            <subscription-id>SUB_ID</subscription-id>
            <cluster-id>HZLCAST001</cluster-id>
            <group-name>GROUP-NAME</group-name>
        </azure>
        <kubernetes enabled="false">
            <namespace>MY-KUBERNETES-NAMESPACE</namespace>
            <service-name>MY-SERVICE-NAME</service-name>
            <service-label-name>MY-SERVICE-LABEL-NAME</service-label-name>
            <service-label-value>MY-SERVICE-LABEL-VALUE</service-label-value>
        </kubernetes>
        <eureka enabled="false">
            <self-registration>true</self-registration>
            <namespace>hazelcast</namespace>
        </eureka>
        <icmp-ping enabled="false">
            <timeout-milliseconds>2000</timeout-milliseconds>
            <interval-milliseconds>3000</interval-milliseconds>
            <ttl>100</ttl>
            <max-attempts>5</max-attempts>
            <echo-fail-fast-on-startup>false</echo-fail-fast-on-startup>
        </icmp-ping>
        <hazelcast-cloud enabled="false">
            <discovery-token>EXAMPLE_TOKEN</discovery-token>
        </hazelcast-cloud>
        <discovery-strategies>
            <node-filter class="DummyFilterClass" />
            <discovery-strategy class="DummyDiscoveryStrategy1" enabled="true">
                <properties>
                    <property name="key-string">foo</property>
                    <property name="key-int">123</property>
                    <property name="key-boolean">true</property>
                </properties>
            </discovery-strategy>
        </discovery-strategies>
    </network>
    <!--
        The <executor-pool-size> element lets you configure the pool size for an internal executor service
        (different from the data structure Executor Service) that has threads and queues to perform internal operations
        such as handling responses. This parameter specifies the size of the pool of threads which perform these
        operations laying in the executor’s queue. If not configured, this parameter has the value of 5 x core size of
        the client, i.e., it is 20 for a machine that has 4 cores.
    -->
    <executor-pool-size>40</executor-pool-size>

    <!--
        ===== HAZELCAST SECURITY CONFIGURATION =====

        This feature is available only in Hazelcast Enterprise. Configuration element's name is <security>.
        It has the following sub-elements:
        * <credentials>:
            The name of the class implementing Hazelcast's Credentials interface.
        * <credentials-factory>:
            Specifies the name and properties of your class that you developed by implementing Hazelcast's Credentials
            interface.
            This element has a mandatory "class-name" attribute where you should define the factory class implementing
            ICredentialsFactory used to create Credentials objects.
            With the <properties> sub-element, you can define properties for the factory class. The properties can be
            defined with the <property> sub-element nested in the <properties>. The <property> element has the attribute
            "name" used to define the name of the attribute. The value of the property is defined in the body.
    -->
    <security>
        <credentials>com.hazelcast.security.UsernamePasswordCredentials</credentials>
        <credentials-factory class-name="com.hazelcast.examples.MyCredentialsFactory">
            <properties>
                <property name="property">value</property>
            </properties>
        </credentials-factory>
    </security>

    <!--
        ===== HAZELCAST LISTENER CONFIGURATIONS =====

        Configuration used to register the listeners that you created by implementing Hazelcast's
        MembershipListener, InstanceListener and MigrationListener interfaces.
    -->
    <listeners>
        <listener>com.hazelcast.examples.MembershipListener</listener>
        <listener>com.hazelcast.examples.InstanceListener</listener>
        <listener>com.hazelcast.examples.MigrationListener</listener>
    </listeners>

    <!--
        ===== HAZELCAST SERIALIZATION CONFIGURATION =====

        Configuration element's name is <serialization>.
        It has the following sub-elements:
        * <portable-version>:
            Version of the portable serialization. Portable version is used to differentiate two
            of the same classes that have changes such as a new field or a new field type.
        * <use-native-byte-order>:
            Set as true if you want to use the native byte order of the underlying platform. Its default value is false.
        * <byte-order>:
            Specifies the byte order that the serialization will use. Its default value is BIG_ENDIAN. Available values
            are BIG_ENDIAN and LITTLE_ENDIAN.
        * <enable-compression>:
            Set as true to enable compression when default Java serialization is used. Its default value is false.
        * <enable-shared-object>:
            Set as true to enable shared object when default Java serialization is used. Its default value is false.
        * <allow-unsafe>:
            Set as true to allow the usage of unsafe. Its default value is false.
        * <data-serializable-factories>:
            Lists your class implementations of Hazelcast's DataSerializableFactory using the <data-serializable-factory>
            sub-elements. Each factory has the required "factory-id" attribute that you should give as the ID of your
            factory.
        * <portable-factories>:
            Lists your class implementations of Hazelcast's PortableFactory using the <portable-factory>
            sub-elements. Each factory has the required "factory-id" attribute that you should give as the ID of your
            factory.
        * <serializers>:
            Lists the serializers (classes) that you implement using Hazelcast's StreamSerializer, ByteArraySerializer,
            Global Serializer, etc. Global serializer should be specified using the <global-serializer> sub-element.
            For others, use the <serializer> sub-element.

            The <serializer> sub-element has two required attributes:
            - class-name: Full class name of the serializer you implemented.
            - type-class: Type of your serializer class implementation.

            The <global-serializer> sub-element has an optional boolean "override-java-serialization" attribute. If you set
            it as true, the Java serialization step will be handled by the global serializer, not by the Java Serializable or
            Externalizable.
        * <check-class-def-errors>:
            If set to true, serialization system will check the class definitions error at the start of serialization process
            and throw a Serialization Exception with the error definition.
        * <java-serialization-filter>:
            Allows to configure blacklisting and whitelisting for deserialized classes when Java serialization is used.
    -->
    <serialization>
        <portable-version>3</portable-version>
        <use-native-byte-order>true</use-native-byte-order>
        <byte-order>BIG_ENDIAN</byte-order>
        <enable-compression>false</enable-compression>
        <enable-shared-object>true</enable-shared-object>
        <allow-unsafe>false</allow-unsafe>
        <data-serializable-factories>
            <data-serializable-factory factory-id="1">com.hazelcast.examples.DataSerializableFactory
            </data-serializable-factory>
        </data-serializable-factories>
        <portable-factories>
            <portable-factory factory-id="2">com.hazelcast.examples.PortableFactory</portable-factory>
        </portable-factories>
        <serializers>
            <global-serializer override-java-serialization="true">com.hazelcast.examples.GlobalSerializerFactory
            </global-serializer>
            <serializer type-class="com.hazelcast.examples.DummyType"
                        class-name="com.hazelcast.examples.SerializerFactory"/>
        </serializers>
        <check-class-def-errors>true</check-class-def-errors>
        <java-serialization-filter>
            <blacklist>
                <class>com.acme.app.BeanComparator</class>
            </blacklist>
            <whitelist>
                <class>java.lang.String</class>
                <class>example.Foo</class>
                <package>com.acme.app</package>
                <package>com.acme.app.subpkg</package>
                <prefix>java</prefix>
                <prefix>[</prefix>
                <prefix>com.</prefix>
            </whitelist>
        </java-serialization-filter>
    </serialization>
    <!--
        ===== HAZELCAST HIGH-DENSITY MEMORY STORE CONFIGURATION =====

        This feature is available only in Hazelcast Enterprise HD. Configuration element's name is
        <native-memory>.
        It has the following attributes:
        - enabled:
            Set as true to enable the High-Density Memory Store usage. Its default value is false.
        - allocator-type:
            Type of the memory allocator. Its default value is POOLED. Available values are as follows:
        * STANDARD: Allocates/frees the memory using default OS memory manager.
        * POOLED: Manages memory blocks in thread local pools.

        It has the following sub-elements:
        - <size>:
            Size of the total native memory to allocate. You can give the size using its "value" attribute and the unit
            using its "unit" attribute. Unit can be bytes, kilobytes, megabytes and gigabytes. Default value is 128 and
            default unit is MEGABYTES.
        - <min-block-size>:
            Minimum size of the blocks in bytes to split and fragment a page block to assign to an allocation request.
            It is used only by the POOLED memory allocator. The value has to be power of two.  Default value is 16.
        - <page-size>:
            Size of the page in bytes to allocate memory as a block. It is used only by the POOLED memory allocator. Its
            default value is 1 << 22 (about 4 MB).
        - <metadata-space-percentage>:
            Percentage of the allocated native memory that is used for the metadata such as indexes, offsets, etc. It is
            used only by the POOLED memory allocator. Its default value is 12.5.
    -->
    <native-memory enabled="false" allocator-type="POOLED">
        <size unit="MEGABYTES" value="128"/>
        <min-block-size>1</min-block-size>
        <page-size>1</page-size>
        <metadata-space-percentage>40.5</metadata-space-percentage>
    </native-memory>
    <!--
        ===== HAZELCAST PROXY FACTORY CONFIGURATION =====

        Configuration element's name is <proxy-factories>.
        The client proxy factories can be defined with the <proxy-factory> sub-element. It has the following attributes:
        * "class-name": The name of the client proxy factory class.
        * "service": The name of the service.
    -->
    <proxy-factories>
        <proxy-factory class-name="com.hazelcast.examples.ProxyXYZ1" service="sampleService1"/>
        <proxy-factory class-name="com.hazelcast.examples.ProxyXYZ2" service="sampleService1"/>
        <proxy-factory class-name="com.hazelcast.examples.ProxyXYZ3" service="sampleService3"/>
    </proxy-factories>

    <!--
        ===== HAZELCAST LOAD BALANCER CONFIGURATION =====

        Configuration element's name is <load-balancer>.
        It has the attribute "type". The valid values for the type of the load balancer are"
        * "random": The member the operations to be sent to is chosen randomly.
        * "round-robin": The member the operations to be sent to is chosen in a round-robin fashion.
    -->
    <load-balancer type="random"/>

    <!--
        ===== HAZELCAST NEAR CACHE CONFIGURATION =====

        Configuration element's name is <near-cache>.
        It has the following attribute:
        - name: You can give a name for your Near Cache. It is optional and its default value is "default".

        It has the following sub-elements:
            - <max-size>:
                Maximum size of the Near Cache. When this is reached, Near Cache is evicted based on the policy defined.
                Any integer between 0 and Integer.MAX_VALUE. 0 means Integer.MAX_VALUE. Its default value is 0.
            - <time-to-live-seconds>:
                Maximum number of seconds for each entry to stay in the Near Cache. Entries that are older than this
                period are automatically evicted from the Near Cache. Any integer between 0 and Integer.MAX_VALUE.
                0 means infinite. Its default value is 0.
            - <max-idle-seconds>:
                Maximum number of seconds each entry can stay in the Near Cache as untouched (not read). Entries that
                are not read more than this period are removed from the Near Cache. Any integer between 0 and
                Integer.MAX_VALUE. 0 means Integer.MAX_VALUE. Its default value is 0.
            - <eviction-policy>:
                Eviction policy configuration. Its default values is NONE. Available values are as follows:
                - NONE:
                    No items will be evicted and the property max-size will be ignored. You still
                    can combine it with time-to-live-seconds and max-idle-seconds.
                - LRU: 	Least Recently Used.
                - LFU: 	Least Frequently Used.
                - <invalidate-on-change>:
                    Specifies whether the cached entries are evicted when the entries are updated or removed. Its default
                    value is true.
            - <in-memory-format>:
                Specifies in which format data will be stored in your Near Cache. Note that a map's in-memory format
                can be different from that of its Near Cache.
                Available values are as follows:
                - BINARY:
                    Data will be stored in serialized binary format. It is the default option.
                - OBJECT:
                    Data will be stored in deserialized form.
                - NATIVE:
                    Data will be stored in the Near Cache that uses Hazelcast's High-Density Memory Store feature.
                    This option is available only in Hazelcast Enterprise HD. Note that a map and its Near Cache
                    can independently use High-Density Memory Store. For example, while your map does not use
                    High-Density Memory Store, its Near Cache can use it.
            - <cache-local-entries>:
                Specifies whether the local entries will be cached. It can be useful when in-memory format for
                Near Cache is different from that of the map. By default, it is disabled.
            - <invalidate-on-change>:
                Specifies whether the cached entries are evicted when the entries are updated or removed.
                Its default value is true.
            - <serialize-keys>:
                Specifies if the keys of a Near Cache entry should be serialized or not. Serializing the keys has
                a big impact on the read performance of the Near Cache. It should just be activated when you have
                mutable keys, which are changed after use for the Near Cache. Its default value is false.
            - <eviction>:
                Configuration for the eviction when the in-memory format of the Near Cache is NATIVE. It has the
                following attributes:
                - size: Maximum size (entry count) of the Near Cache.
                - max-size-policy: Maximum size policy for eviction of the Near Cache. Available values are as follows:
                    * ENTRY_COUNT: Maximum entry count per member.
                    * USED_NATIVE_MEMORY_SIZE: Maximum used native memory size in megabytes.
                    * USED_NATIVE_MEMORY_PERCENTAGE: Maximum used native memory percentage.
                    * FREE_NATIVE_MEMORY_SIZE: Minimum free native memory size to trigger cleanup.
                    * FREE_NATIVE_MEMORY_PERCENTAGE: Minimum free native memory percentage to trigger cleanup.
                - eviction-policy: See the <eviction-policy> element above.

        Note that the Near Cache eviction configuration is different for NATIVE in-memory format.
        Proper eviction configuration example for NATIVE in-memory format :
           `<eviction max-size-policy="USED_NATIVE_MEMORY_SIZE" eviction-policy="LFU" size="60"/>`
    -->
    <near-cache name="default">
        <max-size>2000</max-size>
        <time-to-live-seconds>90</time-to-live-seconds>
        <max-idle-seconds>100</max-idle-seconds>
        <eviction-policy>LFU</eviction-policy>
        <in-memory-format>OBJECT</in-memory-format>
        <cache-local-entries>true</cache-local-entries>
        <invalidate-on-change>true</invalidate-on-change>
        <serialize-keys>true</serialize-keys>
        <local-update-policy>INVALIDATE</local-update-policy>
        <preloader enabled="true" directory="directory" store-initial-delay-seconds="50" store-interval-seconds="10"/>
    </near-cache>

    <near-cache name="NearCacheEvictionConfigExample">
        <eviction eviction-policy="LRU" max-size-policy="ENTRY_COUNT" size="10000"
                  comparator-class-name="com.hazelcast.examples.MyEvictionComparator"/>
    </near-cache>

    <!--
        ===== HAZELCAST FLAKE ID GENERATOR CONFIGURATION =====
        Configuration element's name is <flake-id-generator>. It has the required attribute "name" with which you
        can specify the name of your Flake ID generator.
        It has the following sub-elements:

        * <prefetch-count>:
            Sets how many IDs are pre-fetched on the background when one call to
            FlakeIdGenerator.newId() is made. Value must be in the range 1..100,000, default
            is 100.

            This setting pertains only to newId() calls made on the member that configured it.

        * <prefetch-validity-millis>:
            Sets for how long the pre-fetched IDs can be used. If this time elapses, a new batch of IDs
            will be fetched. Time unit is milliseconds, default is 600,000 (10 minutes).

            The IDs contain timestamp component, which ensures rough global ordering of IDs. If an
            ID is assigned to an object that was created much later, it will be much out of order. If you
            don't care about ordering, set this value to 0.

            This setting pertains only to newId() calls made on the member that configured it.
    -->
    <flake-id-generator name="default">
        <prefetch-count>100</prefetch-count>
        <prefetch-validity-millis>600000</prefetch-validity-millis>
    </flake-id-generator>

    <!--
        ===== HAZELCAST CONTINUOUS QUERY CACHE CONFIGURATION =====

        Configuration element's name is <query-caches>.
        You can create your query caches using its <query-cache> sub-element. It has the following attributes:
        - "name": Specifies the name of your query cache.
        - "mapName": Specifies the name of the map the query cache is used for.
        It has the following sub-elements:
        * <predicate>:
            Predicate to filter events which will be applied to the query cache.
        * <entry-listeners>:
            Adds listeners (listener classes) for your query cache entries. See <entry-listeners> in the map configuration above.
        * <include-value>:
            Set to true if you want to cache the value too. Its default value is true.
        * <batch-size>:
            Batch size used to determine the number of events sent in a batch to your query cache. Its default value is 1.
        * <buffer-size>:
            Maximum number of events which can be stored in a partition buffer. Its default value is 16.
        * <in-memory-format>:
            Type of the data to be stored in your query cache. See <in-memory-format> in the map configuration above.
        * <delay-seconds>:
            Minimum time in seconds that an event waits in the member's buffer. Its default value is 0.
        * <coalesce>:
            Set to true if you want to enable the coalescing of your query cache. Its default value is false.
        * <populate>:
            Set to true if you want to enable the initial population of your query cache. Its default value is true.
        * <eviction>:
            Configuration for the eviction of your query cache.
            It has the following attributes:
                - size: Maximum size (entry count) of the Near Cache.
                - max-size-policy: Maximum size policy for eviction of the Near Cache. Available values are as follows:
                    * ENTRY_COUNT: Maximum entry count per member.
                     * USED_NATIVE_MEMORY_SIZE: Maximum used native memory size in megabytes.
                     * USED_NATIVE_MEMORY_PERCENTAGE: Maximum used native memory percentage.
                     * FREE_NATIVE_MEMORY_SIZE: Minimum free native memory size to trigger cleanup.
                     * FREE_NATIVE_MEMORY_PERCENTAGE: Minimum free native memory percentage to trigger cleanup.
                - eviction-policy: Eviction policy configuration. Its default values is NONE. Available values are as follows:
                    - NONE:
                        No items will be evicted and the property max-size will be ignored. You still
                        can combine it with time-to-live-seconds and max-idle-seconds.
                    - LRU: 	Least Recently Used.
                    - LFU: 	Least Frequently Used.
                - comparator-class-name: The comparator to be used while comparing entries to be evicted.

        * <indexes>:
            You can define indexes for your map using this element's <index> sub-elements. Each <index> has
            only the boolean "ordered" attribute. For example, if you will have a ranged query for a field of a map
            entry, then this attribute should be set to true. But if the field has a boolean value, then it should
            be set to false. Its default value is false.
    -->
    <query-caches>
        <query-cache name="query-cache-class-name-predicate" mapName="map-name">
            <predicate type="class-name">com.hazelcast.examples.ExamplePredicate</predicate>
            <entry-listeners>
                <entry-listener include-value="true" local="false">com.hazelcast.examples.EntryListener</entry-listener>
            </entry-listeners>
            <include-value>true</include-value>
            <batch-size>1</batch-size>
            <buffer-size>16</buffer-size>
            <delay-seconds>0</delay-seconds>
            <in-memory-format>BINARY</in-memory-format>
            <coalesce>false</coalesce>
            <populate>true</populate>
            <eviction eviction-policy="LRU" max-size-policy="ENTRY_COUNT" size="10000"
                      comparator-class-name="com.hazelcast.examples.MyEvictionComparator"/>
            <indexes>
                <index ordered="false">name</index>
            </indexes>
        </query-cache>
        <query-cache name="query-cache-sql-predicate" mapName="map-name">
            <predicate type="sql">%age=40</predicate>
        </query-cache>
    </query-caches>

    <!--
        ===== HAZELCAST CONNECTION STRATEGY CONFIGURATION =====

        Configuration element's name is <connection-strategy>.
        It has the following attributes:
            - "async-start": If set to true, creating Hazelcast client doesn't not wait for connecting to the cluster.
            - "reconnect-mode": Defines the reconnection mode. The valid values are:
                - "ON":
                    Enables reconnection in a blocking manner where all the waiting invocations are blocked until a
                    cluster connection is established or failed. This is the default value.
                - "OFF": Disables the reconnection.
                - "ASYNC":
                    Enables reconnection in a non-blocking manner where all the waiting invocations receive a
                    HazelcastClientOfflineException.

        It has the <connection-retry> sub-element, defining the configuration used when retrying to connect to the cluster.
        It can be enabled by setting the "enabled" attribute to true.
        The <connection-retry> element has the following sub-elements:
            * <initial-backoff-millis>:
                Specifies how long to wait (backoff) after the first failure before retrying in milliseconds.
                Its default value is 1000 ms.
            * <max-backoff-millis>: Specifies the upper limit for the backoff in milliseconds. Its default value is 30000 ms.
            * <multiplier>: Factor to multiply the backoff after a failed retry. Its default value is 2.
            * <fail-on-max-backoff>:
                Specifies whether to fail when the max-backoff-millis has reached or continue waiting max-backoff-millis
                at each iteration. Its default value is false.
            * <jitter>: Specifies by how much to randomize backoffs. Its default value is 0.2.
    -->
    <connection-strategy async-start="true" reconnect-mode="ASYNC">
        <connection-retry enabled="true">
            <initial-backoff-millis>2000</initial-backoff-millis>
            <max-backoff-millis>60000</max-backoff-millis>
            <multiplier>3</multiplier>
            <fail-on-max-backoff>true</fail-on-max-backoff>
            <jitter>0.5</jitter>
        </connection-retry>
    </connection-strategy>

    <!--
        ===== HAZELCAST RELIABLE TOPIC CONFIGURATION =====

        Reliable Topic uses the same ITopic interface. The main difference is that it is backed up by
        Hazelcast Ringbuffer data structure. Reliable Topic messages are stored in the Ringbuffer
        Configuration element's name is <reliable-topic>. It has the optional attribute "name" with which you
        can specify the name of your Reliable Topic, which is the same name you give to your Ringbuffer.
        This attribute's default value is "default".
        It has the following sub-elements:
        * <read-batch-size>:
            Sets the read batch size.
            The ReliableTopic tries to read a batch of messages from the ringbuffer.
            It will get at least one, but if there are more available, then it will
            try to get more to increase throughput. The maximum read batch size can
            be influenced using the read batch size.
            Apart from influencing the number of messages to retrieve, the
            readBatchSize also determines how many messages will be processed
            by the thread running the MessageListener before it returns back
            to the pool to look for other MessageListeners that need to be
            processed. The problem with returning to the pool and looking for new work
            is that interacting with an executor is quite expensive due to contention
            on the work-queue. The more work that can be done without retuning to the
            pool, the smaller the overhead.
            If the readBatchSize is 10 and there are 50 messages available,
            10 items are retrieved and processed consecutively before the thread goes
            back to the pool and helps out with the processing of other messages.
            If the readBatchSize is 10 and there are 2 items available,
            2 items are retrieved and processed consecutively.
            If the readBatchSize is an issue because a thread will be busy
            too long with processing a single MessageListener and it can't
            help out other MessageListeners, increase the size of the
            threadpool so the other MessageListeners don't need to wait for
            a thread, but can be processed in parallel.
        * <topic-overload-policy>:
            A policy to deal with an overloaded topic; so topic where there is no place to store new messages.
            This policy can only be used in combination with the
            com.hazelcast.core.HazelcastInstance#getReliableTopic(String).
            The reliable topic uses a com.hazelcast.ringbuffer.Ringbuffer to
            store the messages. A ringbuffer doesn't track where readers are, so
            it has no concept of a slow consumers. This provides many advantages like
            high performance reads, but it also gives the ability to the reader to
            re-read the same message multiple times in case of an error.
            A ringbuffer has a limited, fixed capacity. A fast producer may overwrite
            old messages that are still being read by a slow consumer. To prevent
            this, we may configure a time-to-live on the ringbuffer (see
            com.hazelcast.config.RingbufferConfig#setTimeToLiveSeconds(int).
            Once the time-to-live is configured, the TopicOverloadPolicy
            controls how the publisher is going to deal with the situation that a
            ringbuffer is full and the oldest item in the ringbuffer is not old
            enough to get overwritten.
            Keep in mind that this retention period (time-to-live) can keep messages
            from being overwritten, even though all readers might have already completed reading.
            Its default value is BLOCK. Available values are as follows:
            - DISCARD_OLDEST:
                Using this policy, a message that has not expired can be overwritten.
                No matter the retention period set, the overwrite will just overwrite
                the item.
                This can be a problem for slow consumers because they were promised a
                certain time window to process messages. But it will benefit producers
                and fast consumers since they are able to continue. This policy sacrifices
                the slow producer in favor of fast producers/consumers.
            - DISCARD_NEWEST:
                Message that was to be published is discarded.
            - BLOCK:
                The caller will wait until there is space in the Ringbuffer.
            - ERROR:
                The publish call fails immediately.
    -->
    <reliable-topic name="rel-topic">
        <read-batch-size>100</read-batch-size>
        <topic-overload-policy>DISCARD_NEWEST</topic-overload-policy>
    </reliable-topic>

    <!--
        ===== HAZELCAST USER CODE DEPLOYMENT CONFIGURATION =====

        Configuration element's name is <user-code-deployment>. It has the required attribute "enabled" to
        specify whether this feature will be enabled on your cluster.
        It has the following sub-elements:
        * <jarPaths>: Defines the jar files containing the classes to load listed by the <jarPath> sub-element.
        * <classNames>: Defines the classes available in the client class path to load.
    -->
    <user-code-deployment enabled="true">
        <jarPaths>
            <jarPath>/User/test/sample.jar</jarPath>
            <jarPath>https://hazelcast.com/</jarPath>
            <jarPath>file://User/test/sample.jar</jarPath>
        </jarPaths>
        <classNames>
            <className>test.sampleClassName</className>
        </classNames>
    </user-code-deployment>

</hazelcast-client>
