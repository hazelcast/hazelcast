<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Copyright (c) 2008-2022, Hazelcast, Inc. All Rights Reserved.
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~ http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<!--
  This is a full example hazelcast-client.xml that includes all the
  configuration elements and attributes of a Hazelcast client.

  To use this, rename it to hazelcast-client.xml and place it in
  the directory where you start your Hazelcast client.

  To learn how to configure Hazelcast, please see the schema at
  https://hazelcast.com/schema/client-config/hazelcast-client-config-5.1.xsd
  or the Reference Manual at https://docs.hazelcast.com/
-->

<!--suppress XmlDefaultAttributeValue -->
<hazelcast-client xmlns="http://www.hazelcast.com/schema/client-config"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                  xsi:schemaLocation="http://www.hazelcast.com/schema/client-config
                  http://www.hazelcast.com/schema/client-config/hazelcast-client-config-5.1.xsd">

    <!--
        You can use the <import> element to load different Hazelcast declarative configuration files you prepared.
        You can import as many XML files as you want and hence compose your Hazelcast configuration
        out of those XML files. If you want to use the <import> element, it should be placed at the top of your
        Hazelcast XML file right after the <hazelcast-client> element, and it should have the required attribute "resource".

        Below is an example where the configuration files you want to include are located at your
        Hazelcast working directory:
        <import resource="your-client-configuration-file.xml"/>

        Below are examples showing a classpath or filesystem location:
        <import resource="file:///etc/hazelcast/your-client-configuration-file-1.xml"/>
        <import resource="classpath:your-client-configuration-file-2.xml"/>

        Below is an example showing property placeholders:
        <import resource="${environment}-your-client-configuration-file.xml"/>

    -->
    <import resource="your-client-configuration-XML-file"/>

    <!--
        The <config-replacers> allow to use variables (placeholders) within the configuration file and use an external
        class to retrieve correct values (replacements).

        It can be used for masking sensitive strings such as passwords for instance.

        Format of a variable is:
        $ PREFIX { STRING_TO_BE_REPLACED }      e.g. $ENC{nnPgTqJCcCQ=:23000:B4y/nlp6M0t3q6YiKImW+w==}

        The PREFIX value depends on the replacer implementation (e.g. "ENC" is used for the EncryptionReplacer)
        The STRING_TO_BE_REPLACED is the value which is provided to replacer implementation.
    -->
    <config-replacers fail-if-value-missing="false">
        <replacer class-name="com.hazelcast.config.replacer.EncryptionReplacer">
            <properties>
                <property name="passwordFile">password.txt</property>
                <property name="passwordUserProperties">false</property>
                <property name="cipherAlgorithm">DES</property>
                <property name="keyLengthBits">64</property>
                <property name="secretKeyAlgorithm">DES</property>
                <property name="secretKeyFactoryAlgorithm">PBKDF2WithHmacSHA1</property>
            </properties>
        </replacer>
    </config-replacers>

    <!--
        Specifies the cluster name. It's sent as part of the client authentication message to Hazelcast
        member(s).
    -->
    <cluster-name>my-cluster</cluster-name>

    <!--
        When Hazelcast instances are created, they are put in a global registry with their creation names.
        <instance-name> elements gives you the ability to get a specific Hazelcast instance from this registry
        by giving the instance's name.
    -->
    <instance-name>CLIENT_NAME</instance-name>

    <!--
        The <properties> element lets you add properties to some of the Hazelcast elements used to configure some of
        the Hazelcast client modules.
        You can define the name and value of these properties using the sub-element <property>.
        Please check the source of the ClientProperty class for the complete list of the client properties and their
        documentation.
    -->
    <properties>
        <property name="hazelcast.client.shuffle.member.list">true</property>
        <property name="hazelcast.client.heartbeat.timeout">60000</property>
        <property name="hazelcast.client.heartbeat.interval">5000</property>
        <property name="hazelcast.client.event.thread.count">5</property>
        <property name="hazelcast.client.event.queue.capacity">1000000</property>
        <property name="hazelcast.client.invocation.timeout.seconds">120</property>
    </properties>
    <!--
        The <client-labels> element lets you define labels in your Java client, similar to the way it can be done for the
        members. Through the client labels, you can assign special roles for your clients and use these roles to perform
        some actions specific to those client connections.

        You can also group your clients using the client labels. These client groups can be blacklisted in the Hazelcast
        Management Center so that they can be prevented from connecting to a cluster. See the related section in the
        Hazelcast Management Center Reference Manual for more information on this topic.

        You can define the labels with the <label> sub-element.
    -->
    <client-labels>
        <label>admin</label>
        <label>foo</label>
    </client-labels>

    <!--
     The <backup-ack-to-client-enabled> element lets you enable/disable backups ack to client.
     This feature reduces number of hops and increase performance for smart clients.
     It is enabled by default for smart clients. This config has no effect for unisocket clients.
    -->
    <backup-ack-to-client-enabled>true</backup-ack-to-client-enabled>

    <!--
        ===== HAZELCAST NETWORK CONFIGURATION =====

        The configuration to build your Hazelcast's network includes configuration for port, interface, discovery
        mechanism, SSL, encryption, etc. The configuration element's name is <network>.
        It has the following sub-elements:
        * <cluster-members>:
            This configuration lets you define the members in your cluster the client is connecting to. The members
            can be configured with the <address> sub-element.
        * <outbound-ports>:
            By default, Hazelcast lets the system pick up an ephemeral port during socket bind operation. But security
            policies/firewalls may require you to restrict outbound ports to be used by Hazelcast-enabled applications.
            You can specify these ports using <ports> under the element <outbound-ports>. You can give a single
            port number, comma separated multiple ports or port ranges. See the example below.
            <outbound-ports>
                <ports>33000-35000</ports>
                <ports>37000,37001,37002,37003</ports>
                <ports>38000,38500-38600</ports>
            </outbound-ports>
        * <smart-routing>:
            If true, client will route the key based operations to owner of the key at the best effort. Note that it
            uses a cached version of com.hazelcast.core.PartitionService#getPartitions() and doesn't guarantee that
            the operation will always be executed on the owner. The cached table is updated every second.
        * <redo-operation>:
            If true, client will redo the operations that were executing on the server and client lost the connection.
            This can be because of network, or simply because the member died. However it is not clear whether the
            application is performed or not. For idempotent operations this is harmless, but for non idempotent ones
            retrying can cause to undesirable effects. Note that the redo can perform on any member. If false, the
            operation will throw a RuntimeException that is wrapping a java.io.IOException.
        * <connection-timeout>:
            Connection timeout is the timeout value in milliseconds for members to accept client connection requests.
            The following are the example configurations. Its default value is 5000.
        * <socket-options>:
            You can configure the network socket options using this setting. It has the following sub-elements:
            - <tcp-no-delay>: Enables/disables the TCP_NODELAY socket option. Its default value is true.
            - <keep-alive>: Enables/disables the SO_KEEPALIVE socket option. Its default value is true.
            - <reuse-address>: Enables/disables the SO_REUSEADDR socket option. Its default value is true.
            - <linger-seconds>:
                Enables/disables SO_LINGER with the specified linger time in seconds.
                Its default value is 3.
            - <buffer-size>:
                Sets the SO_SNDBUF and SO_RCVBUF options to the specified value in KB for this Socket.
                Its default value is 128.
        * <socket-interceptor>:
            Lets you add custom hooks to join and perform connection procedures (like identity checking using
            Kerberos, etc.). This feature is available only in Hazelcast Enterprise. To be able to use it, you
            should first implement SocketInterceptor interface. Its configuration contains the class you
            implemented and socket interceptor properties. By default, it is disabled. The following is an example:
            <socket-interceptor enabled="true">
                <class-name>
                    com.hazelcast.examples.MySocketInterceptor
                </class-name>
                <properties>
                    <property name="kerberos-host">kerb-host-name</property>
                    <property name="kerberos-config-file">kerb.conf</property>
                </properties>
            </socket-interceptor>
        * <ssl>:
            Allows configuring TLS/SSL communication encryption. This feature is available only in Hazelcast Enterprise.
            The default configuration usually uses JSSE engine available in Java.
            Consult the Hazelcast documentation on how to integrate with OpenSSL/BoringSSL engines.
            <ssl enabled="true">
                <factory-class-name>
                    com.hazelcast.nio.ssl.OpenSSLEngineFactory
                </factory-class-name>
                <properties>
                    <property name="protocol">TLSv1.2</property>
                    <property name="trustCertCollectionFile">/opt/hazelcast/trusted-certs.pem</property>
                    <property name="keyFile">/opt/hazelcast/privkey.pem</property>
                    <property name="keyCertChainFile">/opt/hazelcast/chain.pem</property>
                </properties>
            </ssl>
        * <aws>:
            Set its "enabled" attribute to true for cluster discovery within Amazon EC2.
            Please refer to https://github.com/hazelcast/hazelcast-aws/#configuration for the configuration details.
        * <gcp>:
            Set its "enabled" attribute to true for cluster discovery within the Google Cloud Platform.
            Please refer to https://github.com/hazelcast/hazelcast-gcp/#configuration for the configuration details.
        * <azure>:
            Set its "enabled" attribute to true for cluster discovery within Microsoft Azure.
            Please refer to https://github.com/hazelcast/hazelcast-azure/#configuring-at-hazelcast-side for
            the configuration details.
        * <kubernetes>:
            Set its "enabled" attribute to true for cluster discovery in the Kubernetes environment.
            Please refer to https://github.com/hazelcast/hazelcast-kubernetes#hazelcast-configuration for
            the configuration details.
        * <eureka>:
            Set its "enabled" attribute to true for cluster discovery with using Eureka Service Registry.
            Please refer to https://github.com/hazelcast/hazelcast-eureka#hazelcast-configuration for
            the configuration details.
        * <hazelcast-cloud>:
            Set its "enabled" attribute to true for cluster discovery in the Hazelcast Cloud infrastructure. You need to
            define the mandatory <discovery-token> used by the discovery mechanism.
        * <discovery-strategies>:
            Set its "enabled" attribute to true for cluster discovery in various cloud infrastructures. You also need to set the
            value of "hazelcast.discovery.enabled" property to true. See the description of the <properties> element
            to learn how to do this.
            You can define multiple discovery strategies using the <discovery-strategy> sub-element and its
            properties. Please refer to
            http://docs.hazelcast.org/docs/latest/manual/html-single/index.html#discovering-cluster-members
            to see the properties you can use.
            The following is an example for EC2 cloud.
            <discovery-strategies>
                <discovery-strategy class="com.hazelcast.jclouds.JCloudsDiscoveryStrategy" enabled="true">
                <properties>
                    <property name="provider">aws-ec2</property>
                    <property name="identity">AWS_IDENTITY</property>
                    <property name="credential">AWS_CREDENTIAL</property>
                </properties>
                </discovery-strategy>
            </discovery-strategies>
        * <icmp-ping>:
            ICMP can be used in addition to the other detectors. It operates at OSI layer 3 and detects network
            and hardware issues more quickly. This detector needs to be turned on by setting the "enabled" attribute
            to true. It is turned off by default.

            It has the following sub-elements:
            * <timeout-milliseconds>:
                Number of milliseconds until a ping attempt is considered failed if there was no reply.
                Its default value is 1000 milliseconds.
            * <interval-milliseconds>:
                Interval, in milliseconds, between each ping attempt. 1000ms (1 sec) is also the minimum interval allowed.
                Its default value is 1000 milliseconds.
            * <max-attempts>:
                Maximum number of ping attempts before the member gets suspected by the detector. Its default value is 3.
            * <ttl>:
                Maximum number of hops the packets should go through. Its default value is 255. You can set to 0 to use
                your systemâ€™s default TTL.
            * <echo-fail-fast-on-startup>:
                Cluster Member will fail to start if it is unable to action an ICMP ping command when ICMP is enabled.
                Failure is usually due to OS level restrictions.
    -->
    <network>
        <cluster-members>
            <address>127.0.0.1</address>
            <address>127.0.0.2</address>
        </cluster-members>
        <outbound-ports>
            <ports>34600</ports>
            <ports>34700-34710</ports>
        </outbound-ports>
        <smart-routing>true</smart-routing>
        <redo-operation>true</redo-operation>
        <connection-timeout>60000</connection-timeout>
        <socket-options>
            <tcp-no-delay>false</tcp-no-delay>
            <keep-alive>true</keep-alive>
            <reuse-address>true</reuse-address>
            <linger-seconds>3</linger-seconds>
            <buffer-size>128</buffer-size>
        </socket-options>
        <socket-interceptor enabled="true">
            <class-name>com.hazelcast.examples.MySocketInterceptor</class-name>
            <properties>
                <property name="foo">bar</property>
            </properties>
        </socket-interceptor>

        <ssl enabled="false">
            <properties>
                <property name="protocol">TLS</property>

                <property name="trustStore">/opt/hazelcast-client.truststore</property>
                <property name="trustStorePassword">secret.123456</property>
                <property name="trustStoreType">PKCS12</property>

                <!-- Following properties are only needed when the mutual authentication is used. -->
                <property name="keyStore">/opt/hazelcast-client.keystore</property>
                <property name="keyStorePassword">keystorePassword123</property>
                <property name="keyStoreType">PKCS12</property>
            </properties>
        </ssl>
        <auto-detection enabled="false"/>
        <aws enabled="false">
            <access-key>my-access-key</access-key>
            <secret-key>my-secret-key</secret-key>
            <region>us-west-1</region>
            <host-header>ec2.amazonaws.com</host-header>
            <connection-timeout-seconds>7</connection-timeout-seconds>
            <read-timeout-seconds>7</read-timeout-seconds>
            <connection-retries>4</connection-retries>
            <hz-port>5701-5710</hz-port>
            <use-public-ip>true</use-public-ip>
            <tag-key>type</tag-key>
            <tag-value>hz-nodes</tag-value>
            <security-group-name>hazelcast-sg</security-group-name>
            <iam-role>dummy</iam-role>
            <!--
            <cluster>my-cluster</cluster>
            <family>test-family</family>
            <service-name>test-service</service-name>
            -->
        </aws>
        <gcp enabled="false">
            <private-key-path>key-path</private-key-path>
            <projects>project-1,project-2</projects>
            <region>us-central1</region>
            <zones>us-central1-b,us-central1-c</zones>
            <label>key=value</label>
            <hz-port>5701-5710</hz-port>
            <use-public-ip>true</use-public-ip>
        </gcp>
        <azure enabled="false">
            <instance-metadata-available>false</instance-metadata-available>
            <client-id>CLIENT_ID</client-id>
            <client-secret>CLIENT_SECRET</client-secret>
            <tenant-id>TENANT_ID</tenant-id>
            <subscription-id>SUB_ID</subscription-id>
            <resource-group>RESOURCE-GROUP-NAME</resource-group>
            <scale-set>SCALE-SET-NAME</scale-set>
            <tag>TAG-NAME=HZLCAST001</tag>
            <hz-port>5701-5707</hz-port>
            <use-public-ip>true</use-public-ip>
        </azure>
        <kubernetes enabled="false">
            <namespace>MY-KUBERNETES-NAMESPACE</namespace>
            <service-name>MY-SERVICE-NAME</service-name>
            <service-label-name>MY-SERVICE-LABEL-NAME</service-label-name>
            <service-label-value>MY-SERVICE-LABEL-VALUE</service-label-value>
        </kubernetes>
        <eureka enabled="false">
            <self-registration>true</self-registration>
            <namespace>hazelcast</namespace>
        </eureka>
        <icmp-ping enabled="false">
            <timeout-milliseconds>2000</timeout-milliseconds>
            <interval-milliseconds>3000</interval-milliseconds>
            <ttl>100</ttl>
            <max-attempts>5</max-attempts>
            <echo-fail-fast-on-startup>false</echo-fail-fast-on-startup>
        </icmp-ping>
        <hazelcast-cloud enabled="false">
            <discovery-token>EXAMPLE_TOKEN</discovery-token>
        </hazelcast-cloud>
        <discovery-strategies>
            <node-filter class="DummyFilterClass"/>
            <discovery-strategy class="DummyDiscoveryStrategy1" enabled="true">
                <properties>
                    <property name="key-string">foo</property>
                    <property name="key-int">123</property>
                    <property name="key-boolean">true</property>
                </properties>
            </discovery-strategy>
        </discovery-strategies>
    </network>

    <!--
        ===== HAZELCAST SECURITY CONFIGURATION =====

        This feature is available only in Hazelcast Enterprise. Configuration element's name is <security>.
        It has one of the following sub-elements:
        * <credentials-factory>:
            Specifies the name and properties of your class that you developed by implementing Hazelcast's Credentials
            interface.
            This element has a mandatory "class-name" attribute where you should define the factory class implementing
            ICredentialsFactory used to create Credentials objects.
            With the <properties> sub-element, you can define properties for the factory class. The properties can be
            defined with the <property> sub-element nested in the <properties>. The <property> element has the attribute
            "name" used to define the name of the attribute. The value of the property is defined in the body.
        * <username-password>
            Defines a static UsernamePasswordCredentials instance as the client's identity. It has mandatory
            "username" and "password" attributes.
        * <token>
            Defines a static TokenCredentials instance as the client's identity. It can have attribute "encoding".
            Content of the element is token value in given encoding (or in plain text).
        * <kerberos>
            Uses Kerberos service ticket (wrapped as GSS-API init token) as the identity.
            It may reference a security realm  in the <realms> section. The realm is used for the Kerberos authentication.
    -->
    <security>
        <credentials-factory class-name="com.hazelcast.examples.MyCredentialsFactory">
            <properties>
                <property name="property">value</property>
            </properties>
        </credentials-factory>
        <!--
        <username-password username="client1" password="s3crEt"/>
        <token encoding="base64">SGF6ZWxjYXN0</token>
        <kerberos>
            <realm>HAZELCAST.COM</realm>
            <security-realm>krb5Initiator</security-realm>
            <service-name-prefix>hz/</service-name-prefix>
            <use-canonical-hostname>true</use-canonical-hostname>
            <spn>hz/127.0.0.1@HAZELCAST.COM</spn>
        </kerberos>
         -->
        <realms>
            <realm name="krb5Initiator">
                <authentication>
                    <jaas>
                        <login-module class-name="com.sun.security.auth.module.Krb5LoginModule" usage="REQUIRED">
                            <properties>
                                <property name="isInitiator">true</property>
                                <property name="useTicketCache">false</property>
                                <property name="doNotPrompt">true</property>
                                <property name="useKeyTab">true</property>
                                <property name="storeKey">true</property>
                                <property name="principal">jduke@HAZELCAST.COM</property>
                                <property name="keyTab">/opt/jduke.keytab</property>
                            </properties>
                        </login-module>
                    </jaas>
                </authentication>
            </realm>
        </realms>
    </security>

    <!--
        ===== HAZELCAST LISTENER CONFIGURATIONS =====

        Configuration used to register the listeners that you created by implementing Hazelcast's
        MembershipListener and MigrationListener interfaces.
    -->
    <listeners>
        <listener>com.hazelcast.examples.MembershipListener</listener>
        <listener>com.hazelcast.examples.MigrationListener</listener>
    </listeners>

    <!--
        ===== HAZELCAST SERIALIZATION CONFIGURATION =====

        Configuration element's name is <serialization>.
        It has the following sub-elements:
        * <portable-version>:
            Version of the portable serialization. Portable version is used to differentiate two
            of the same classes that have changes such as a new field or a new field type.
        * <use-native-byte-order>:
            Set as true if you want to use the native byte order of the underlying platform. Its default value is false.
        * <byte-order>:
            Specifies the byte order that the serialization will use. Its default value is BIG_ENDIAN. Available values
            are BIG_ENDIAN and LITTLE_ENDIAN.
        * <enable-compression>:
            Set as true to enable compression when default Java serialization is used. Its default value is false.
        * <enable-shared-object>:
            Set as true to enable shared object when default Java serialization is used. Its default value is false.
        * <allow-unsafe>:
            Set as true to allow the usage of unsafe. Its default value is false.
        * <allow-override-default-serializers>:
            Set as true to allow override of default serializers. Its default value is false.
        * <data-serializable-factories>:
            Lists your class implementations of Hazelcast's DataSerializableFactory using the <data-serializable-factory>
            sub-elements. Each factory has the required "factory-id" attribute that you should give as the ID of your
            factory.
        * <portable-factories>:
            Lists your class implementations of Hazelcast's PortableFactory using the <portable-factory>
            sub-elements. Each factory has the required "factory-id" attribute that you should give as the ID of your
            factory.
        * <serializers>:
            Lists the serializers (classes) that you implement using Hazelcast's StreamSerializer, ByteArraySerializer,
            Global Serializer, etc. Global serializer should be specified using the <global-serializer> sub-element.
            For others, use the <serializer> sub-element.

            The <serializer> sub-element has two required attributes:
            - class-name: Full class name of the serializer you implemented.
            - type-class: Type of your serializer class implementation.

            The <global-serializer> sub-element has an optional boolean "override-java-serialization" attribute. If you set
            it as true, the Java serialization step will be handled by the global serializer, not by the Java Serializable or
            Externalizable.
        * <check-class-def-errors>:
            If set to true, serialization system will check the class definitions error at the start of serialization process
            and throw a Serialization Exception with the error definition.
        * <java-serialization-filter>:
            Allows to configure blacklisting and whitelisting for deserialized classes when Java serialization is used.
    -->
    <serialization>
        <portable-version>3</portable-version>
        <use-native-byte-order>true</use-native-byte-order>
        <byte-order>BIG_ENDIAN</byte-order>
        <enable-compression>false</enable-compression>
        <enable-shared-object>true</enable-shared-object>
        <allow-unsafe>false</allow-unsafe>
        <allow-override-default-serializers>false</allow-override-default-serializers>
        <data-serializable-factories>
            <data-serializable-factory factory-id="1">com.hazelcast.examples.DataSerializableFactory
            </data-serializable-factory>
        </data-serializable-factories>
        <portable-factories>
            <portable-factory factory-id="2">com.hazelcast.examples.PortableFactory</portable-factory>
        </portable-factories>
        <serializers>
            <global-serializer override-java-serialization="true">com.hazelcast.examples.GlobalSerializerFactory
            </global-serializer>
            <serializer type-class="com.hazelcast.examples.DummyType"
                        class-name="com.hazelcast.examples.SerializerFactory"/>
        </serializers>
        <check-class-def-errors>true</check-class-def-errors>
        <java-serialization-filter>
            <blacklist>
                <class>com.acme.app.BeanComparator</class>
            </blacklist>
            <whitelist>
                <class>java.lang.String</class>
                <class>example.Foo</class>
                <package>com.acme.app</package>
                <package>com.acme.app.subpkg</package>
                <prefix>java</prefix>
                <prefix>[</prefix>
                <prefix>com.</prefix>
            </whitelist>
        </java-serialization-filter>
        <compact-serialization enabled="true">
            <registered-classes>
                <class>
                    com.hazelcast.examples.DummyType
                </class>
                <class type-name="dummy" serializer="com.hazelcast.examples.DummyTypeSerializer">
                    com.hazelcast.examples.DummyTypeWithSerializer
                </class>
            </registered-classes>
        </compact-serialization>
    </serialization>
    <!--
        ===== HAZELCAST HIGH-DENSITY MEMORY STORE CONFIGURATION =====

        This feature is available only in Hazelcast Enterprise HD. Configuration element's name is
        <native-memory>.
        It has the following attributes:
        - enabled:
            Set as true to enable the High-Density Memory Store usage. Its default value is false.
        - allocator-type:
            Type of the memory allocator. Its default value is POOLED. Available values are as follows:
        * STANDARD: Allocates/frees the memory using default OS memory manager.
        * POOLED: Manages memory blocks in thread local pools.

        It has the following sub-elements:
        - <size>:
            Size of the total native memory to allocate. You can give the size using its "value" attribute and the unit
            using its "unit" attribute. Unit can be bytes, kilobytes, megabytes and gigabytes. Default value is 128 and
            default unit is MEGABYTES.
        - <min-block-size>:
            Minimum size of the blocks in bytes to split and fragment a page block to assign to an allocation request.
            It is used only by the POOLED memory allocator. The value has to be power of two.  Default value is 16.
        - <page-size>:
            Size of the page in bytes to allocate memory as a block. It is used only by the POOLED memory allocator. Its
            default value is 1 << 22 (about 4 MB).
        - <metadata-space-percentage>:
            Percentage of the allocated native memory that is used for the metadata such as indexes, offsets, etc. It is
            used only by the POOLED memory allocator. Its default value is 12.5.
    -->
    <native-memory enabled="false" allocator-type="POOLED">
        <size unit="MEGABYTES" value="128"/>
        <min-block-size>1</min-block-size>
        <page-size>1</page-size>
        <metadata-space-percentage>40.5</metadata-space-percentage>
        <!-- Simple configuration for single-socket machines with non-volatile memory -->
        <!-- <persistent-memory-directory>/mnt/optane</persistent-memory-directory> -->
        <!-- Advanced configuration for non-volatile memory -->
        <persistent-memory enabled="true" mode="MOUNTED">
            <directories>
                <directory numa-node="0">/mnt/pmem0</directory>
                <directory numa-node="1">/mnt/pmem1</directory>
            </directories>
        </persistent-memory>
    </native-memory>
    <!--
        ===== HAZELCAST PROXY FACTORY CONFIGURATION =====

        Configuration element's name is <proxy-factories>.
        The client proxy factories can be defined with the <proxy-factory> sub-element. It has the following attributes:
        * "class-name": The name of the client proxy factory class.
        * "service": The name of the service.
    -->
    <proxy-factories>
        <proxy-factory class-name="com.hazelcast.examples.ProxyXYZ1" service="sampleService1"/>
        <proxy-factory class-name="com.hazelcast.examples.ProxyXYZ2" service="sampleService1"/>
        <proxy-factory class-name="com.hazelcast.examples.ProxyXYZ3" service="sampleService3"/>
    </proxy-factories>

    <!--
        ===== HAZELCAST LOAD BALANCER CONFIGURATION =====

        Configuration element's name is <load-balancer>.
        It has the attribute "type". The valid values for the type of the load balancer are"
        * "random": The member the operations to be sent to is chosen randomly.
        * "round-robin": The member the operations to be sent to is chosen in a round-robin fashion.
        * "custom": The member the operations to be sent to is chosen by provided load balancer implementation.
                    The implementation class name is specified as text content.
    -->
    <load-balancer type="random"/>

    <!--
        ===== HAZELCAST NEAR CACHE CONFIGURATION =====

        Configuration element's name is <near-cache>.
        It has the following attribute:
        - name: You can give a name for your Near Cache. It is optional and its default value is "default".

        It has the following sub-elements:
            - <time-to-live-seconds>:
                Maximum number of seconds for each entry to stay in the Near Cache. Entries that are older than this
                period are automatically evicted from the Near Cache. Any integer between 0 and Integer.MAX_VALUE.
                0 means infinite. Its default value is 0.
            - <max-idle-seconds>:
                Maximum number of seconds each entry can stay in the Near Cache as untouched (not read). Entries that
                are not read more than this period are removed from the Near Cache. Any integer between 0 and
                Integer.MAX_VALUE. 0 means Integer.MAX_VALUE. Its default value is 0.
             - <invalidate-on-change>:
                Specifies whether the cached entries are evicted when the entries are updated or removed. Its default
                value is true.
            - <in-memory-format>:
                Specifies in which format data will be stored in your Near Cache. Note that a map's in-memory format
                can be different from that of its Near Cache.
                Available values are as follows:
                - BINARY:
                    Data will be stored in serialized binary format. It is the default option.
                - OBJECT:
                    Data will be stored in deserialized form.
                - NATIVE:
                    Data will be stored in the Near Cache that uses Hazelcast's High-Density Memory Store feature.
                    This option is available only in Hazelcast Enterprise HD. Note that a map and its Near Cache
                    can independently use High-Density Memory Store. For example, while your map does not use
                    High-Density Memory Store, its Near Cache can use it.
            - <invalidate-on-change>:
                Specifies whether the cached entries are evicted when the entries are updated or removed.
                Its default value is true.
            - <serialize-keys>:
                Specifies if the keys of a Near Cache entry should be serialized or not. Serializing the keys has
                a big impact on the read performance of the Near Cache. It should just be activated when you have
                mutable keys, which are changed after use for the Near Cache. Its default value is false.
            - <eviction>:
                Configuration for the eviction when the in-memory format of the Near Cache is NATIVE. It has the
                following attributes:
                - size: Maximum size (entry count) of the Near Cache.
                - max-size-policy: Maximum size policy for eviction of the Near Cache. Available values are as follows:
                    * ENTRY_COUNT: Maximum entry count per member.
                    * USED_NATIVE_MEMORY_SIZE: Maximum used native memory size in megabytes.
                    * USED_NATIVE_MEMORY_PERCENTAGE: Maximum used native memory percentage.
                    * FREE_NATIVE_MEMORY_SIZE: Minimum free native memory size to trigger cleanup.
                    * FREE_NATIVE_MEMORY_PERCENTAGE: Minimum free native memory percentage to trigger cleanup.
                - eviction-policy: See the <eviction-policy> element above.

        Note that the Near Cache eviction configuration is different for NATIVE in-memory format.
        Proper eviction configuration example for NATIVE in-memory format :
           `<eviction max-size-policy="USED_NATIVE_MEMORY_SIZE" eviction-policy="LFU" size="60"/>`
    -->
    <near-cache name="default">
        <time-to-live-seconds>90</time-to-live-seconds>
        <max-idle-seconds>100</max-idle-seconds>
        <in-memory-format>OBJECT</in-memory-format>
        <invalidate-on-change>true</invalidate-on-change>
        <serialize-keys>true</serialize-keys>
        <local-update-policy>INVALIDATE</local-update-policy>
        <preloader enabled="true" directory="directory" store-initial-delay-seconds="50" store-interval-seconds="10"/>
    </near-cache>

    <near-cache name="NearCacheEvictionConfigExample">
        <eviction eviction-policy="LRU" max-size-policy="ENTRY_COUNT" size="10000"
                  comparator-class-name="com.hazelcast.examples.MyEvictionComparator"/>
    </near-cache>

    <!--
        ===== HAZELCAST FLAKE ID GENERATOR CONFIGURATION =====
        Configuration element's name is <flake-id-generator>. It has the required attribute "name" with which you
        can specify the name of your Flake ID generator.
        It has the following sub-elements:

        * <prefetch-count>:
            Sets how many IDs are pre-fetched on the background when one call to
            FlakeIdGenerator.newId() is made. Value must be in the range 1..100,000, default
            is 100.

            This setting pertains only to newId() calls made on the member that configured it.

        * <prefetch-validity-millis>:
            Sets for how long the pre-fetched IDs can be used. If this time elapses, a new batch of IDs
            will be fetched. Time unit is milliseconds, default is 600,000 (10 minutes).

            The IDs contain timestamp component, which ensures rough global ordering of IDs. If an
            ID is assigned to an object that was created much later, it will be much out of order. If you
            don't care about ordering, set this value to 0.

            This setting pertains only to newId() calls made on the member that configured it.
    -->
    <flake-id-generator name="default">
        <prefetch-count>100</prefetch-count>
        <prefetch-validity-millis>600000</prefetch-validity-millis>
    </flake-id-generator>

    <!--
        ===== HAZELCAST CONTINUOUS QUERY CACHE CONFIGURATION =====

        Configuration element's name is <query-caches>.
        You can create your query caches using its <query-cache> sub-element. It has the following attributes:
        - "name": Specifies the name of your query cache.
        - "mapName": Specifies the name of the map the query cache is used for.
        It has the following sub-elements:
        * <predicate>:
            Predicate to filter events which will be applied to the query cache.
        * <entry-listeners>:
            Adds listeners (listener classes) for your query cache entries. See <entry-listeners> in the map configuration above.
        * <include-value>:
            Set to true if you want to cache the value too. Its default value is true.
        * <batch-size>:
            Batch size used to determine the number of events sent in a batch to your query cache. Its default value is 1.
        * <buffer-size>:
            Maximum number of events which can be stored in a partition buffer. Its default value is 16.
        * <in-memory-format>:
            Type of the data to be stored in your query cache. See <in-memory-format> in the map configuration above.
        * <delay-seconds>:
            Minimum time in seconds that an event waits in the member's buffer. Its default value is 0.
        * <coalesce>:
            Set to true if you want to enable the coalescing of your query cache. Its default value is false.
        * <populate>:
            Set to true if you want to enable the initial population of your query cache. Its default value is true.
        * <eviction>:
            Configuration for the eviction of your query cache.
            It has the following attributes:
                - size: Maximum size (entry count) of the Near Cache.
                - max-size-policy: Maximum size policy for eviction of the Near Cache. Available values are as follows:
                    * ENTRY_COUNT: Maximum entry count per member.
                     * USED_NATIVE_MEMORY_SIZE: Maximum used native memory size in megabytes.
                     * USED_NATIVE_MEMORY_PERCENTAGE: Maximum used native memory percentage.
                     * FREE_NATIVE_MEMORY_SIZE: Minimum free native memory size to trigger cleanup.
                     * FREE_NATIVE_MEMORY_PERCENTAGE: Minimum free native memory percentage to trigger cleanup.
                - eviction-policy: Eviction policy configuration. Its default values is NONE. Available values are as follows:
                    - NONE:
                        No items will be evicted and the property max-size will be ignored. You still
                        can combine it with time-to-live-seconds and max-idle-seconds.
                    - LRU: 	Least Recently Used.
                    - LFU: 	Least Frequently Used.
                - comparator-class-name: The comparator to be used while comparing entries to be evicted.

        * <indexes>:
            You can define indexes for your map using this element's <index> sub-elements. Index definition consists
            of type, optional name and the list of columns to be indexed. Valid types are SORTED (default) and HASH.
    -->
    <query-caches>
        <query-cache name="query-cache-class-name-predicate" mapName="map-name">
            <predicate type="class-name">com.hazelcast.examples.ExamplePredicate</predicate>
            <entry-listeners>
                <entry-listener include-value="true" local="false">com.hazelcast.examples.EntryListener</entry-listener>
            </entry-listeners>
            <include-value>true</include-value>
            <batch-size>1</batch-size>
            <buffer-size>16</buffer-size>
            <delay-seconds>0</delay-seconds>
            <in-memory-format>BINARY</in-memory-format>
            <coalesce>false</coalesce>
            <populate>true</populate>
            <serialize-keys>true</serialize-keys>
            <eviction eviction-policy="LRU" max-size-policy="ENTRY_COUNT" size="10000"
                      comparator-class-name="com.hazelcast.examples.MyEvictionComparator"/>
            <indexes>
                <index type="HASH">
                    <attributes>
                        <attribute>name</attribute>
                    </attributes>
                </index>
            </indexes>
        </query-cache>
        <query-cache name="query-cache-sql-predicate" mapName="map-name">
            <predicate type="sql">%age=40</predicate>
        </query-cache>
    </query-caches>

    <!--
        ===== HAZELCAST CONNECTION STRATEGY CONFIGURATION =====

        Configuration element's name is <connection-strategy>.
        It has the following attributes:
            - "async-start": If set to true, creating Hazelcast client doesn't not wait for connecting to the cluster.
            - "reconnect-mode": Defines the reconnection mode. The valid values are:
                - "ON":
                    Enables reconnection in a blocking manner where all the waiting invocations are blocked until a
                    cluster connection is established or failed. This is the default value.
                - "OFF": Disables the reconnection.
                - "ASYNC":
                    Enables reconnection in a non-blocking manner where all the waiting invocations receive a
                    HazelcastClientOfflineException.

        It has the <connection-retry> sub-element, defining the configuration used when retrying to connect to the cluster.
        The <connection-retry> element has the following sub-elements:
            * <initial-backoff-millis>:
                Specifies how long to wait (backoff) after the first failure before retrying in milliseconds.
                Its default value is 1000 ms.
            * <max-backoff-millis>: Specifies the upper limit for the backoff in milliseconds. Its default value is 30000 ms.
            * <multiplier>: Factor to multiply the backoff after a failed retry. Its default value is 1.05.
            * <cluster-connect-timeout-millis>: Timeout value in milliseconds for the client to give up to connect to
              the current cluster
              Depending on FailoverConfig, a client can shutdown or start trying on alternative cluster after reaching the timeout.
              Its default value is -1. For the default value, the client will not stop trying to connect to the cluster.
              If the failover client is used, the client will start trying to connect alternative clusters after
              120000 ms. For any other value, both the failover and non-failover client will use that as it is.
            * <jitter>: Specifies by how much to randomize backoffs. Its default value is 0.
    -->
    <connection-strategy async-start="true" reconnect-mode="ASYNC">
        <connection-retry>
            <initial-backoff-millis>2000</initial-backoff-millis>
            <max-backoff-millis>60000</max-backoff-millis>
            <multiplier>3</multiplier>
            <cluster-connect-timeout-millis>5000</cluster-connect-timeout-millis>
            <jitter>0.5</jitter>
        </connection-retry>
    </connection-strategy>

    <!--
        ===== HAZELCAST RELIABLE TOPIC CONFIGURATION =====

        Reliable Topic uses the same ITopic interface. The main difference is that it is backed up by
        Hazelcast Ringbuffer data structure. Reliable Topic messages are stored in the Ringbuffer
        Configuration element's name is <reliable-topic>. It has the optional attribute "name" with which you
        can specify the name of your Reliable Topic, which is the same name you give to your Ringbuffer.
        This attribute's default value is "default".
        It has the following sub-elements:
        * <read-batch-size>:
            Sets the read batch size.
            The ReliableTopic tries to read a batch of messages from the ringbuffer.
            It will get at least one, but if there are more available, then it will
            try to get more to increase throughput. The maximum read batch size can
            be influenced using the read batch size.
            Apart from influencing the number of messages to retrieve, the
            readBatchSize also determines how many messages will be processed
            by the thread running the MessageListener before it returns back
            to the pool to look for other MessageListeners that need to be
            processed. The problem with returning to the pool and looking for new work
            is that interacting with an executor is quite expensive due to contention
            on the work-queue. The more work that can be done without retuning to the
            pool, the smaller the overhead.
            If the readBatchSize is 10 and there are 50 messages available,
            10 items are retrieved and processed consecutively before the thread goes
            back to the pool and helps out with the processing of other messages.
            If the readBatchSize is 10 and there are 2 items available,
            2 items are retrieved and processed consecutively.
            If the readBatchSize is an issue because a thread will be busy
            too long with processing a single MessageListener and it can't
            help out other MessageListeners, increase the size of the
            threadpool so the other MessageListeners don't need to wait for
            a thread, but can be processed in parallel.
        * <topic-overload-policy>:
            A policy to deal with an overloaded topic; so topic where there is no place to store new messages.
            This policy can only be used in combination with the
            com.hazelcast.core.HazelcastInstance#getReliableTopic(String).
            The reliable topic uses a com.hazelcast.ringbuffer.Ringbuffer to
            store the messages. A ringbuffer doesn't track where readers are, so
            it has no concept of a slow consumers. This provides many advantages like
            high performance reads, but it also gives the ability to the reader to
            re-read the same message multiple times in case of an error.
            A ringbuffer has a limited, fixed capacity. A fast producer may overwrite
            old messages that are still being read by a slow consumer. To prevent
            this, we may configure a time-to-live on the ringbuffer (see
            com.hazelcast.config.RingbufferConfig#setTimeToLiveSeconds(int).
            Once the time-to-live is configured, the TopicOverloadPolicy
            controls how the publisher is going to deal with the situation that a
            ringbuffer is full and the oldest item in the ringbuffer is not old
            enough to get overwritten.
            Keep in mind that this retention period (time-to-live) can keep messages
            from being overwritten, even though all readers might have already completed reading.
            Its default value is BLOCK. Available values are as follows:
            - DISCARD_OLDEST:
                Using this policy, a message that has not expired can be overwritten.
                No matter the retention period set, the overwrite will just overwrite
                the item.
                This can be a problem for slow consumers because they were promised a
                certain time window to process messages. But it will benefit producers
                and fast consumers since they are able to continue. This policy sacrifices
                the slow producer in favor of fast producers/consumers.
            - DISCARD_NEWEST:
                Message that was to be published is discarded.
            - BLOCK:
                The caller will wait until there is space in the Ringbuffer.
            - ERROR:
                The publish call fails immediately.
    -->
    <reliable-topic name="rel-topic">
        <read-batch-size>100</read-batch-size>
        <topic-overload-policy>DISCARD_NEWEST</topic-overload-policy>
    </reliable-topic>

    <!--
        ===== HAZELCAST USER CODE DEPLOYMENT CONFIGURATION =====

        Configuration element's name is <user-code-deployment>. It has the required attribute "enabled" to
        specify whether this feature will be enabled on your cluster.
        It has the following sub-elements:
        * <jarPaths>: Defines the jar files containing the classes to load listed by the <jarPath> sub-element.
        * <classNames>: Defines the classes available in the client class path to load.
    -->
    <user-code-deployment enabled="true">
        <jarPaths>
            <jarPath>/User/test/sample.jar</jarPath>
            <jarPath>https://hazelcast.com/</jarPath>
            <jarPath>file://User/test/sample.jar</jarPath>
        </jarPaths>
        <classNames>
            <className>test.sampleClassName</className>
        </classNames>
    </user-code-deployment>

    <!--
        ===== HAZELCAST METRICS CONFIGURATION =====

        Configuration element's name is <metrics>.

        It has the following attributes:
        - enabled:
            The master-switch for the metrics collection. If this is set
            to false no metrics collection is done, regardless of the other
            settings. Its default value is true.

        It has the following sub-elements:
        * <jmx>:
            Defines the JMX related metrics configuration.

            It has the following attributes:
            * "enabled":
                Controls whether the metrics collected are exposed to
                through JMX. It is enabled by default.
                In order to expose the metrics, the metrics system need
                to be enabled via the enabled master-switch attribute.

        * <collection-frequency-seconds>:
            Sets the metrics collection frequency in seconds.
            By default, metrics are collected every 5 seconds.

    -->
    <metrics enabled="false">
        <jmx enabled="false"/>
        <collection-frequency-seconds>42</collection-frequency-seconds>
    </metrics>

    <!--
      ===== HAZELCAST INSTANCE TRACKING CONFIGURATION =====

      Configuration element's name is <instance-tracking>.

      It has the following attributes:
      - enabled:
          Enables or disables instance tracking.

      It has the following sub-elements:
      * <format-pattern>:
          Sets the pattern used to render the contents of the instance tracking file.
          It may contain placeholders for these properties:
          - "product": The instance product name, e.g. "Hazelcast" or "Hazelcast Enterprise".
          - "version": The instance version.
          - "mode": The instance mode which can be "server", "embedded" or "client".
          - "start_timestamp": The timestamp of when the instance was started expressed the difference,
          measured in milliseconds, between the current time and midnight, January 1, 1970 UTC
          - "licensed": If this instance is using a license or not. The value 0 signifies
          that there is no license set and the value 1 signifies that a license is in use.
          - "pid": Attempts to get the process ID value. The algorithm does not guarantee to get the
          process ID on all JVMs and operating systems so please test before use. In case we are unable to
          get the PID, the value will be -1.
          The placeholders are defined by a $HZ_INSTANCE_TRACKING{ prefix and followed by }. For instance,
          a placeholder for the "start_timestamp" would be $HZ_INSTANCE_TRACKING{start_timestamp}.
          The placeholders are resolved in a fail-safe manner. Any incorrect syntax
          is ignored and only the known properties are resolved, placeholders for
          any parameters which do not have defined values will be ignored. This also
          means that if there is a missing closing bracket in one of the placeholders,
          the property name will be resolved as anything from the opening bracket
          to the next closing bracket, which might contain additional opening brackets.
          If unset, a JSON formatted output will be used.
      * <file-name>:
          Sets the name of the file which will contain the tracking metadata. If left unset
          a file named "Hazelcast.process" will be created in the directory as returned by
          System.getProperty("java.io.tmpdir").
          The filename can contain placeholders that will be resolved in the same way
          as placeholders for the format pattern.

  -->
    <instance-tracking enabled="false">
        <file-name>hazelcast.process</file-name>
        <format-pattern>$HZ_INSTANCE_TRACKING{product}:$HZ_INSTANCE_TRACKING{version}</format-pattern>
    </instance-tracking>

</hazelcast-client>
