<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Copyright (c) 2008-2016, Hazelcast, Inc. All Rights Reserved.
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~ http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns="http://www.hazelcast.com/schema/config"
           targetNamespace="http://www.hazelcast.com/schema/config"
           elementFormDefault="qualified"
           attributeFormDefault="unqualified">

    <xs:element name="hazelcast">
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element ref="import"/>
                <xs:element name="group" type="cluster-group" minOccurs="0" maxOccurs="1"/>
                <xs:element name="license-key" type="xs:string" minOccurs="0" maxOccurs="1">
	                <xs:annotation>
	                    <xs:documentation>
	                        To use Hazelcast Enterprise, you need to set the license key here or programmatically.
	                    </xs:documentation>
	                </xs:annotation>
	            </xs:element>
                <xs:element name="instance-name" type="xs:string" minOccurs="0" maxOccurs="1"/>
                <xs:element name="management-center" type="management-center" minOccurs="0" maxOccurs="1"/>
                <xs:element name="properties" type="properties" minOccurs="0" maxOccurs="1"/>
                <xs:element name="wan-replication" type="wan-replication" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="network" type="network" minOccurs="0" maxOccurs="1"/>
                <xs:element name="partition-group" type="partition-group" minOccurs="0" maxOccurs="1"/>
                <xs:element name="executor-service" type="executor-service" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="queue" type="queue" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="map" type="map" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="multimap" type="multimap" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="replicatedmap" type="replicatedmap" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="cache" type="cache" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="list" type="list" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="set" type="set" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="topic" type="topic" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="reliable-topic" type="reliable-topic" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="jobtracker" type="jobtracker" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="semaphore" type="semaphore" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="ringbuffer" type="ringbuffer" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="listeners" type="listeners" minOccurs="0" maxOccurs="1"/>
                <xs:element name="serialization" type="serialization" minOccurs="0" maxOccurs="1"/>
                <xs:element name="native-memory" type="native-memory" minOccurs="0" maxOccurs="1"/>
                <xs:element name="services" type="services" minOccurs="0" maxOccurs="1"/>
                <xs:element name="security" type="security" minOccurs="0" maxOccurs="1"/>
                <xs:element ref="member-attributes" minOccurs="0" maxOccurs="1"/>
                <xs:element name="quorum" type="quorum" minOccurs="0" maxOccurs="1"/>
                <xs:element name="lite-member" type="lite-member" minOccurs="0" maxOccurs="1"/>
                <xs:element name="hot-restart-persistence" type="hot-restart-persistence" minOccurs="0" maxOccurs="1"/>
            </xs:choice>
            <xs:attribute name="id" type="xs:string" use="optional" default="default"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="import">
        <xs:complexType>
            <xs:complexContent>
                <xs:restriction base="xs:anyType">
                    <xs:attribute name="resource" type="xs:string" use="required"/>
                </xs:restriction>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:complexType name="map">
        <xs:all>
            <xs:element name="in-memory-format" type="in-memory-format" minOccurs="0" maxOccurs="1" default="BINARY">
                <xs:annotation>
                    <xs:documentation>
                        Data type used to store entries.
                        Possible values:
                        BINARY (default): keys and values are stored as binary data.
                        OBJECT: values are stored in their object forms.
                        NATIVE: keys and values are stored in native memory. Only available on Hazelcast Enterprise.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="statistics-enabled" type="xs:boolean" minOccurs="0" maxOccurs="1" default="true">
                <xs:annotation>
                    <xs:documentation>
                        True (default) if statistics gathering is enabled on the map, false otherwise.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="optimize-queries" type="xs:boolean" minOccurs="0" maxOccurs="1" default="false">
                <xs:annotation>
                    <xs:documentation>
                        This parameter is deprecated as of Hazelcast 3.6
                        Use cache-deserialized-values attribute instead.

                        When both optimize-query and cache-deserialized-values are used at the same time
                        Hazelcast will do its best to detect possible conflicts. Conflict detection
                        is done on best-effort basis and you should not rely on it.

                        If true, increases the speed of query processes in the map. It only works when in-memory-format
                        is set as BINARY and performs a pre-caching on the entries queried. Default value is false.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="cache-deserialized-values" type="cache-deserialized-values" minOccurs="0" maxOccurs="1" default="INDEX-ONLY">
                <xs:annotation>
                    <xs:documentation>
                        Control caching of de-serialized values. Caching makes query evaluation faster, but it cost memory.
                        Possible Values:
                        NEVER: Never cache de-serialized object
                        INDEX-ONLY: Cache values only when they are inserted into an index.
                        ALWAYS: Always cache de-serialized values.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="backup-count" type="backup-count" minOccurs="0" maxOccurs="1" default="1">
                <xs:annotation>
                    <xs:documentation>
                        Number of synchronous backups. For example, if 1 is set as the backup-count,
                        then all entries of the map will be copied to one other JVM for
                        fail-safety. Valid numbers are 0 (no backup), 1, 2 ... 6.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="async-backup-count" type="backup-count" minOccurs="0" maxOccurs="1" default="0">
                <xs:annotation>
                    <xs:documentation>
                        Number of asynchronous backups. For example, if 1 is set as the backup-count,
                        then all entries of the map will be copied to one other JVM for
                        fail-safety. Valid numbers are 0 (no backup), 1, 2 ... 6.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="time-to-live-seconds" type="xs:unsignedInt" minOccurs="0" maxOccurs="1" default="0">
                <xs:annotation>
                    <xs:documentation>
                        Maximum number of seconds for each entry to stay in the map. Entries that are
                        older than &lt;time-to-live-seconds&gt; and are not updated for &lt;time-to-live-seconds&gt;
                        are automatically evicted from the map.
                        Any integer between 0 and Integer.MAX_VALUE. 0 means infinite. Default is 0.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="max-idle-seconds" type="xs:unsignedInt" minOccurs="0" maxOccurs="1" default="0">
                <xs:annotation>
                    <xs:documentation>
                        Maximum number of seconds for each entry to stay idle in the map. Entries that are
                        idle(not touched) for more than &lt;max-idle-seconds&gt; are
                        automatically evicted from the map. The entry is touched if get, put or containsKey is called.
                        Any integer between 0 and Integer.MAX_VALUE. 0 means infinite. Default is 0.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="eviction-policy" type="eviction-policy" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Valid values are:
                        NONE (no eviction).
                        LRU (Least Recently Used).
                        LFU (Least Frequently Used).
                        NONE is the default.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="max-size" minOccurs="0" maxOccurs="1" default="0">
                <xs:annotation>
                    <xs:documentation>
                        Maximum size of the map.
                        Any integer between 0 and Integer.MAX_VALUE. 0 means Integer.MAX_VALUE. Default is 0.
                        For max-size to work, set the eviction-policy property to a value other than NONE.
                    </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:simpleContent>
                        <xs:extension base="xs:integer">
                            <!--policy attribute didn't converted into enumeration to support case-insensitivity-->
                            <xs:attribute name="policy" use="optional" default="PER_NODE">
				                <xs:annotation>
				                    <xs:documentation>
				                        Valid values are:
										PER_NODE: Maximum number of map entries in each Hazelcast instance.
                                        This is the default policy.
										PER_PARTITION: Maximum number of map entries within each partition. Storage size
										depends on the partition count in a Hazelcast instance.
                                        This attribute should not be used often.
										Avoid using this attribute with a small cluster: if the cluster is small it will
										be hosting more partitions, and therefore map entries, than that of a larger
										cluster. Thus, for a small cluster, eviction of the entries will decrease
										performance (the number of entries is large).
										USED_HEAP_SIZE: Maximum used heap size in megabytes per map for each Hazelcast instance.
										USED_HEAP_PERCENTAGE: Maximum used heap size percentage per map for each Hazelcast instance.
                                        If, for example, JVM is configured to have 1000 MB and this value is 10, then the map
										entries will be evicted when used heap size exceeds 100 MB.
										FREE_HEAP_SIZE: Minimum free heap size in megabytes for each JVM.
										FREE_HEAP_PERCENTAGE: Minimum free heap size percentage for each JVM.
                                        For example, if JVM is configured to have 1000 MB and this value is 10,
                                        then the map entries will be evicted when free heap size is below 100 MB.
                                        USED_NATIVE_MEMORY_SIZE: Maximum used native memory size in megabytes per map
                                        for each Hazelcast instance.
                                        USED_NATIVE_MEMORY_PERCENTAGE: Maximum used native memory size percentage per map
                                        for each Hazelcast instance.
                                        FREE_NATIVE_MEMORY_SIZE: Minimum free native memory size in megabytes
                                        for each Hazelcast instance.
                                        FREE_NATIVE_MEMORY_PERCENTAGE: Minimum free native memory size percentage
                                        for each Hazelcast instance.
				                    </xs:documentation>
				                </xs:annotation>
				            </xs:attribute>
                        </xs:extension>
                    </xs:simpleContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="eviction-percentage" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        When the map reaches maximum size, this specified percentage of the map will be evicted. Set to any
                        integer between 0 and 100.
                        For example, if 25 is set, 25% of the entries are evicted.
                        Beware that eviction mechanism is different for NATIVE in-memory format.
                        (It uses a probabilistic algorithm based on sampling. Please see documentation for further details.)
                        For this in-memory format, `minEvictionCheckMillis` has no effect
                    </xs:documentation>
                </xs:annotation>
                <xs:simpleType>
                    <xs:restriction base="xs:byte">
                        <xs:minInclusive value="0"/>
                        <xs:maxInclusive value="100"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:element>
            <xs:element name="min-eviction-check-millis" type="xs:unsignedLong" minOccurs="0" maxOccurs="1"
                        default="100">
                <xs:annotation>
                    <xs:documentation>
                        Minimum time in milliseconds which should pass before checking
                        if a partition of this map is evictable or not.
                        Default value is 100 millis.
                        Beware that eviction mechanism is different for NATIVE in-memory format.
                        (It uses a probabilistic algorithm based on sampling. Please see documentation for further details.)
                        For this in-memory format, `minEvictionCheckMillis` has no effect
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="merge-policy" type="xs:string" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        While recovering from split-brain (network partitioning), map entries in the small cluster
                        merge into the bigger cluster
                        based on the policy set here. When an entry merges into the cluster, an
                        entry with the same key might already exist in the cluster.
                        The values of these entries might be different for that same key. Which value should be set for the
                        key?
                        The conflict is resolved by the policy set here.
                        <p>
                            <br/>There are built-in merge policies, such as:
                            <br/>com.hazelcast.map.merge.PassThroughMergePolicy: the entry will be added if there is no
                            existing entry for the key.
                            <br/>com.hazelcast.map.merge.PutIfAbsentMapMergePolicy: the entry will be added if the merging
                            entry doesn't exist in the cluster.
                            <br/>com.hazelcast.map.merge.HigherHitsMapMergePolicy: the entry with the higher number of hits wins.
                            <br/>com.hazelcast.map.merge.LatestUpdateMapMergePolicy: the entry with the latest update wins.
                            <br/>Default policy is 'com.hazelcast.map.merge.PutIfAbsentMapMergePolicy'
                        </p>
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="read-backup-data" type="xs:boolean" minOccurs="0" maxOccurs="1" default="false">
                <xs:annotation>
                    <xs:documentation>
                        True if reading local backup entries is enabled, false otherwise.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="hot-restart" type="hot-restart" minOccurs="0" maxOccurs="1" />
            <xs:element name="map-store" type="map-store" minOccurs="0" maxOccurs="1"/>
            <xs:element name="near-cache" type="near-cache" minOccurs="0" maxOccurs="1"/>
            <xs:element name="wan-replication-ref" type="wan-replication-ref" minOccurs="0" maxOccurs="1"/>
            <xs:element name="indexes" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="index" type="index" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element name="attributes" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="attribute" type="map-attribute" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element name="entry-listeners" type="entry-listeners" minOccurs="0" maxOccurs="1"/>
            <xs:element name="partition-lost-listeners" type="partition-lost-listeners" minOccurs="0" maxOccurs="1"/>
            <xs:element name="partition-strategy" type="xs:string" minOccurs="0" maxOccurs="1"/>
            <xs:element name="quorum-ref" minOccurs="0" maxOccurs="1"/>
            <xs:element name="query-caches" type="query-caches" minOccurs="0" maxOccurs="1"/>
        </xs:all>
        <xs:attribute name="name" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the map.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:string"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="cache-entry-listeners">
        <xs:sequence>
            <xs:element name="cache-entry-listener" type="cache-entry-listener" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="cache-entry-listener">
        <xs:all>
            <xs:element name="cache-entry-listener-factory" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:attribute name="class-name" use="required"/>
                </xs:complexType>
            </xs:element>
            <xs:element name="cache-entry-event-filter-factory" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:attribute name="class-name" use="required"/>
                </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute name="old-value-required" type="xs:boolean" use="optional" default="false">
            <xs:annotation>
                <xs:documentation>
                    If true, previously assigned values for the affected keys will be sent to this
                    cache-entry-listener implementation. Setting this attribute to true
                    creates additional traffic. Default value is false.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="synchronous" type="xs:boolean" use="optional" default="false">
            <xs:annotation>
                <xs:documentation>
                    If true, this cache-entry-listener implementation will be called
                    in a synchronous manner. Default value is false.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="cache">
        <xs:all>
            <xs:element name="key-type" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:attribute name="class-name" use="required">
                        <xs:annotation>
                            <xs:documentation>
                                The fully qualified class name of the cache key type.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:complexType>
            </xs:element>
            <xs:element name="value-type" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:attribute name="class-name" use="required">
                        <xs:annotation>
                            <xs:documentation>
                                The fully qualified class name of the cache value type.
                            </xs:documentation>
                        </xs:annotation>
                   </xs:attribute>
                </xs:complexType>
            </xs:element>
            <xs:element name="statistics-enabled" type="xs:boolean" minOccurs="0" maxOccurs="1" default="false">
                <xs:annotation>
                    <xs:documentation>
                        True if statistics gathering is enabled on the cache, false (default) otherwise.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="management-enabled" type="xs:boolean" minOccurs="0" maxOccurs="1" default="false">
                <xs:annotation>
                    <xs:documentation>
                        True if management is enabled on the cache, false (default) otherwise.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="read-through" type="xs:boolean" minOccurs="0" maxOccurs="1" default="false">
                <xs:annotation>
                    <xs:documentation>
                        True if read-through caching is used, false (default) otherwise.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="write-through" type="xs:boolean" minOccurs="0" maxOccurs="1" default="false">
                <xs:annotation>
                    <xs:documentation>
                        True if write-through caching is used, false (default) otherwise.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="cache-loader-factory" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:attribute name="class-name" use="required">
                        <xs:annotation>
                            <xs:documentation>
                                The cache loader factory class name.
                            </xs:documentation>
                        </xs:annotation>
	                </xs:attribute>
                </xs:complexType>
            </xs:element>
            <xs:element name="cache-writer-factory" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:attribute name="class-name" use="required">
                        <xs:annotation>
                            <xs:documentation>
                                The cache writer factory class name.
                            </xs:documentation>
                        </xs:annotation>
	                </xs:attribute>
                </xs:complexType>
            </xs:element>
            <xs:element name="expiry-policy-factory" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:all>
                        <xs:annotation>
                            <xs:documentation>
                                Defines the expiry policy factory class name or
                                defines the expiry policy factory from predefined ones with duration configuration.
                            </xs:documentation>
                        </xs:annotation>
                        <xs:element name="timed-expiry-policy-factory"
                                    type="timed-expiry-policy-factory" minOccurs="0" maxOccurs="1"/>
                    </xs:all>
                    <xs:attribute name="class-name"/>
                </xs:complexType>
            </xs:element>
            <xs:element name="cache-entry-listeners" type="cache-entry-listeners" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        List of cache entry listeners.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="in-memory-format" type="in-memory-format" minOccurs="0" maxOccurs="1" default="BINARY">
                <xs:annotation>
                    <xs:documentation>
                        Data type used to store entries.
                        Possible values:
                        BINARY (default): keys and values are stored as binary data.
                        OBJECT: values are stored in their object forms.
                        NATIVE: keys and values are stored in native memory. Only available on Hazelcast Enterprise.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="backup-count" type="backup-count" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Number of synchronous backups. For example, if `1` is set as the `backup-count`,
                        then all entries of the cache are copied to one other instance as synchronous for fail-safety.
                        `backup-count` + `async-backup-count` cannot be bigger than maximum backup count which is `6`.
                        Valid numbers are 0 (no backup), 1, 2 ... 6.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="async-backup-count" type="backup-count" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Number of asynchronous backups. For example, if `1` is set as the `async-backup-count`,
                        then all entries of the cache are copied to one other instance as asynchronous for fail-safety.
                        `backup-count` + `async-backup-count` cannot be bigger than maximum backup count which is `6`.
                        Valid numbers are 0 (no backup), 1, 2 ... 6.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="eviction" type="eviction" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        When maximum size is reached, cache is evicted based on the eviction policy.

                        size:
                        maximum size can be any integer between 0 and Integer.MAX_VALUE.

                        Default value is 0.

                        max-size-policy:
                        max-size-policy has these valid values:
                        ENTRY_COUNT (Maximum number of cache entries in the cache),
                        USED_NATIVE_MEMORY_SIZE (Maximum used native memory size in megabytes per cache for each Hazelcast instance),
                        USED_NATIVE_MEMORY_PERCENTAGE (Maximum used native memory size percentage per cache for each Hazelcast instance),
                        FREE_NATIVE_MEMORY_SIZE (Maximum free native memory size in megabytes for each Hazelcast instance),
                        FREE_NATIVE_MEMORY_PERCENTAGE (Maximum free native memory size percentage for each Hazelcast instance).

                        Default value is "ENTRY_COUNT".

                        eviction-policy:
                        Eviction policy has these valid values:
                        LRU (Least Recently Used),
                        LFU (Least Frequently Used).

                        Default value is "LRU".
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="wan-replication-ref" type="wan-replication-ref" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Wan replication configuration for cache.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="quorum-ref" minOccurs="0" maxOccurs="1"/>
            <xs:element name="partition-lost-listeners" type="partition-lost-listeners" minOccurs="0" maxOccurs="1"/>
            <xs:element name="merge-policy" type="xs:string" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        While recovering from split-brain (network partitioning), cache entries in the small cluster
                        merge into the bigger cluster based on the policy set here.
                        When an entry merges into the cluster, an entry with the same key might already exist in the cluster.
                        The values of these entries might be different for that same key. Which value should be set for the
                        key? The conflict is resolved by the policy set here.
                        <p>
                            <br/>There are built-in merge policies, such as:
                            <br/>`com.hazelcast.cache.merge.PassThroughCacheMergePolicy` or `PASS_THROUGH`:
                            The entry will be added directly even though there is an existing entry for the key.
                            <br/>`com.hazelcast.cache.merge.PutIfAbsentCacheMergePolicy` or `PUT_IF_ABSENT`:
                            The entry will be added if there is no existing entry for the key.
                            <br/>`com.hazelcast.cache.merge.HigherHitsCacheMergePolicy` or `HIGHER_HITS`:
                            The entry with the higher number of hits wins.
                            <br/>`com.hazelcast.cache.merge.LatestAccessCacheMergePolicy` or `LATEST_ACCESS`:
                            The entry which has been accessed more recently wins.
                            <br/>Default policy is 'com.hazelcast.cache.merge.PassThroughCacheMergePolicy'
                        </p>
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="hot-restart" type="hot-restart" minOccurs="0" maxOccurs="1" />
        </xs:all>

        <xs:attribute name="name" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the cache.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:string"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="queue">
        <xs:all>
            <xs:element name="statistics-enabled" type="xs:boolean" minOccurs="0" maxOccurs="1" default="true">
                <xs:annotation>
                    <xs:documentation>
                        True (default) if statistics gathering is enabled on the queue, false otherwise.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="max-size" type="xs:unsignedInt" minOccurs="0" maxOccurs="1" default="0">
                <xs:annotation>
                    <xs:documentation>
                        Maximum number of items in the queue.
                        Any integer between 0 and Integer.MAX_VALUE. 0 means Integer.MAX_VALUE. Default is 0.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="backup-count" type="backup-count" minOccurs="0" maxOccurs="1" default="1">
                <xs:annotation>
                    <xs:documentation>
                        Number of synchronous backups. For example, if 1 is set as the backup-count,
                        then all entries of the queue are copied to one other JVM for
                        fail-safety. Valid numbers are 0 (no backup), 1, 2 ... 6.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="async-backup-count" type="backup-count" minOccurs="0" maxOccurs="1" default="0">
                <xs:annotation>
                    <xs:documentation>
                        Number of asynchronous backups. For example, if 1 is set as the backup-count,
                        then all entries of the queue are copied to one other JVM for
                        fail-safety. Valid numbers are 0 (no backup), 1, 2 ... 6.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="empty-queue-ttl" type="empty-queue-ttl" minOccurs="0" maxOccurs="1" default="-1">
                <xs:annotation>
                    <xs:documentation>
                        Used to purge unused or empty queues. If you define a value (time in seconds) for this element,
                        then your queue will be destroyed if it stays empty or unused for that time.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="item-listeners" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Lets you add listeners (listener classes) for the queue items. You can also set the attribute
                        include-value to true if you want the item event to contain the item values, and you can set
                        local to true if you want to listen to the items on the local node.
                    </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="item-listener" type="item-listener" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element ref="queue-store" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Includes the queue store factory class name and the following properties.

						Binary: By default, Hazelcast stores the queue items in serialized form in memory.
						Before it inserts the queue items into datastore, it deserializes them. But if you
						will not reach the queue store from an external application, you might prefer that the
						items be inserted in binary form. You can get rid of the de-serialization step; this
						would be a performance optimization. The binary feature is disabled by default.

						Memory Limit: This is the number of items after which Hazelcast will store items only to
						datastore. For example, if the memory limit is 1000, then the 1001st item will be put
						only to datastore. This feature is useful when you want to avoid out-of-memory conditions.
						The default number for memory-limit is 1000. If you want to always use memory, you can set
						it to Integer.MAX_VALUE.

						Bulk Load: When the queue is initialized, items are loaded from QueueStore in bulks. Bulk
						load is the size of these bulks. By default, bulk-load is 250.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:all>
        <xs:attribute name="name" use="optional" default="default">
            <xs:annotation>
                <xs:documentation>
                    Name of the queue.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:string"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="list">
        <xs:all>
            <xs:element name="statistics-enabled" type="xs:boolean" minOccurs="0" maxOccurs="1" default="true">
                <xs:annotation>
                    <xs:documentation>
                        True (default) if statistics gathering is enabled on the list, false otherwise.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="max-size" type="xs:unsignedInt" minOccurs="0" maxOccurs="1" default="0">
                <xs:annotation>
                    <xs:documentation>
                        Maximum size of the list.
                        Any integer between 0 and Integer.MAX_VALUE. 0 means Integer.MAX_VALUE. Default is 0.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="backup-count" type="backup-count" minOccurs="0" maxOccurs="1" default="1">
                <xs:annotation>
                    <xs:documentation>
                        Number of synchronous backups. For example, if 1 is set as the backup-count,
                        then all entries of the list are copied to one other JVM for
                        fail-safety. Valid numbers are 0 (no backup), 1, 2 ... 6.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="async-backup-count" type="backup-count" minOccurs="0" maxOccurs="1" default="0">
                <xs:annotation>
                    <xs:documentation>
                        Number of asynchronous backups. For example, if 1 is set as the backup-count,
                        then all entries of the list will be copied to one other JVM for
                        fail-safety. Valid numbers are 0 (no backup), 1, 2 ... 6.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="item-listeners" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Lets you add listeners (listener classes) for the list items. You can also set the attribute
                        include-value to true if you want the item event to contain the item values, and you can set
                        local to true if you want to listen to the items on the local node.
                    </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="item-listener" type="item-listener" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute name="name" use="optional" default="default">
            <xs:annotation>
                <xs:documentation>
                    Name of the list.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:string"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="set">
        <xs:all>
            <xs:element name="statistics-enabled" type="xs:boolean" minOccurs="0" maxOccurs="1" default="true">
                <xs:annotation>
                    <xs:documentation>
                        True (default) if statistics gathering is enabled on the set, false otherwise.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="max-size" type="xs:unsignedInt" minOccurs="0" maxOccurs="1" default="0">
                <xs:annotation>
                    <xs:documentation>
                        Maximum size of the set.
                        Any integer between 0 and Integer.MAX_VALUE. 0 means Integer.MAX_VALUE. Default is 0.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="backup-count" type="backup-count" minOccurs="0" maxOccurs="1" default="1">
                <xs:annotation>
                    <xs:documentation>
                        Number of synchronous backups. For example, if 1 is set as the backup-count,
                        then all entries of the set are copied to one other JVM for
                        fail-safety. Valid numbers are 0 (no backup), 1, 2 ... 6.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="async-backup-count" type="backup-count" minOccurs="0" maxOccurs="1" default="0">
                <xs:annotation>
                    <xs:documentation>
                        Number of asynchronous backups. For example, if 1 is set as the backup-count,
                        then all entries of the set will be copied to one other JVM for
                        fail-safety. Valid numbers are 0 (no backup), 1, 2 ... 6.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="item-listeners" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Lets you add listeners (listener classes) for the set items. You can also set the attribute
                        include-value to true if you want the item event to contain the item values, and you can set
                        local to true if you want to listen to the items on the local node.
                    </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="item-listener" type="item-listener" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute name="name" use="optional" default="default">
            <xs:annotation>
                <xs:documentation>
                    Name of the set.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:string"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="multimap">
        <xs:annotation>
            <xs:documentation>
                Hazelcast MultiMap is a specialized map where you can store multiple values under a single key.
                Just like any other distributed data structure implementation in Hazelcast, MultiMap is distributed
                and thread-safe. Hazelcast MultiMap is not an implementation of java.util.Map due to the difference
                in method signatures. It supports most features of Hazelcast Map except for indexing, predicates and
                MapLoader/MapStore.
            </xs:documentation>
        </xs:annotation>
        <xs:all>
            <xs:element name="backup-count" type="backup-count" minOccurs="0" maxOccurs="1" default="1">
                <xs:annotation>
                    <xs:documentation>
                        Number of synchronous backups. For example, if 1 is set as the backup-count,
                        then all entries of the multimap are copied to one other JVM for
                        fail-safety. Valid numbers are 0 (no backup), 1, 2 ... 6.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="async-backup-count" type="backup-count" minOccurs="0" maxOccurs="1" default="0">
                <xs:annotation>
                    <xs:documentation>
                        Number of asynchronous backups. For example, if 1 is set as the backup-count,
                        then all entries of the multimap are copied to one other JVM for
                        fail-safety. Valid numbers are 0 (no backup), 1, 2 ... 6.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="statistics-enabled" type="xs:boolean" minOccurs="0" maxOccurs="1" default="true">
                <xs:annotation>
                    <xs:documentation>
                        True (default) if statistics gathering is enabled on the multimap, false otherwise.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="value-collection-type" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Type of the value collection : SET or LIST.
                    </xs:documentation>
                </xs:annotation>
                <xs:simpleType>
                    <xs:restriction base="non-space-string">
                        <xs:enumeration value="SET"/>
                        <xs:enumeration value="LIST"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:element>
            <xs:element name="entry-listeners" type="entry-listeners" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Lets you add listeners (listener classes) for the multimap entries. You can also set the attribute
                        include-value to true if you want the item event to contain the entry values, and you can set
                        local to true if you want to listen to the entries on the local node.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <!--<xs:element name="partition-strategy" type="xs:string" minOccurs="0" maxOccurs="1" />-->
        </xs:all>
        <xs:attribute name="name" use="required">
           <xs:annotation>
               <xs:documentation>
                   Name of the multimap.
               </xs:documentation>
           </xs:annotation>
           <xs:simpleType>
                <xs:restriction base="xs:string"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="replicatedmap">
        <xs:annotation>
            <xs:documentation>
                A ReplicatedMap is a map-like data structure with weak consistency
                and values locally stored on every node of the cluster.
                Whenever a value is written asynchronously, the new value will be internally
                distributed to all existing cluster members, and eventually every node will have
                the new value.
                When a new node joins the cluster, the new node initially will request existing
                values from older nodes and replicate them locally.
            </xs:documentation>
        </xs:annotation>
        <xs:all>
            <xs:element name="in-memory-format" type="in-memory-format" minOccurs="0" maxOccurs="1" default="OBJECT">
                <xs:annotation>
                    <xs:documentation>
                        Data type used to store entries.
                        Possible values:
                        BINARY: keys and values are stored as binary data.
                        OBJECT (default): values are stored in their object forms.
                        NATIVE: keys and values are stored in native memory. Only available on Hazelcast Enterprise.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="concurrency-level" type="concurrency-level" minOccurs="0" maxOccurs="1" default="32">
                <xs:annotation>
                    <xs:documentation>
                        Number of parallel mutexes to minimize contention on keys. The default value is 32 which
                        is a good number for lots of applications. If higher contention is seen on writes to values
                        inside of the replicated map this value can be adjusted to the needs.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="replication-delay-millis" type="xs:unsignedInt" minOccurs="0" maxOccurs="1" default="100">
                <xs:annotation>
                    <xs:documentation>
                        Defines the number of milliseconds after a put is executed before the value is replicated
                        to other nodes. During this time, multiple puts can be operated and cached up to be sent
                        out all at once after the delay.
                        Default value is 100ms before a replication is operated. If set to 0, no delay is used and
                        all values are replicated one by one.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="async-fillup" type="xs:boolean" minOccurs="0" maxOccurs="1" default="true">
                <xs:annotation>
                    <xs:documentation>
                        True if the replicated map is available for reads before the initial
                        replication is completed, false otherwise. Default is true. If false, no Exception will be
                        thrown when the replicated map is not yet ready, but call is blocked until
                        the initial replication is completed.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="statistics-enabled" type="xs:boolean" minOccurs="0" maxOccurs="1" default="true">
                <xs:annotation>
                    <xs:documentation>
                        True (default) if statistics gathering is enabled on the replicated map, false otherwise.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="entry-listeners" type="entry-listeners" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Lets you add listeners (listener classes) for the replicated map entries. You can also set the attribute
                        include-value to true if you want the item event to contain the entry values, and you can set
                        local to true if you want to listen to the entries on the local node.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:all>
        <xs:attribute name="name" use="required">
            <xs:annotation>
               <xs:documentation>
                   Name of the replicated map.
               </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:string"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="topic">
        <xs:all>
            <xs:element name="statistics-enabled" type="xs:boolean" minOccurs="0" maxOccurs="1" default="true">
                <xs:annotation>
                    <xs:documentation>
                        True (default) if statistics gathering is enabled on the topic, false otherwise.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="global-ordering-enabled" type="xs:boolean" minOccurs="0" maxOccurs="1"
                        default="false">
			    <xs:annotation>
			        <xs:documentation>
			            Default is `false`, meaning there is no global order guarantee.
			        </xs:documentation>
			    </xs:annotation>
			</xs:element>
            <xs:element name="message-listeners" minOccurs="0" maxOccurs="1">
                <xs:annotation>
			        <xs:documentation>
			            Lets you add listeners (listener classes) for the topic messages.
			        </xs:documentation>
			    </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="message-listener" type="listener-base" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute name="name" use="optional" default="default">
            <xs:annotation>
                <xs:documentation>
                    The name of the topic.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:string"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="reliable-topic">
        <xs:all>
            <xs:element name="statistics-enabled" type="xs:boolean" minOccurs="0" maxOccurs="1" default="true">
                <xs:annotation>
                    <xs:documentation>
                        True (default) if statistics gathering is enabled on the reliable topic, false otherwise.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="message-listeners" minOccurs="0" maxOccurs="1">
                <xs:annotation>
			        <xs:documentation>
			            Lets you add listeners (listener classes) for the topic messages.
			        </xs:documentation>
			    </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="message-listener" type="listener-base" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>

            <xs:element name="read-batch-size" type="xs:int" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        The maximum number of items to read in a batch.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="topic-overload-policy" type="topic-overload-policy" minOccurs="0" maxOccurs="1">
                <xs:annotation>
	                <xs:documentation>
	                    Policy to handle an overloaded topic. Available values are `DISCARD_OLDEST`, `DISCARD_NEWEST`,
	                    `BLOCK` and `ERROR`. The default value is `BLOCK.
	                </xs:documentation>
                </xs:annotation>
	        </xs:element>
        </xs:all>
        <xs:attribute name="name" use="optional" default="default">
            <xs:annotation>
                <xs:documentation>
                    The name of the reliable topic.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:string"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="jobtracker">
        <xs:annotation>
            <xs:documentation>
                The JobTracker configuration is used to setup behavior of the Hazelcast MapReduce framework.
                Every JobTracker is capable of running multiple map reduce jobs at once and so once configuration
                is meant as a shared resource for all jobs created by the same JobTracker.
                The configuration gives full control over the expected load behavior and thread counts to be used.
            </xs:documentation>
        </xs:annotation>
        <xs:all>
            <xs:element name="max-thread-size" type="xs:nonNegativeInteger" minOccurs="0" maxOccurs="1" default="0">
                <xs:annotation>
                    <xs:documentation>
                        The maximum thread pool size of the JobTracker.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="queue-size" type="xs:nonNegativeInteger" minOccurs="0" maxOccurs="1" default="0">
                <xs:annotation>
                    <xs:documentation>
                        The maximum size of the queue; the maximum number of tasks that can wait to be processed. A
                        value of 0 means an unbounded queue.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="retry-count" type="xs:nonNegativeInteger" minOccurs="0" maxOccurs="1" default="0">
                <xs:annotation>
                    <xs:documentation>
                        retry-count is currently not used but reserved for later use where the framework will
                        automatically try to restart / retry operations from an available savepoint.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="chunk-size" type="xs:nonNegativeInteger" minOccurs="0" maxOccurs="1" default="1000">
                <xs:annotation>
                    <xs:documentation>
                        The number of emitted values before a chunk is sent to the reducers.
                        If your emitted values are big, you might want to change this to a lower value. If you want
                        to better balance your work, you might want to change this to a higher value.
                        A value of 0 means immediate transmission, but remember that low values mean higher traffic
                        costs.
                        A very high value might cause an OutOfMemoryError to occur if emitted values do not fit into
                        heap memory before being sent to reducers. To prevent this, you might want to use a combiner
                        to pre-reduce values on mapping nodes.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="communicate-stats" type="xs:boolean" minOccurs="0" maxOccurs="1" default="true">
                <xs:annotation>
                    <xs:documentation>
                        True if statistics (for example, about processed entries)
                        are transmitted to the job emitter, false otherwise. This might be used to show any kind of progress to
                        users inside of UI systems, but this produces additional traffic. If statistics are not needed, you might
                        want to deactivate this.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="topology-changed-strategy" type="topology-changed-strategy" minOccurs="0" maxOccurs="1"
                        default="CANCEL_RUNNING_OPERATION">
                <xs:annotation>
                    <xs:documentation>
                        Defines how the map reduce framework will react on topology
                        changes while executing a job.
                        Currently only CANCEL_RUNNING_OPERATION is fully supported; it throws an exception to
                        the job emitter (throws com.hazelcast.mapreduce.TopologyChangedException).
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:all>
        <xs:attribute name="name" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the JobTracker. Required.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:string"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="semaphore">
        <xs:all>
            <xs:element name="initial-permits" type="xs:unsignedInt" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        The thread count to which the concurrent access is limited. For example, if you set
                        it to "3", concurrent access to the object is limited to 3 threads.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="backup-count" type="backup-count" minOccurs="0" maxOccurs="1" default="1">
                <xs:annotation>
                    <xs:documentation>
                        Number of synchronous backups. For example, if 1 is set as the backup-count,
                        then all permits of the semaphore are copied to one other JVM for
                        fail-safety. Valid numbers are 0 (no backup), 1, 2 ... 6.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="async-backup-count" type="backup-count" minOccurs="0" maxOccurs="1" default="0">
                <xs:annotation>
                    <xs:documentation>
                        Number of asynchronous backups. For example, if 1 is set as the backup-count,
                        then all permits of the semaphore are copied to one other JVM for
                        fail-safety. Valid numbers are 0 (no backup), 1, 2 ... 6.
                    </xs:documentation>
                </xs:annotation>
	        </xs:element>
        </xs:all>
        <xs:attribute name="name" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the semaphore. Required.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:string"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="ringbuffer">
        <xs:all>
            <xs:element name="capacity" type="xs:unsignedInt" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Number of items in the ringbuffer. If no time-to-live-seconds is set, the size will always
                        be equal to capacity after the head completed the first loop around the ring. This is
                        because no items are getting retired.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="time-to-live-seconds" type="xs:unsignedInt" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Maximum number of seconds for each entry to stay in the ringbuffer. Entries that are
                        older than &lt;time-to-live-seconds&gt; and are not updated for &lt;time-to-live-seconds&gt;
                        are automatically evicted from the map.
                        Any integer between 0 and Integer.MAX_VALUE. 0 means infinite. Default is 0.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="backup-count" type="backup-count" minOccurs="0" maxOccurs="1" default="1">
                <xs:annotation>
                    <xs:documentation>
                        Number of synchronous backups. For example, if 1 is set as the backup-count,
                        then the items in the ringbuffer are copied to one other JVM for
                        fail-safety. Valid numbers are 0 (no backup), 1, 2 ... 6.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="async-backup-count" type="backup-count" minOccurs="0" maxOccurs="1" default="0">
                <xs:annotation>
                    <xs:documentation>
                        Number of asynchronous backups. For example, if 1 is set as the backup-count,
                        then the items in the ringbuffer are copied to one other JVM for
                        fail-safety. Valid numbers are 0 (no backup), 1, 2 ... 6.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="in-memory-format" type="in-memory-format" minOccurs="0" maxOccurs="1" default="BINARY">
                <xs:annotation>
                    <xs:documentation>
                        Data type used to store entries.
                        Possible values:
                        BINARY (default): keys and values are stored as binary data.
                        OBJECT: values are stored in their object forms.
                        NATIVE: keys and values are stored in native memory. Only available on Hazelcast Enterprise.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:all>
        <xs:attribute name="name" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the ringbuffer. Required.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:string"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="network">
        <xs:all>
            <xs:element name="public-address" type="xs:string" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Overrides the public address of a node. By default, a node selects its socket address
                        as its public address. But behind a network address translation (NAT), two endpoints (nodes)
                        may not be able to see/access each other. If both nodes set their public addresses to their
                        defined addresses on NAT, then they can communicate with each other. In this case, their
                        public addresses are not an address of a local network interface but a virtual address defined by NAT.
                        This is optional to set and useful when you have a private cloud.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="port" type="port" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        The ports which Hazelcast will use to communicate between cluster members. Its default value is 5701.
						It has the following attributes.
                            port-count: The default value is 100, meaning that Hazelcast will try to bind 100 ports.
                                If you set the value of port as 5701, as members join the cluster, Hazelcast tries to find
                                ports between 5701 and 5801. You can change the port count in cases like having large
                                instances on a single machine or you are willing to have only a few ports assigned.
                            auto-increment: Default value is true. If port is set to 5701, Hazelcast will try to find free
                                ports between 5701 and 5801. Normally, you will not need to change this value, but it comes
                                in handy when needed. You may also want to choose to use only one port. In that case, you can
                                disable the auto-increment feature of port by setting its value as false.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="reuse-address" type="xs:boolean" minOccurs="0" maxOccurs="1" default="false">
               <xs:annotation>
                    <xs:documentation>
                        When you shutdown a cluster member, the server socket port will be in the TIME_WAIT
                        state for the next couple of minutes. If you start the member right after shutting it down,
                        you may not be able to bind it to the same port because it is in the TIME_WAIT state. If you
                        set reuse-address to true, the TIME_WAIT state is ignored and you can bind the member to the
                        same port again. Default value is false.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="outbound-ports" type="outbound-ports" minOccurs="0" maxOccurs="1">
               <xs:annotation>
                    <xs:documentation>
                        By default, Hazelcast lets the system pick up an ephemeral port during socket bind operation.
                        But security policies/firewalls may require to restrict outbound ports to be used by
                        Hazelcast-enabled applications. To fulfill this requirement, you can configure Hazelcast to use
                        only defined outbound ports.
                        outbound-ports has the ports attribute to allow you to define outbound ports.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="join" type="join" minOccurs="0" maxOccurs="1"/>
            <xs:element name="interfaces" type="interfaces" minOccurs="0" maxOccurs="1"/>
            <xs:element name="ssl" type="ssl" minOccurs="0" maxOccurs="1"/>
            <xs:element name="socket-interceptor" type="socket-interceptor" minOccurs="0" maxOccurs="1"/>
            <xs:element name="symmetric-encryption" type="symmetric-encryption" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        encryption algorithm such as
                        DES/ECB/PKCS5Padding,
                        PBEWithMD5AndDES,
                        AES/CBC/PKCS5Padding,
                        Blowfish,
                        DESede
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:all>
    </xs:complexType>
    <xs:complexType name="tcp-ip">
        <xs:choice maxOccurs="unbounded">
            <xs:element name="required-member" type="xs:string" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        IP address of the required member. Cluster will form only if the member with this IP
                        address is found.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:sequence>
                <xs:element name="member" type="xs:string" minOccurs="0" maxOccurs="unbounded" default="127.0.0.1">
	                <xs:annotation>
	                    <xs:documentation>
	                        IP address(es) of one or more well known members. Once members are connected to these
                            well known ones, all member addresses will be communicated with each other.
	                    </xs:documentation>
	                </xs:annotation>
	            </xs:element>
            </xs:sequence>
            <xs:element name="interface" type="xs:string" minOccurs="0" maxOccurs="1"
                        default="127.0.0.1"/>
            <xs:element name="members" type="xs:string" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Comma separated IP addresses of one or more well known members.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="member-list" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="member" type="xs:string" minOccurs="0" maxOccurs="unbounded"
                                    default="127.0.0.1"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
        </xs:choice>
        <xs:attribute name="enabled" type="xs:boolean" use="optional" default="false">
            <xs:annotation>
                <xs:documentation>
                    Specifies whether the TCP/IP discovery is enabled or not. Default value is false.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="connection-timeout-seconds" type="xs:int" use="optional" default="5">
            <xs:annotation>
                <xs:documentation>
                    The maximum amount of time Hazelcast is going to try to connect to a well known member
                    before giving up. Setting it to a too low value could mean that a member is not able
                    to connect to a cluster. Setting it to a too high value means that member startup could
                    slow down because of longer timeouts (e.g. when a well known member is not up). Increasing
                    this value is recommended if you have many IPs listed and the members cannot properly
                    build up the cluster. Its default value is 5.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="port">
        <xs:simpleContent>
            <xs:extension base="xs:unsignedShort">
                <xs:attribute name="auto-increment" type="xs:boolean" use="optional" default="true"/>
                <xs:attribute name="port-count" type="xs:unsignedInt" use="optional" default="100"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:complexType name="outbound-ports">
        <xs:sequence>
            <xs:element name="ports" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="multicast">
        <xs:all>
            <xs:element name="multicast-group" type="xs:string" minOccurs="0" maxOccurs="1" default="224.2.2.3">
	            <xs:annotation>
	                <xs:documentation>
	                    The multicast group IP address. Specify it when you want to create clusters within the
	                    same network. Values can be between 224.0.0.0 and 239.255.255.255. Default value is 224.2.2.3.
	                </xs:documentation>
	            </xs:annotation>
	        </xs:element>
            <xs:element name="multicast-port" type="xs:unsignedShort" minOccurs="0" maxOccurs="1" default="54327">
	            <xs:annotation>
	                <xs:documentation>
	                    The multicast socket port through which the Hazelcast member listens and sends discovery messages.
	                    Default value is 54327.
	                </xs:documentation>
	            </xs:annotation>
	        </xs:element>
            <xs:element name="multicast-timeout-seconds" type="xs:int" minOccurs="0" maxOccurs="1" default="2">
	            <xs:annotation>
	                <xs:documentation>
	                    Only when the nodes are starting up, this timeout (in seconds) specifies the period during
	                    which a node waits for a multicast response from another node. For example, if you set it
	                    to 60 seconds, each node will wait for 60 seconds until a leader node is selected.
	                    Its default value is 2 seconds.
	                </xs:documentation>
	            </xs:annotation>
	        </xs:element>
            <xs:element name="multicast-time-to-live" type="xs:int" minOccurs="0" maxOccurs="1" default="32">
	            <xs:annotation>
	                <xs:documentation>
	                    Time-to-live value for multicast packets sent out to control the scope of multicasts.
	                </xs:documentation>
	            </xs:annotation>
	        </xs:element>
            <xs:element name="trusted-interfaces" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Includes IP addresses of trusted members. When a node wants to join to the cluster,
                        its join request will be rejected if it is not a trusted member. You can give an IP
                        addresses range using the wildcard (*) on the last digit of the IP address
                        (e.g. 192.168.1.* or 192.168.1.100-110).
                    </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="interface" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute name="enabled" type="xs:boolean" use="optional" default="true">
            <xs:annotation>
                <xs:documentation>
                    Specifies whether the multicast discovery is enabled or not. Values can be true or false.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="loopbackModeEnabled" type="xs:boolean" use="optional" default="true"/>
    </xs:complexType>
    <xs:complexType name="aws">
        <xs:all>
            <xs:element name="access-key" type="xs:string" minOccurs="0" maxOccurs="1">
	            <xs:annotation>
	                <xs:documentation>
	                    Access key of your account on EC2.
	                </xs:documentation>
	            </xs:annotation>
	        </xs:element>
            <xs:element name="secret-key" type="xs:string" minOccurs="0" maxOccurs="1">
	            <xs:annotation>
	                <xs:documentation>
	                    Secret key of your account on EC2.
	                </xs:documentation>
	            </xs:annotation>
	        </xs:element>
            <xs:element name="iam-role" type="xs:string" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        IAM role that binds with your instance.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="region" type="xs:string" minOccurs="0" maxOccurs="1">
	            <xs:annotation>
	                <xs:documentation>
	                    The region where your nodes are running. Default value is us-east-1.
	                    Needs to be specified if the region is other than the default one.
	                </xs:documentation>
	            </xs:annotation>
	        </xs:element>
            <xs:element name="host-header" type="xs:string" minOccurs="0" maxOccurs="1">
	            <xs:annotation>
	                <xs:documentation>
	                    The URL that is the entry point for a web service. It is optional.
	                </xs:documentation>
	            </xs:annotation>
	        </xs:element>
            <xs:element name="security-group-name" type="xs:string" minOccurs="0" maxOccurs="1">
	            <xs:annotation>
	                <xs:documentation>
	                    Name of the security group you specified at the EC2 management console.
	                    It is used to narrow the Hazelcast nodes to be within this group.
	                    It is optional.
	                </xs:documentation>
	            </xs:annotation>
	        </xs:element>
            <xs:element name="tag-key" type="xs:string" minOccurs="0" maxOccurs="1">
	            <xs:annotation>
	                <xs:documentation>
	                    To narrow the members in the cloud down to only Hazelcast nodes, you can set
	                    this to the one you specified in the EC2 console. It is optional.
	                </xs:documentation>
	            </xs:annotation>
	        </xs:element>
            <xs:element name="tag-value" type="xs:string" minOccurs="0" maxOccurs="1">
	            <xs:annotation>
	                <xs:documentation>
	                    To narrow the members in the cloud down to only Hazelcast nodes, you can set
	                    this to the one you specified in the EC2 console. It is optional.
	                </xs:documentation>
	            </xs:annotation>
	        </xs:element>
        </xs:all>
        <xs:attribute name="enabled" type="xs:boolean" use="optional" default="true">
            <xs:annotation>
                <xs:documentation>
                    Specifies whether the EC2 discovery is enabled or not. Value can be true or false.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="connection-timeout-seconds" type="xs:int" use="optional" default="5">
            <xs:annotation>
                <xs:documentation>
                    The maximum amount of time Hazelcast is going to try to connect to a well known member
                    before giving up. Setting its value too low value could mean that a member is not able
                    to connect to a cluster. Setting it too high value means that member startup could slow
                    down because of longer timeouts (e.g. when a well known member is not up). Increasing
                    this value is recommended if you have many IPs listed and the members cannot properly
                    build up the cluster. Its default value is 5.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="join">
        <xs:annotation>
            <xs:documentation>
                The `join` configuration element is used to enable the Hazelcast instances to form a cluster,
                i.e. to join the members. Three ways can be used to join the members: discovery by TCP/IP, by
                multicast, and by discovery on AWS (EC2 auto-discovery).
            </xs:documentation>
        </xs:annotation>
        <xs:all>
            <xs:element name="multicast" type="multicast" minOccurs="0"/>
            <xs:element name="tcp-ip" type="tcp-ip" minOccurs="0"/>
            <xs:element name="aws" type="aws" minOccurs="0"/>
            <xs:element name="discovery-strategies" type="discovery-strategies" minOccurs="0" maxOccurs="1"/>
        </xs:all>
    </xs:complexType>

    <xs:complexType name="discovery-strategies">
        <xs:sequence>
            <xs:element name="node-filter" type="discovery-node-filter" minOccurs="0" maxOccurs="1"/>
            <xs:element name="discovery-strategy" type="discovery-strategy" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="discovery-node-filter">
        <xs:attribute name="class" type="xs:string" use="required"/>
    </xs:complexType>
    <xs:complexType name="discovery-strategy">
        <xs:sequence>
            <xs:element name="properties" type="properties" minOccurs="0" maxOccurs="1"/>
        </xs:sequence>
        <xs:attribute name="enabled" type="xs:boolean" use="optional" default="false"/>
        <xs:attribute name="class" type="xs:string" use="required"/>
    </xs:complexType>
    <xs:complexType name="interfaces">
        <xs:annotation>
            <xs:documentation>
                You can specify which network interfaces that Hazelcast should use. Servers mostly have more
                than one network interface, so you may want to list the valid IPs. Range characters
                ('\*' and '-') can be used for simplicity. For instance, 10.3.10.\* refers to IPs between
                10.3.10.0 and 10.3.10.255. Interface 10.3.10.4-18 refers to IPs between 10.3.10.4 and
                10.3.10.18 (4 and 18 included). If network interface configuration is enabled (it is disabled
                by default) and if Hazelcast cannot find an matching interface, then it will print a message
                on the console and will not start on that node.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="interface" type="xs:string" default="127.0.0.1" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="enabled" type="xs:boolean" use="optional" default="false">
            <xs:annotation>
                <xs:documentation>
                    True to enable these interfaces, false to disable.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="executor-service">
        <xs:all>
            <xs:element name="statistics-enabled" type="xs:boolean" minOccurs="0" maxOccurs="1" default="true">
                <xs:annotation>
                    <xs:documentation>
                        True (default) if statistics gathering is enabled on the executor task, false otherwise.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="pool-size" type="xs:unsignedShort" minOccurs="0" maxOccurs="1" default="8">
                <xs:annotation>
                    <xs:documentation>
                        The number of executor threads per member for the executor.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="queue-capacity" type="xs:unsignedInt" minOccurs="0" maxOccurs="1" default="0">
                <xs:annotation>
                    <xs:documentation>
                        Queue capacity of the executor task. 0 means Integer.MAX_VALUE.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:all>
        <xs:attribute name="name" type="xs:string" use="optional" default="default">
            <xs:annotation>
                <xs:documentation>
                    Name of the executor task.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:simpleType name="backup-count">
        <xs:restriction base="xs:byte">
            <xs:minInclusive value="0"/>
            <xs:maxInclusive value="6"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="empty-queue-ttl">
        <xs:restriction base="xs:int">
            <xs:minInclusive value="-1"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="concurrency-level">
        <xs:restriction base="xs:int">
            <xs:minInclusive value="0"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="symmetric-encryption">
        <xs:annotation>
            <xs:documentation>
                Enterprise only. Hazelcast allows you to encrypt the entire socket level communication among
                all Hazelcast members. Encryption is based on Java Cryptography Architecture. In symmetric
                encryption, each node uses the same key, so the key is shared.
            </xs:documentation>
        </xs:annotation>
        <xs:all>
            <xs:element name="algorithm" type="xs:string">
                <xs:annotation>
                    <xs:documentation>
                        Encryption algorithm such as DES/ECB/PKCS5Padding, PBEWithMD5AndDES, Blowfish,
						or DESede.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="salt" type="xs:string" default="thesalt">
                <xs:annotation>
                    <xs:documentation>
                        Salt value to use when generating the secret key.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="password" type="xs:string">
                <xs:annotation>
                    <xs:documentation>
                        Pass phrase to use when generating the secret key.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="iteration-count" type="xs:unsignedByte" default="19">
                <xs:annotation>
                    <xs:documentation>
                        Iteration count to use when generating the secret key.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:all>
        <xs:attribute name="enabled" type="xs:boolean" use="optional" default="false">
            <xs:annotation>
                <xs:documentation>
                    True to enable symmetric encryption, false to disable.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="map-store">
        <xs:all>
            <xs:element ref="factory-or-class-name" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        The name of the class implementing MapLoader and/or MapStore.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="write-delay-seconds" type="xs:unsignedInt" minOccurs="0" maxOccurs="1" default="0">
                <xs:annotation>
                    <xs:documentation>
                        The number of seconds to delay the store writes. Default value is 0.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="write-batch-size" type="xs:unsignedInt" minOccurs="0" maxOccurs="1" default="1">
                <xs:annotation>
                    <xs:documentation>
                        The number of operations to be included in each batch processing round. Default value is 1.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="write-coalescing" type="xs:boolean" minOccurs="0" maxOccurs="1" default="true">
                <xs:annotation>
                    <xs:documentation>
                        Setting this is meaningful if you are using write behind in MapStore. When write-coalescing is true,
                        only the latest store operation on a key in the write-delay-seconds time-window will be
                        reflected to MapStore. Default value is true.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="properties" type="properties" minOccurs="0" maxOccurs="1"/>
        </xs:all>
        <xs:attribute name="enabled" default="true" type="xs:boolean">
            <xs:annotation>
                <xs:documentation>
                    True to enable this map-store, false to disable.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="initial-mode">
            <xs:annotation>
                <xs:documentation>
                    Sets the initial load mode.
		    	    LAZY: default load mode, where load is asynchronous.
			        EAGER: load is blocked till all partitions are loaded.
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="non-space-string">
                    <xs:enumeration value="LAZY"/>
                    <xs:enumeration value="EAGER"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="query-caches">
        <xs:sequence>
            <xs:element name="query-cache" type="query-cache" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="query-cache">
        <xs:all>
            <xs:element name="include-value" type="xs:boolean" minOccurs="0" maxOccurs="1" default="true">
	            <xs:annotation>
	                <xs:documentation>
	                    True to enable value caching, false to disable.
	                </xs:documentation>
	            </xs:annotation>
	        </xs:element>
            <xs:element name="predicate" type="predicate" minOccurs="1" maxOccurs="1">
	            <xs:annotation>
	                <xs:documentation>
	                    The predicate to filter events which will be applied to the QueryCache.
	                </xs:documentation>
	            </xs:annotation>
	        </xs:element>
            <xs:element name="entry-listeners" type="entry-listeners" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Lets you add listeners (listener classes) for the query cache entries.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="in-memory-format" type="in-memory-format" minOccurs="0" maxOccurs="1" default="BINARY">
                <xs:annotation>
                    <xs:documentation>
                        Data type used to store entries.
                        Possible values:
                        BINARY (default): keys and values are stored as binary data.
                        OBJECT: values are stored in their object forms.
                        NATIVE: keys and values are stored in native memory. Only available on Hazelcast Enterprise.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="populate" type="xs:boolean" minOccurs="0" maxOccurs="1" default="true">
                <xs:annotation>
                    <xs:documentation>
                        True to enable initial population of the query cache, false otherwise.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="coalesce" type="xs:boolean" minOccurs="0" maxOccurs="1" default="false">
                <xs:annotation>
                    <xs:documentation>
                        True to enable coalescing of the query cache, false otherwise.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="delay-seconds" type="xs:unsignedInt" minOccurs="0" maxOccurs="1" default="0">
                <xs:annotation>
                    <xs:documentation>
                        The minimum number of seconds that an event waits in the node buffer.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="batch-size" type="xs:unsignedInt" minOccurs="0" maxOccurs="1" default="1">
                <xs:annotation>
                    <xs:documentation>
                        The batch size used to determine the number of events sent
                        in a batch to the query cache.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="buffer-size" type="xs:unsignedInt" minOccurs="0" maxOccurs="1" default="16">
                <xs:annotation>
                    <xs:documentation>
                        The maximum number of events which can be stored in a partition buffer.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="eviction" type="eviction" minOccurs="0" maxOccurs="1"/>
            <xs:element name="indexes" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="index" type="index" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute name="name" use="required">
            <xs:simpleType>
                <xs:restriction base="xs:string"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="predicate">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="type" use="required">
                    <xs:simpleType>
                        <xs:restriction base="non-space-string">
                            <xs:enumeration value="class-name"/>
                            <xs:enumeration value="sql"/>
                        </xs:restriction>
                    </xs:simpleType>
                </xs:attribute>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

    <xs:element name="factory-or-class-name" abstract="true"/>
    <xs:element name="class-name" substitutionGroup="factory-or-class-name"/>
    <xs:element name="factory-class-name" substitutionGroup="factory-or-class-name"/>
    <xs:element name="queue-store">
        <xs:complexType>
            <xs:all>
                <xs:element ref="factory-or-class-name" minOccurs="0" maxOccurs="1"/>
                <xs:element name="properties" type="properties" minOccurs="0" maxOccurs="1"/>
            </xs:all>
            <xs:attribute name="enabled" default="true" type="xs:boolean"/>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="wan-replication">
        <xs:sequence>
            <xs:element name="target-cluster" type="target-cluster" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name for your WAN replication configuration.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="snapshot-enabled" type="xs:boolean" use="optional" default="false">
            <xs:annotation>
                <xs:documentation>
                    Only valid when used with WanBatchReplication (enterprise only: target-cluster
                    replication-impl). When set to true, only the latest events (based on key) are
                    selected and sent in a batch.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="target-cluster">
        <xs:all>
            <xs:element name="replication-impl" type="xs:string" minOccurs="1" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Name of the class implementation for the WAN replication.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="end-points" type="end-points" minOccurs="1" maxOccurs="1"/>
            <xs:element name="batch-size" type="xs:integer" default="500" minOccurs="0" maxOccurs="1"/>
            <xs:element name="batch-max-delay-millis" type="xs:long" default="1000" minOccurs="0" maxOccurs="1"/>
            <xs:element name="queue-capacity" type="xs:integer" default="10000" minOccurs="0" maxOccurs="1"/>
            <xs:element name="response-timeout-millis" type="xs:long" default="60000" minOccurs="0" maxOccurs="1"/>
            <xs:element name="acknowledge-type" type="wan-ack-type" minOccurs="0" maxOccurs="1"/>
            <xs:element name="queue-full-behavior" type="wan-queue-full-behavior" minOccurs="0" maxOccurs="1"/>
        </xs:all>
        <xs:attribute name="group-name" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    The group name for the WAN replication.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="group-password" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    The group password for the WAN replication.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="end-points">
        <xs:sequence>
            <xs:element name="address" type="xs:string" minOccurs="1" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>
                        IP address of a cluster member for which the WAN replication is implemented.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="ssl">
        <xs:all>
            <xs:element name="factory-class-name" type="xs:string" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        The name of the com.hazelcast.nio.ssl.SSLContextFactory implementation class.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="properties" type="properties" minOccurs="0" maxOccurs="1"/>
        </xs:all>
        <xs:attribute name="enabled" default="false" type="xs:boolean">
            <xs:annotation>
                <xs:documentation>
                    True to enable this ssl configuration, false to disable.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="item-listener">
        <xs:simpleContent>
            <xs:extension base="listener-base">
                <xs:attribute name="include-value" type="xs:boolean" use="optional" default="true"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:complexType name="entry-listeners">
        <xs:sequence>
            <xs:element name="entry-listener" type="entry-listener" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="entry-listener">
        <xs:simpleContent>
            <xs:extension base="item-listener">
                <xs:attribute name="local" type="xs:boolean" use="optional" default="false"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:complexType name="partition-lost-listeners">
        <xs:sequence>
            <xs:element name="partition-lost-listener" type="partition-lost-listener" minOccurs="0"
                        maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="partition-lost-listener">
        <xs:simpleContent>
            <xs:extension base="listener-base"/>
        </xs:simpleContent>
    </xs:complexType>
    <xs:complexType name="index">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="ordered" type="xs:boolean" use="optional" default="false"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:complexType name="map-attribute">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="extractor" type="xs:string" />
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:complexType name="partition-group">
        <xs:sequence>
            <xs:element name="member-group" minOccurs="0" maxOccurs="unbounded">
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="interface" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="enabled" type="xs:boolean" default="false"/>
        <xs:attribute name="group-type">
            <xs:annotation>
                <xs:documentation>
                    When you enable partition grouping, Hazelcast presents three choices for you to configure
                    partition groups.
                    HOST_AWARE: You can group nodes automatically using the IP addresses of nodes, so nodes
                    sharing the same network interface will be grouped together. All members on the same host
                    (IP address or domain name) will be a single partition group.
                    CUSTOM: You can do custom grouping using Hazelcast's interface matching configuration.
                    This way, you can add different and multiple interfaces to a group.
                    PER_MEMBER: You can give every member its own group. Each member is a group of its own
                    and primary and backup partitions are distributed randomly (not on the same physical member).
                </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="non-space-string">
                    <xs:enumeration value="HOST_AWARE"/>
                    <xs:enumeration value="CUSTOM"/>
                    <xs:enumeration value="PER_MEMBER"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="management-center">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="enabled" type="xs:boolean" default="false" use="optional">
		            <xs:annotation>
		                <xs:documentation>
		                    True to enable management center, false to disable.
		                </xs:documentation>
		            </xs:annotation>
		        </xs:attribute>
                <xs:attribute name="update-interval" type="xs:integer" default="3" use="optional">
		            <xs:annotation>
		                <xs:documentation>
		                    The time frequency (in seconds) for which Management Center will take
		                    information from the Hazelcast cluster.
		                </xs:documentation>
		            </xs:annotation>
		        </xs:attribute>
                <xs:attribute name="cluster-id" type="xs:string" use="optional">
		            <xs:annotation>
		                <xs:documentation>
		                    The Hazelcast cluster from which Management Center will take
		                    information.
		                </xs:documentation>
		            </xs:annotation>
		        </xs:attribute>
                <xs:attribute name="security-token" type="xs:string" use="optional"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:complexType name="services">
        <xs:sequence>
            <xs:element name="service" type="service" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="enable-defaults" type="xs:boolean" default="true"/>
    </xs:complexType>
    <xs:complexType name="service">
        <xs:all>
            <xs:element name="name" type="xs:string" minOccurs="1" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Name of the service to be registered.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="class-name" type="xs:string" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Name of the class that you develop for your service.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="properties" type="properties" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        The custom properties that you can add to your service. You enable/disable
                        these properties and set their values using this element.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="configuration" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        You can include configuration items which you develop using the Config object
                        in your code.
                    </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:any minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                    <xs:attribute name="parser" type="xs:string" use="required"/>
                </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute name="enabled" type="xs:boolean" default="true"/>
    </xs:complexType>
    <xs:complexType name="security">
        <xs:all>
            <xs:element name="member-credentials-factory" type="security-object" minOccurs="0" maxOccurs="1"/>
            <xs:element name="member-login-modules" type="login-modules" minOccurs="0" maxOccurs="1"/>
            <xs:element name="client-login-modules" type="login-modules" minOccurs="0" maxOccurs="1"/>
            <xs:element name="client-permission-policy" type="security-object" minOccurs="0" maxOccurs="1"/>
            <xs:element name="client-permissions" type="permissions" minOccurs="0" maxOccurs="1"/>
            <xs:element name="security-interceptors" type="interceptors" minOccurs="0" maxOccurs="1"/>
        </xs:all>
        <xs:attribute name="enabled" type="xs:boolean" default="false"/>
    </xs:complexType>
    <xs:complexType name="interceptors">
        <xs:sequence>
            <xs:element name="interceptor" type="interceptor" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="interceptor">
        <xs:attribute name="class-name" type="non-space-string" use="required"/>
    </xs:complexType>
    <xs:complexType name="login-modules">
        <xs:sequence>
            <xs:element name="login-module" type="login-module" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="login-module">
        <xs:sequence>
            <xs:element name="properties" type="properties" minOccurs="0" maxOccurs="1"/>
        </xs:sequence>
        <xs:attribute name="class-name" type="non-space-string" use="required"/>
        <xs:attribute name="usage" use="optional" default="REQUIRED">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="REQUIRED"/>
                    <xs:enumeration value="OPTIONAL"/>
                    <xs:enumeration value="REQUISITE"/>
                    <xs:enumeration value="SUFFICIENT"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="security-object">
        <xs:sequence>
            <xs:element name="properties" type="properties" minOccurs="0" maxOccurs="1"/>
        </xs:sequence>
        <xs:attribute name="class-name" type="non-space-string" use="required"/>
    </xs:complexType>
    <xs:complexType name="permissions">
        <xs:choice minOccurs="1" maxOccurs="unbounded">
            <xs:element name="all-permissions" type="base-permission" minOccurs="0" maxOccurs="1"/>
            <xs:element name="map-permission" type="instance-permission" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="queue-permission" type="instance-permission" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="multimap-permission" type="instance-permission" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="topic-permission" type="instance-permission" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="list-permission" type="instance-permission" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="set-permission" type="instance-permission" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="lock-permission" type="instance-permission" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="atomic-long-permission" type="instance-permission" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="countdown-latch-permission" type="instance-permission" minOccurs="0"
                        maxOccurs="unbounded"/>
            <xs:element name="semaphore-permission" type="instance-permission" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="id-generator-permission" type="instance-permission" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="executor-service-permission" type="instance-permission" minOccurs="0"
                        maxOccurs="unbounded"/>
            <xs:element name="transaction-permission" type="base-permission" minOccurs="0" maxOccurs="1"/>
        </xs:choice>
    </xs:complexType>
    <xs:complexType name="base-permission">
        <xs:sequence>
            <xs:element name="endpoints" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="endpoint" minOccurs="1" maxOccurs="unbounded" default="127.0.0.1">
                            <xs:annotation>
                                <xs:documentation>
                                    Endpoint address of the principal. Wildcards(*) can be used.
                                </xs:documentation>
                            </xs:annotation>
                            <xs:simpleType>
                                <xs:restriction base="xs:string"/>
                            </xs:simpleType>
                        </xs:element>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="principal" type="xs:string" use="optional" default="*">
            <xs:annotation>
                <xs:documentation>
                    Name of the principal. Wildcards(*) can be used.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="instance-permission">
        <xs:complexContent>
            <xs:extension base="base-permission">
                <xs:sequence>
                    <xs:element name="actions" type="actions" minOccurs="1" maxOccurs="1"/>
                </xs:sequence>
                <xs:attribute name="name" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:documentation>
                            Name of the permission. Wildcards(*) can be used.
                        </xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="actions">
        <xs:sequence>
            <xs:element name="action" minOccurs="1" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>
                        Permission actions that are permitted on Hazelcast instance objects.
                    </xs:documentation>
                </xs:annotation>
                <xs:simpleType>
                    <xs:restriction base="xs:string">
                        <xs:enumeration value="all"/>
                        <xs:enumeration value="create"/>
                        <xs:enumeration value="destroy"/>
                        <xs:enumeration value="modify"/>
                        <xs:enumeration value="read"/>
                        <xs:enumeration value="remove"/>
                        <xs:enumeration value="lock"/>
                        <xs:enumeration value="listen"/>
                        <xs:enumeration value="release"/>
                        <xs:enumeration value="acquire"/>
                        <xs:enumeration value="put"/>
                        <xs:enumeration value="add"/>
                        <xs:enumeration value="index"/>
                        <xs:enumeration value="intercept"/>
                        <xs:enumeration value="publish"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="cluster-group">
        <xs:all>
            <xs:element name="name" type="xs:string" minOccurs="0" maxOccurs="1" default="dev">
                <xs:annotation>
                    <xs:documentation>
                        Name of the group to be created.
	                </xs:documentation>
	            </xs:annotation>
	        </xs:element>
            <xs:element name="password" type="xs:string" minOccurs="0" maxOccurs="1" default="dev-pass">
                <xs:annotation>
                    <xs:documentation>
                        Password of the group to be created.
	                </xs:documentation>
	            </xs:annotation>
	        </xs:element>
        </xs:all>
    </xs:complexType>
    <xs:complexType name="listeners">
        <xs:sequence>
            <xs:element name="listener" type="listener-base" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="listener-base">
        <xs:annotation>
            <xs:documentation>
                One of the following: membership-listener, instance-listener, migration-listener or
                partition-lost-listener.
            </xs:documentation>
        </xs:annotation>
        <xs:simpleContent>
            <xs:extension base="non-space-string"/>
        </xs:simpleContent>
    </xs:complexType>

    <xs:complexType name="near-cache">
        <xs:all>
            <xs:element name="max-size" type="xs:unsignedInt" minOccurs="0" maxOccurs="1" default="0">
	            <xs:annotation>
	                <xs:documentation>
	                    Maximum size of the near cache. When max size is reached,
						cache is evicted based on the policy defined.
						Any integer between 0 and Integer.MAX_VALUE. 0 means
						Integer.MAX_VALUE. Default is 0.
	                </xs:documentation>
	            </xs:annotation>
	        </xs:element>
            <xs:element name="time-to-live-seconds" type="xs:unsignedInt" minOccurs="0" maxOccurs="1" default="0">
	            <xs:annotation>
	                <xs:documentation>
	                    Maximum number of seconds for each entry to stay in the near cache. Entries that are
						older than time-to-live-seconds will get automatically evicted from the near cache.
						Any integer between 0 and Integer.MAX_VALUE. 0 means infinite. Default is 0.
	                </xs:documentation>
	            </xs:annotation>
	        </xs:element>
            <xs:element name="max-idle-seconds" type="xs:unsignedInt" minOccurs="0" maxOccurs="1" default="0">
	            <xs:annotation>
	                <xs:documentation>
	                    Maximum number of seconds each entry can stay in the near cache as untouched (not-read).
				        Entries that are not read (touched) more than max-idle-seconds value will get removed
				        from the near cache.
				        Any integer between 0 and Integer.MAX_VALUE. 0 means Integer.MAX_VALUE. Default is 0.
	                </xs:documentation>
	            </xs:annotation>
	        </xs:element>
            <xs:element name="eviction-policy" type="eviction-policy" minOccurs="0" maxOccurs="1" default="LRU">
	            <xs:annotation>
	                <xs:documentation>
	                    Valid values are:
				        NONE (no extra eviction, time-to-live-seconds may still apply),
				        LRU  (Least Recently Used),
				        LFU  (Least Frequently Used).
				        NONE is the default.
				        Regardless of the eviction policy used, time-to-live-seconds will still apply.
	                </xs:documentation>
	            </xs:annotation>
	        </xs:element>
            <xs:element name="invalidate-on-change" type="xs:boolean" minOccurs="0" maxOccurs="1" default="true">
	            <xs:annotation>
	                <xs:documentation>
					True to evict the cached entries if the entries are changed (updated or removed).
					Default value is true.
				    </xs:documentation>
	            </xs:annotation>
	        </xs:element>
            <xs:element name="in-memory-format" type="in-memory-format" minOccurs="0" maxOccurs="1" default="BINARY">
                <xs:annotation>
                    <xs:documentation>
                        Data type used to store entries.
                        Possible values:
                        BINARY (default): keys and values are stored as binary data.
                        OBJECT: values are stored in their object forms.
                        NATIVE: keys and values are stored in native memory. Only available on Hazelcast Enterprise.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="cache-local-entries" type="xs:boolean" minOccurs="0" maxOccurs="1" default="false">
                <xs:annotation>
                    <xs:documentation>
                        True to cache local entries also.
						This is useful when in-memory-format for near cache is different than the map's one.
						Default value is false.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="eviction" type="eviction" minOccurs="0" maxOccurs="1"/>
        </xs:all>
        <xs:attribute name="name" use="optional" type="xs:string" default="default"/>
    </xs:complexType>

    <xs:simpleType name="in-memory-format">
        <xs:restriction base="non-space-string">
            <xs:enumeration value="BINARY"/>
            <xs:enumeration value="OBJECT"/>
            <xs:enumeration value="NATIVE"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="cache-deserialized-values">
        <xs:restriction base="non-space-string">
            <xs:enumeration value="NEVER"/>
            <xs:enumeration value="ALWAYS"/>
            <xs:enumeration value="INDEX-ONLY"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="time-unit">
        <xs:restriction base="non-space-string">
            <xs:enumeration value="NANOSECONDS"/>
            <xs:enumeration value="MICROSECONDS"/>
            <xs:enumeration value="MILLISECONDS"/>
            <xs:enumeration value="SECONDS"/>
            <xs:enumeration value="MINUTES"/>
            <xs:enumeration value="HOURS"/>
            <xs:enumeration value="DAYS"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="expiry-policy-type">
        <xs:restriction base="non-space-string">
            <xs:enumeration value="CREATED"/>
            <xs:enumeration value="ACCESSED"/>
            <xs:enumeration value="ETERNAL"/>
            <xs:enumeration value="MODIFIED"/>
            <xs:enumeration value="TOUCHED"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="timed-expiry-policy-factory">
        <xs:attribute name="expiry-policy-type" type="expiry-policy-type" use="required"/>
        <xs:attribute name="duration-amount" type="xs:unsignedLong" use="optional"/>
        <xs:attribute name="time-unit" type="time-unit" use="optional"/>
    </xs:complexType>

    <xs:simpleType name="non-space-string">
        <xs:restriction base="xs:string">
            <xs:pattern value="\S.*"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="serialization">
        <xs:all>
            <xs:element name="portable-version" type="xs:unsignedInt" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        The version of the portable serialization. Portable version is used to differentiate two
                        same classes that have changes on it like adding/removing field or changing a type of a field.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="use-native-byte-order" type="xs:boolean" minOccurs="0" maxOccurs="1" default="false">
                <xs:annotation>
                    <xs:documentation>
                        True to use native byte order of the underlying platform, false otherwise. Default value is false.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="byte-order" minOccurs="0" maxOccurs="1" default="BIG_ENDIAN">
                <xs:annotation>
                    <xs:documentation>
                        Defines the byte order that the serialization will use.
                    </xs:documentation>
                </xs:annotation>
                <xs:simpleType>
                    <xs:restriction base="non-space-string">
                        <xs:enumeration value="BIG_ENDIAN"/>
                        <xs:enumeration value="LITTLE_ENDIAN"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:element>
            <xs:element name="enable-compression" type="xs:boolean" minOccurs="0" maxOccurs="1" default="false">
                <xs:annotation>
                    <xs:documentation>
                        True to enable compression if default Java serialization is used, false otherwise.
                        Default value is false.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="enable-shared-object" type="xs:boolean" minOccurs="0" maxOccurs="1" default="false">
                <xs:annotation>
                    <xs:documentation>
                        True to enable shared object if default Java serialization is used, false otherwise.
                        Default value is false.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="allow-unsafe" type="xs:boolean" minOccurs="0" maxOccurs="1" default="false">
                <xs:annotation>
                    <xs:documentation>
                        True to allow the usage of unsafe, false otherwise.
                        Default value is false.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="data-serializable-factories" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="data-serializable-factory" type="serialization-factory" minOccurs="0"
                                    maxOccurs="unbounded">
						    <xs:annotation>
							    <xs:documentation>
								    PortableFactory class to be registered.
						        </xs:documentation>
					        </xs:annotation>
						</xs:element>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element name="portable-factories" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="portable-factory" type="serialization-factory" minOccurs="0"
                                    maxOccurs="unbounded">
					        <xs:annotation>
							    <xs:documentation>
							        PortableFactory class to be registered.
							    </xs:documentation>
						    </xs:annotation>
						</xs:element>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element name="serializers" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:choice minOccurs="1" maxOccurs="unbounded">
                        <xs:element name="global-serializer" type="global-serializer" minOccurs="0" maxOccurs="1">
					        <xs:annotation>
					            <xs:documentation>
					                Global serializer class to be registered if no other serializer is applicable.
					            </xs:documentation>
					        </xs:annotation>
				        </xs:element>
                        <xs:element name="serializer" type="serializer" minOccurs="0" maxOccurs="unbounded">
					        <xs:annotation>
					            <xs:documentation>
					                Defines the class name and the type class of the serializer implementation.
					            </xs:documentation>
					        </xs:annotation>
				        </xs:element>
                    </xs:choice>
                </xs:complexType>
            </xs:element>
            <xs:element name="check-class-def-errors" type="xs:boolean" minOccurs="0" maxOccurs="1" default="true">
                <xs:annotation>
                    <xs:documentation>
                        If true (default), serialization system will check class definitions error at start and throw a
                        Serialization Exception with error definition.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:all>
    </xs:complexType>
    <xs:complexType name="serialization-factory">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="factory-id" use="required" type="xs:unsignedInt"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:complexType name="serializer">
        <xs:attribute name="class-name" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    The name of the class that will be serialized.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="type-class" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    The type of the class that will be serialized.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="global-serializer">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="override-java-serialization" type="xs:boolean" default="false" use="optional">
                    <xs:annotation>
                        <xs:documentation>
                            Java Serializable and Externalizable is prior to global serializer by default. If set true
                            the Java serialization step assumed to be handled by the global serializer.
                        </xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

    <xs:complexType name="socket-interceptor">
        <xs:all>
            <xs:element name="class-name" type="xs:string" minOccurs="0" maxOccurs="1"/>
            <xs:element name="properties" type="properties" minOccurs="0" maxOccurs="1"/>
        </xs:all>
        <xs:attribute name="enabled" default="false" type="xs:boolean"/>
    </xs:complexType>

    <xs:complexType name="native-memory">
        <xs:all>
            <xs:element name="size" type="memory-size" minOccurs="0" maxOccurs="1"/>
            <xs:element name="min-block-size" type="xs:positiveInteger" minOccurs="0" maxOccurs="1"/>
            <xs:element name="page-size" type="xs:positiveInteger" minOccurs="0" maxOccurs="1"/>
            <xs:element name="metadata-space-percentage" minOccurs="0" maxOccurs="1">
                <xs:simpleType>
                    <xs:restriction base="xs:decimal">
                        <xs:totalDigits value="3"/>
                        <xs:fractionDigits value="1"/>
                        <xs:minInclusive value="5"/>
                        <xs:maxInclusive value="95"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:element>
        </xs:all>
        <xs:attribute name="allocator-type" default="POOLED" type="memory-allocator-type"/>
        <xs:attribute name="enabled" default="false" type="xs:boolean"/>
    </xs:complexType>

    <xs:complexType name="memory-size">
        <xs:attribute name="value" type="xs:int" default="128"/>
        <xs:attribute name="unit" type="memory-unit" default="MEGABYTES"/>
    </xs:complexType>

    <xs:simpleType name="memory-unit">
        <xs:restriction base="xs:string">
            <xs:enumeration value="BYTES"/>
            <xs:enumeration value="KILOBYTES"/>
            <xs:enumeration value="MEGABYTES"/>
            <xs:enumeration value="GIGABYTES"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="topic-overload-policy">
        <xs:restriction base="xs:string">
            <xs:enumeration value="DISCARD_OLDEST"/>
            <xs:enumeration value="DISCARD_NEWEST"/>
            <xs:enumeration value="BLOCK"/>
            <xs:enumeration value="ERROR"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="memory-allocator-type">
        <xs:restriction base="xs:string">
            <xs:enumeration value="STANDARD"/>
            <xs:enumeration value="POOLED"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="property">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="name" use="required" type="non-space-string"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:complexType name="properties">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
            <xs:element name="property" type="property"/>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="member-attributes">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="attribute" type="attribute" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:complexType>
        <xs:unique name="uniqueAttributeConstraint">
            <xs:selector xpath="./*"/>
            <xs:field xpath="@name"/>
        </xs:unique>
    </xs:element>
    <xs:simpleType name="attributeName">
        <xs:restriction base="non-space-string"/>
    </xs:simpleType>
    <xs:simpleType name="attributeTypeEnum">
        <xs:restriction base="xs:string">
            <xs:enumeration value="boolean"/>
            <xs:enumeration value="byte"/>
            <xs:enumeration value="double"/>
            <xs:enumeration value="float"/>
            <xs:enumeration value="int"/>
            <xs:enumeration value="long"/>
            <xs:enumeration value="short"/>
            <xs:enumeration value="string"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="attribute">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="name" use="required" type="attributeName"/>
                <!--xs:attribute name="name" use="required" type="xs:ID"/-->
                <xs:attribute name="type" use="optional" default="string" type="attributeTypeEnum"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:complexType name="attributes">
        <xs:sequence>
            <xs:element name="attribute" type="attribute" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:simpleType name="topology-changed-strategy">
        <xs:restriction base="xs:string">
            <xs:enumeration value="CANCEL_RUNNING_OPERATION"/>
            <xs:enumeration value="DISCARD_AND_RESTART"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="eviction-policy">
        <xs:restriction base="xs:string">
            <xs:enumeration value="NONE"/>
            <xs:enumeration value="LRU"/>
            <xs:enumeration value="LFU"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="max-size-policy">
        <xs:restriction base="xs:string">
            <xs:enumeration value="ENTRY_COUNT"/>
            <xs:enumeration value="USED_NATIVE_MEMORY_SIZE"/>
            <xs:enumeration value="USED_NATIVE_MEMORY_PERCENTAGE"/>
            <xs:enumeration value="FREE_NATIVE_MEMORY_SIZE"/>
            <xs:enumeration value="FREE_NATIVE_MEMORY_PERCENTAGE"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="eviction">
        <xs:attribute name="size" type="xs:nonNegativeInteger" default="10000" use="optional"/>
        <xs:attribute name="max-size-policy" type="max-size-policy" default="ENTRY_COUNT" use="optional"/>
        <xs:attribute name="eviction-policy" type="eviction-policy" default="LRU" use="optional"/>
    </xs:complexType>

    <xs:complexType name="wan-replication-ref">
        <xs:all>
            <xs:element name="merge-policy" type="xs:string" minOccurs="1" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Resolve conflicts that occurred when target cluster already has the replicated
                        entry key.

						4 merge policy implementations for IMap and 2 merge policy implementations for
						ICache are provided out of the box.

						IMap has the following merge policies:
						com.hazelcast.map.merge.PutIfAbsentMapMergePolicy: Incoming entry merges from the
                        source map to the target map if it does not exist in the target map.
						com.hazelcast.map.merge.HigherHitsMapMergePolicy: Incoming entry merges from the
						source map to the target map if the source entry has more hits than the target one.
						com.hazelcast.map.merge.PassThroughMergePolicy: Incoming entry merges from the
						source map to the target map unless the incoming entry is not null.
						com.hazelcast.map.merge.LatestUpdateMapMergePolicy: Incoming entry merges from the
						source map to the target map if the source entry has been updated more recently
						than the target entry. Please note that this merge policy can only be used when the
						clusters' clocks are in sync.

						ICache has the following merge policies:
						com.hazelcast.cache.merge.HigherHitsCacheMergePolicy: Incoming entry merges from
						the source cache to the target cache if the source entry has more hits than the
						target one.
						com.hazelcast.cache.merge.PassThroughCacheMergePolicy: Incoming entry merges from
						the source cache to the target cache unless the incoming entry is not null.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="filters" type="wan-replication-ref-filters" minOccurs="0" maxOccurs="1"></xs:element>
            <xs:element name="republishing-enabled" type="xs:boolean" minOccurs="0" maxOccurs="1" default="true">
                <xs:annotation>
                    <xs:documentation>
                        When enabled, an incoming event to a member is forwarded to the target cluster of that member.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:all>
        <xs:attribute name="name" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>
                    Name of the wan-replication configuration. IMap or ICache instance uses this wan-replication config.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="quorum">
        <xs:all>
            <xs:element name="quorum-size" type="quorum-size" minOccurs="0" maxOccurs="1">
                <xs:annotation>
	                <xs:documentation>
	                    The minimum number of members required in a cluster for the cluster to remain in an
	                    operational state. If the number of members is below the defined minimum at any time,
	                    the operations are rejected and the rejected operations return a QuorumException to
	                    their callers.
	                </xs:documentation>
	            </xs:annotation>
	        </xs:element>
            <xs:element name="quorum-type" type="quorum-type" minOccurs="0" maxOccurs="1"/>
            <xs:element name="quorum-function-class-name" type="xs:string" minOccurs="0" maxOccurs="1"/>
            <xs:element name="quorum-listeners" minOccurs="0" maxOccurs="1">
                <xs:annotation>
	                <xs:documentation>
	                    You can register quorum listeners to be notified about quorum results. Quorum listeners
	                    are local to the member that they are registered, so they receive only events occurred on
	                    that local member.
	                </xs:documentation>
	            </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="quorum-listener" type="quorum-listener" maxOccurs="unbounded"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute name="enabled" type="xs:boolean" use="required"/>
        <xs:attribute name="name" use="required">
            <xs:simpleType>
                <xs:restriction base="xs:string"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>

    <xs:simpleType name="quorum-type">
        <xs:restriction base="xs:string">
            <xs:enumeration value="READ"/>
            <xs:enumeration value="WRITE"/>
            <xs:enumeration value="READ_WRITE"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="quorum-size">
        <xs:restriction base="xs:int">
            <xs:minInclusive value="0"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="quorum-listener">
        <xs:simpleContent>
            <xs:extension base="listener-base">
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

    <xs:complexType name="lite-member">
        <xs:attribute name="enabled" type="xs:boolean" use="required">
            <xs:annotation>
                <xs:documentation>
                    True to set the node as a lite member, false otherwise.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="hot-restart-persistence">
        <xs:all>
            <xs:element name="base-dir" type="xs:string" minOccurs="0" maxOccurs="1" default="hot-restart">
                <xs:annotation>
                    <xs:documentation>
                        Base directory for all hot-restart data
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="validation-timeout-seconds" type="xs:unsignedInt" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Validation timeout for hot-restart process, includes validating
                        cluster members expected to join and partition table on all cluster.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="data-load-timeout-seconds" type="xs:unsignedInt" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Data load timeout for hot-restart process,
                        all members in the cluster should complete restoring their local data
                        before this timeout.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:all>
        <xs:attribute name="enabled" type="xs:boolean" use="required">
            <xs:annotation>
                <xs:documentation>
                    True to enable hot-restart, false otherwise.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="hot-restart">
        <xs:all>
            <xs:element name="fsync" type="xs:boolean" default="false">
                <xs:annotation>
                    <xs:documentation>
                        True if disk write should be followed by an fsync() system call,
                        false otherwise.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:all>

        <xs:attribute name="enabled" type="xs:boolean" default="false">
            <xs:annotation>
                <xs:documentation>
                    True if hot-restart is enabled, false otherwise
                    Only available on Hazelcast Enterprise.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="wan-replication-ref-filters">
        <xs:sequence>
            <xs:element name="filter-impl" type="xs:string" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:simpleType name="wan-ack-type">
        <xs:restriction base="non-space-string">
            <xs:enumeration value="ACK_ON_RECEIPT"/>
            <xs:enumeration value="ACK_ON_OPERATION_COMPLETE"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="wan-queue-full-behavior">
        <xs:restriction base="non-space-string">
            <xs:enumeration value="DISCARD_AFTER_MUTATION"/>
            <xs:enumeration value="THROW_EXCEPTION"/>
        </xs:restriction>
    </xs:simpleType>
</xs:schema>
