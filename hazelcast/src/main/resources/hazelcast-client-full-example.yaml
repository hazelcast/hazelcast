# Copyright (c) 2008-2022, Hazelcast, Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This is a full example hazelcast-client.yaml that includes all the
# configuration elements of a Hazelcast client.
#
# To use this, rename it to hazelcast-client.yaml and place it in
# the directory where you start your Hazelcast client.
#
# To learn how to configure Hazelcast, please see the Reference Manual
# at https://docs.hazelcast.com/

hazelcast-client:

  # You can use import to load different Hazelcast declarative configuration files you prepared.
  # You can import as many YAML files as you want and hence compose your Hazelcast configuration
  # out of those YAML files. If you want to use import, it should be placed at the top of your
  # Hazelcast YAML file right after the "hazelcast-client" root node.
  #
  # Below is an example where the configuration files you want to include are located at your
  # Hazelcast working directory:
  #   import:
  #     - your-client-configuration-file.yaml
  #
  # Below are examples showing a classpath or filesystem location:
  #   import:
  #     - file:///etc/hazelcast/your-client-configuration-file-1.yaml
  #     - classpath:your-client-configuration-file-2.yaml
  #
  # Below is an example showing property placeholders:
  #   import:
  #     - ${environment}-your-client-configuration-file.yaml
  #
  import:
    - your-client-configuration-YAML-file

  # The "config-replacers" allow to use variables (placeholders) within the configuration file and use an external
  # class to retrieve correct values (replacements).
  #
  # It can be used for masking sensitive strings such as passwords for instance.
  #
  # Format of a variable is:
  # $ PREFIX { STRING_TO_BE_REPLACED }      e.g. $ENC{nnPgTqJCcCQ=:23000:B4y/nlp6M0t3q6YiKImW+w==}
  #
  # The PREFIX value depends on the replacer implementation (e.g. "ENC" is used for the EncryptionReplacer)
  # The STRING_TO_BE_REPLACED is the value which is provided to replacer implementation.
  #
  config-replacers:
    fail-if-value-missing: false
    replacers:
      - class-name: com.hazelcast.config.replacer.EncryptionReplacer
        properties:
          passwordFile: password
          passwordUserProperties: false
          cipherAlgorithm: DES
          keyLengthBits: 64
          secretKeyAlgorithm: DES
          secretKeyFactoryAlgorithm: PBKDF2WithHmacSHA1
  #
  # Specifies the cluster name. It's sent as part of the client authentication message to Hazelcast
  # member(s).
  cluster-name: my-cluster
  #
  # When Hazelcast instances are created, they are put in a global registry with their creation names.
  # "instance-name" gives you the ability to get a specific Hazelcast instance from this registry
  # by giving the instance's name.
  #
  instance-name: CLIENT_NAME
  #
  # The "properties" mapping lets you add properties to some of the Hazelcast elements used to configure some of
  # the Hazelcast client modules.
  # You can define the name and value of these properties.
  # Please check the source of the ClientProperty class for the complete list of the client properties and their
  # documentation.
  #
  properties:
    hazelcast.client.shuffle.member.list: true
    hazelcast.client.heartbeat.timeout: 60000
    hazelcast.client.heartbeat.interval: 5000
    hazelcast.client.event.thread.count: 5
    hazelcast.client.event.queue.capacity: 1000000
    hazelcast.client.invocation.timeout.seconds: 120
  #
  # The "client-labels" sequence lets you define labels in your Java client, similar to the way it can be done for the
  # members. Through the client labels, you can assign special roles for your clients and use these roles to perform
  # some actions specific to those client connections.
  #
  # You can also group your clients using the client labels. These client groups can be blacklisted in the Hazelcast
  # Management Center so that they can be prevented from connecting to a cluster. See the related section in the
  # Hazelcast Management Center Reference Manual for more information on this topic.
  #
  client-labels:
    - admin
    - foo

  #
  # The "backup-ack-to-client-enabled" element lets you enable/disable backups ack to client.
  # This feature reduces number of hops and increase performance for smart clients.
  # It is enabled by default for smart clients. This config has no effect for unisocket clients.
  #
  backup-ack-to-client-enabled: true

  #
  # ===== HAZELCAST NETWORK CONFIGURATION =====
  #
  # The configuration to build your Hazelcast's network includes configuration for port, interface, discovery
  # mechanism, SSL, encryption, etc. The configuration node's name is "network".
  #   It has the following sub-nodes:
  # * "cluster-members":
  #     This sequence lets you list the members in your cluster the client is connecting to.
  # * "outbound-ports":
  #     By default, Hazelcast lets the system pick up an ephemeral port during socket bind operation.
  #     But security policies/firewalls may require to restrict outbound ports to be used by
  #     Hazelcast-enabled applications. To fulfill this requirement, you can configure Hazelcast to use
  #     only defined outbound ports.
  #     The outbound ports are listed as a sequence under the "outbound-ports" element.
  # * "smart-routing":
  #     If true, client will route the key based operations to owner of the key at the best effort. Note that it
  #     uses a cached version of com.hazelcast.core.PartitionService#getPartitions() and doesn't guarantee that
  #     the operation will always be executed on the owner. The cached table is updated every second.
  # * "redo-operation":
  #     If true, client will redo the operations that were executing on the server and client lost the connection.
  #     This can be because of network, or simply because the member died. However it is not clear whether the
  #     application is performed or not. For idempotent operations this is harmless, but for non idempotent ones
  #     retrying can cause to undesirable effects. Note that the redo can perform on any member. If false, the
  #     operation will throw a RuntimeException that is wrapping a java.io.IOException.
  # * "connection-timeout":
  #     Connection timeout is the timeout value in milliseconds for members to accept client connection requests.
  #     The following are the example configurations. Its default value is 5000.
  # * "socket-options":
  #     You can configure the network socket options using this setting. It has the following sub-elements:
  #       - "tcp-no-delay": Enables/disables the TCP_NODELAY socket option. Its default value is true.
  #       - "keep-alive": Enables/disables the SO_KEEPALIVE socket option. Its default value is true.
  #       - "reuse-address": Enables/disables the SO_REUSEADDR socket option. Its default value is true.
  #       - "linger-seconds":
  #           Enables/disables SO_LINGER with the specified linger time in seconds.
  #           Its default value is 3.
  #       - "buffer-size":
  #           Sets the SO_SNDBUF and SO_RCVBUF options to the specified value in KB for this Socket.
  #           Its default value is 128.
  # * "socket-interceptor":
  #     Lets you add custom hooks to join and perform connection procedures (like identity checking using
  #     Kerberos, etc.). This feature is available only in Hazelcast Enterprise. To be able to use it, you
  #     should first implement the MemberSocketInterceptor (for members joining to a cluster) or
  #     SocketInterceptor (for clients connecting to a member) class. Its configuration contains the class you
  #     implemented and socket interceptor properties. By default, it is disabled. The following is an example:
  #     socket-interceptor:
  #       enabled: true
  #       class-name: com.hazelcast.examples.MySocketInterceptor
  #       properties:
  #         kerberos-host: kerb-host-name
  #         kerberos-config-file: kerb.conf
  # * "ssl":
  #     Allows configuring TLS/SSL communication encryption. This feature is available only in Hazelcast
  #     Enterprise.
  #     The default configuration usually uses JSSE engine available in Java.
  #     Consult the Hazelcast documentation on how to integrate with OpenSSL/BoringSSL engines.
  #     ssl:
  #       enabled: true
  #       factory-class-name: com.hazelcast.nio.ssl.OpenSSLEngineFactory
  #       properties:
  #         protocol: TLSv1.2
  #         trustCertCollectionFile: /opt/hazelcast/trusted-certs.pem
  #         keyFile: /opt/hazelcast/privkey.pem
  #         keyCertChainFile: /opt/hazelcast/chain.pem
  # * "aws":
  #     Set its "enabled" sub-element to true for discovery within Amazon EC2.
  #     Please refer to https://github.com/hazelcast/hazelcast-aws/#configuration for the configuration details.
  # * "gcp":
  #     Set its "enabled" sub-element to true for discovery within the Google Cloud Platform.
  #     Please refer to https://github.com/hazelcast/hazelcast-gcp/#configuration for the configuration details.
  # * "azure":
  #     Set its "enabled" sub-element to true for discovery within Microsoft Azure.
  #     Please refer to https://github.com/hazelcast/hazelcast-azure/#configuring-at-hazelcast-side for
  #     the configuration details.
  # * "kubernetes":
  #     Set its "enabled" sub-element to true for discovery in the Kubernetes environment.
  #     Please refer to https://github.com/hazelcast/hazelcast-kubernetes#hazelcast-configuration for
  #     the configuration details.
  # * "eureka":
  #     Set its "enabled" sub-element to true for discovery with using Eureka Service Registry.
  #     Please refer to https://github.com/hazelcast/hazelcast-eureka#hazelcast-configuration for
  #     the configuration details.
  # * "hazelcast-cloud":
  #     Set its "enabled" sub-element to true for cluster discovery in the Hazelcast Cloud infrastructure. You need to
  #     define the mandatory "discovery-token" sub-node used by the discovery mechanism.
  # * "discovery-strategies":
  #     Set its "enabled" sub-element to true for discovery in various cloud infrastructures. You also need to set the
  #     value of "hazelcast.discovery.enabled" property to true. See the description of the "properties" element
  #     to learn how to do this.
  #     You can define multiple discovery strategies using the "discovery-strategy" sub-element and its
  #     properties. Please refer to
  #     http://docs.hazelcast.org/docs/latest/manual/html-single/index.html#discovering-cluster-members
  #     to see the properties you can use.
  #     The following is an example for EC2 cloud.
  #     discovery-strategies:
  #         - enabled: true
  #           class: com.hazelcast.jclouds.JCloudsDiscoveryStrategy
  #           properties:
  #             provider: aws-ec2
  #             identity: AWS_IDENTITY
  #             credential: AWS_CREDENTIAL
  # * "icmp-ping":
  #     ICMP can be used in addition to the other detectors. It operates at OSI layer 3 and detects network
  #     and hardware issues more quickly. This detector needs to be turned on by setting the "enabled" attribute
  #     to true. It is turned off by default.
  #
  #       It has the following sub-elements:
  #     * "timeout-milliseconds":
  #         Number of milliseconds until a ping attempt is considered failed if there was no reply.
  #         Its default value is 1000 milliseconds.
  #     * "interval-milliseconds":
  #         Interval, in milliseconds, between each ping attempt. 1000ms (1 sec) is also the minimum interval allowed.
  #         Its default value is 1000 milliseconds.
  #     * "max-attempts":
  #         Maximum number of ping attempts before the member gets suspected by the detector. Its default value is 3.
  #     * "ttl":
  #         Maximum number of hops the packets should go through. Its default value is 255. You can set to 0 to use
  #         your systemâ€™s default TTL.
  #     * "echo-fail-fast-on-startup":
  #         The client will fail to start if it is unable to action an ICMP ping command when ICMP is enabled.
  #         Failure is usually due to OS level restrictions.
  #
  network:
    cluster-members:
      - 127.0.0.1
      - 127.0.0.2
    outbound-ports:
      - 34600
      - 34700-34710
    smart-routing: true
    redo-operation: true
    connection-timeout: 60000
    socket-options:
      tcp-no-delay: false
      keep-alive: true
      reuse-address: true
      linger-seconds: 3
      buffer-size: 128
    socket-interceptor:
      enabled: true
      class-name: com.hazelcast.examples.MySocketInterceptor
      properties:
        foo: bar

    ssl:
      enabled: false
      properties:
        protocol: TLS

        trustStore: /opt/hazelcast-client.truststore
        trustStorePassword: secret.123456
        trustStoreType: PKCS12

        # Following properties are only needed when the mutual authentication is used.
        keyStore: /opt/hazelcast-client.keystore
        keyStorePassword: keystorePassword123
        keyStoreType: PKCS12

    auto-detection:
      enabled: false
    aws:
      enabled: false
      access-key: my-access-key
      secret-key: my-secret-key
      region: us-west-1
      host-header: ec2.amazonaws.com
      connection-timeout-seconds: 7
      read-timeout-seconds: 7
      connection-retries: 4
      hz-port: 5701-5710
      use-public-ip: true
      security-group-name: hazelcast-sg
      tag-key: type
      tag-value: hz-nodes
      iam-role: dummy
      # cluster: my-cluster
      # family: test-family
      # service-name: test-service
    gcp:
      enabled: false
      private-key-path: key-path
      projects: project-1,project-2
      region: us-central1
      zones: us-central1-b,us-central1-c
      label: key=value
      hz-port: 5701-5710
      use-public-ip: true
    azure:
      enabled: false
      instance-metadata-available: false
      client-id: CLIENT_ID
      tenant-id: TENANT_ID
      client-secret: CLIENT_SECRET
      subscription-id: SUB_ID
      resource-group: RESOURCE-GROUP-NAME
      scale-set: SCALE-SET-NAME
      tag: TAG-NAME=HZLCAST001
      hz-port: 5701-5707
      use-public-ip: true
    kubernetes:
      enabled: false
      namespace: MY-KUBERNETES-NAMESPACE
      service-name: MY-SERVICE-NAME
      service-label-name: MY-SERVICE-LABEL-NAME
      service-label-value: MY-SERVICE-LABEL-VALUE
    eureka:
      enabled: false
      self-registration: true
      namespace: hazelcast
    icmp-ping:
      enabled: false
      timeout-milliseconds: 2000
      interval-milliseconds: 3000
      ttl: 100
      max-attempts: 5
      echo-fail-fast-on-startup: false
    hazelcast-cloud:
      enabled: false
      discovery-token: EXAMPLE_TOKEN
    discovery-strategies:
      node-filter:
        class: DummyFilterClass
      discovery-strategies:
        - class: DummyDiscoveryStrategy1
          enabled: true
          properties:
            key-string: foo
            key-int: 123
            key-boolean: true

  #
  # ===== HAZELCAST SECURITY CONFIGURATION =====
  #
  # This feature is available only in Hazelcast Enterprise. Configuration element's name is "security".
  #   It has one of the following sub-nodes:
  # * "credentials-factory":
  #     Specifies the name and properties of your class that you developed by implementing Hazelcast's Credentials
  #     interface.
  #     This element has a mandatory "class-name" attribute where you should define the factory class implementing
  #     ICredentialsFactory used to create Credentials objects.
  #     With the "properties" sub-element, you can define properties for the factory class. The properties can be
  #     defined as a mapping where the key is the name of the property.
  # * "username-password":
  #     Defines a static UsernamePasswordCredentials instance as the client's identity. It has mandatory
  #     "username" and "password" attributes.
  # * "token"
  #     Defines a static TokenCredentials instance as the client's identity. It can have attribute "encoding".
  #     Content of the attribute "value" is token value in given encoding (or in plain text).
  # * "kerberos"
  #     Uses Kerberos service ticket (wrapped as GSS-API init token) as the identity.
  #     It may reference a security realm  in the <realms> section. The realm is used for the Kerberos authentication.

  security:
    credentials-factory:
      class-name: com.hazelcast.examples.MyCredentialsFactory
      properties:
        property: value
    realms:
      - name: krb5Initiator
        authentication:
          jaas:
            - class-name: com.sun.security.auth.module.Krb5LoginModule
              usage: REQUIRED
              properties:
                isInitiator: true
                useTicketCache: false
                doNotPrompt: true
                useKeyTab: true
                storeKey: true
                principal: jduke@HAZELCAST.COM
                keyTab: /opt/jduke.keytab

  #
  # ===== HAZELCAST LISTENER CONFIGURATIONS =====
  #
  # Configuration used to register the listeners that you created by implementing Hazelcast's
  # MembershipListener and MigrationListener interfaces.
  #
  listeners:
    - com.hazelcast.examples.MembershipListener
    - com.hazelcast.examples.MigrationListener
  #
  # ===== HAZELCAST SERIALIZATION CONFIGURATION =====
  #
  # Configuration element's name is "serialization".
  # It has the following sub-elements:
  # * "portable-version":
  #     Version of the portable serialization. Portable version is used to differentiate two
  #     of the same classes that have changes such as a new field or a new field type.
  # * "use-native-byte-order":
  #     Set as true if you want to use the native byte order of the underlying platform. Its default value is false.
  # * "byte-order":
  #     Specifies the byte order that the serialization will use. Its default value is BIG_ENDIAN. Available values
  #     are BIG_ENDIAN and LITTLE_ENDIAN.
  # * "enable-compression":
  #     Set as true to enable compression when default Java serialization is used. Its default value is false.
  # * "enable-shared-object":
  #     Set as true to enable shared object when default Java serialization is used. Its default value is false.
  # * "allow-unsafe":
  #     Set as true to allow the usage of unsafe. Its default value is false.
  # * "allow-override-default-serializers":
  #     Set as true to allow override of default serializers. Its default value is false.
  # * "data-serializable-factories":
  #     Lists your class implementations of Hazelcast's DataSerializableFactory. Each factory has the required
  #     "factory-id" attribute that you should give as the ID of your factory.
  # * "portable-factories":
  #     Lists your class implementations of Hazelcast's PortableFactory. Each factory has the required "factory-id"
  #     attribute that you should give as the ID of your factory.
  # * "global-serializer":
  #     Global serializer should be defined with "global-serializer" element. It has an optional boolean
  #     "override-java-serialization" attribute. If you set it as true, the Java serialization step will be handled by the
  #     global serializer, not by the Java Serializable or Externalizable
  # * "serializers":
  #     Lists the serializers (classes) that you implement using Hazelcast's StreamSerializer, ByteArraySerializer etc.
  #
  #     The serializer sub-elements has two required attributes:
  #     - class-name: Full class name of the serializer you implemented.
  #     - type-class: Type of your serializer class implementation.
  #
  # * "check-class-def-errors":
  #     If set to true, serialization system will check the class definitions error at the start of serialization process
  #     and throw a Serialization Exception with the error definition.
  # * "java-serialization-filter":
  #     Allows to configure blacklisting and whitelisting for deserialized classes when Java serialization is used.
  #
  serialization:
    portable-version: 3
    use-native-byte-order: true
    byte-order: BIG_ENDIAN
    enable-compression: false
    enable-shared-object: true
    allow-unsafe: false
    allow-override-default-serializers: false
    data-serializable-factories:
      - factory-id: 1
        class-name: com.hazelcast.examples.DataSerializableFactory
    portable-factories:
      - factory-id: 2
        class-name: com.hazelcast.examples.PortableFactory
    global-serializer:
      override-java-serialization: true
      class-name: com.hazelcast.examples.GlobalSerializerFactory
    serializers:
      - type-class: com.hazelcast.examples.DummyType
        class-name: com.hazelcast.examples.SerializerFactory
    check-class-def-errors: true
    java-serialization-filter:
      blacklist:
        class:
          - com.acme.app.BeanComparator
      whitelist:
        class:
          - java.lang.String
          - example.Foo
        package:
          - com.acme.app
          - com.acme.app.subpkg
        prefix:
          - java
          - "["
          - com.
    compact-serialization:
      enabled: true
      registered-classes:
        - class: com.hazelcast.examples.DummyType
        - class: com.hazelcast.examples.DummyTypeWithSerializer
          type-name: dummy
          serializer: com.hazelcast.examples.DummyTypeSerializer
  #
  # ===== HAZELCAST HIGH-DENSITY MEMORY STORE CONFIGURATION =====
  #
  # This feature is available only in Hazelcast Enterprise HD. Configuration element's name is
  # "native-memory".
  # It has the following attributes:
  # - enabled:
  #     Set as true to enable the High-Density Memory Store usage. Its default value is false.
  # - allocator-type:
  #     Type of the memory allocator. Its default value is POOLED. Available values are as follows:
  # * STANDARD: Allocates/frees the memory using default OS memory manager.
  # * POOLED: Manages memory blocks in thread local pools.
  #
  # It has the following sub-elements:
  # - "size":
  #     Size of the total native memory to allocate. You can give the size using its "value" attribute and the unit
  #     using its "unit" attribute. Unit can be bytes, kilobytes, megabytes and gigabytes. Default value is 128 and
  #     default unit is MEGABYTES.
  # - "min-block-size":
  #     Minimum size of the blocks in bytes to split and fragment a page block to assign to an allocation request.
  #     It is used only by the POOLED memory allocator. The value has to be power of two.  Default value is 16.
  # - "page-size":
  #     Size of the page in bytes to allocate memory as a block. It is used only by the POOLED memory allocator. Its
  #     default value is 1 << 22 (about 4 MB).
  # - "metadata-space-percentage":
  #     Percentage of the allocated native memory that is used for the metadata such as indexes, offsets, etc. It is
  #     used only by the POOLED memory allocator. Its default value is 12.5.
  #
  native-memory:
    enabled: false
    allocator-type: POOLED
    size:
      unit: MEGABYTES
      value: 128
    min-block-size: 1
    page-size: 1
    metadata-space-percentage: 40.5
    # Simple configuration for single-socket machines with non-volatile memory
    # persistent-memory-directory: /mnt/optane
    # Advanced configuration for non-volatile memory
    persistent-memory:
      enabled: true
      mode: MOUNTED
      directories:
        - directory: /mnt/pmem0
          numa-node: 0
        - directory: /mnt/pmem1
          numa-node: 1

  #
  # ===== HAZELCAST PROXY FACTORY CONFIGURATION =====
  #
  # The client proxy factories can be defined under the "proxy-factories" sequence. Each node in the sequence is
  # a mapping, with the following sub-nodes:
  # * "class-name": The name of the client proxy factory class.
  # * "service": The name of the service.
  #
  proxy-factories:
    - class-name: com.hazelcast.examples.ProxyXYZ1
      service: sampleService1
    - class-name: com.hazelcast.examples.ProxyXYZ2
      service: sampleService1
    - class-name: com.hazelcast.examples.ProxyXYZ3
      service: sampleService3
  #
  # ===== HAZELCAST LOAD BALANCER CONFIGURATION =====
  #
  # The load balancer can be configured with the "load-balancer" mapping.
  # It has a scalar sub-node called "type". The valid values for the type of the load balancer are:
  # * "random": The member the operations to be sent to is chosen randomly.
  # * "round-robin": The member the operations to be sent to is chosen in a round-robin fashion.
  # * "custom": The member the operations to be sent to is chosen by provided load balancer implementation.
  #             The implementation class name is specified in additional "class-name" key.
  #
  load-balancer:
    type: random
  #
  # ===== HAZELCAST NEAR CACHE CONFIGURATION =====
  #
  # Configuration element's name is "near-cache".
  # It has the following attribute:
  #   - name: You can give a name for your Near Cache. It is mandatory.
  #
  # It has the following sub-nodes:
  #   - "max-size":
  #       Maximum size of the Near Cache. When this is reached, Near Cache is evicted based on the policy defined.
  #       Any integer between 0 and Integer.MAX_VALUE. 0 means Integer.MAX_VALUE. Its default value is 0.
  #   - "time-to-live-seconds":
  #       Maximum number of seconds for each entry to stay in the Near Cache. Entries that are older than this
  #       period are automatically evicted from the Near Cache. Any integer between 0 and Integer.MAX_VALUE.
  #       0 means infinite. Its default value is 0.
  #   - "max-idle-seconds":
  #       Maximum number of seconds each entry can stay in the Near Cache as untouched (not read). Entries that
  #       are not read more than this period are removed from the Near Cache. Any integer between 0 and
  #       Integer.MAX_VALUE. 0 means Integer.MAX_VALUE. Its default value is 0.
  #   - "eviction-policy":
  #       Eviction policy configuration. Its default values is NONE. Available values are as follows:
  #         - NONE:
  #             No items will be evicted and the property max-size will be ignored. You still
  #             can combine it with time-to-live-seconds and max-idle-seconds.
  #         - LRU: 	Least Recently Used.
  #         - LFU: 	Least Frequently Used.
  #         - "invalidate-on-change":
  #             Specifies whether the cached entries are evicted when the entries are updated or removed. Its default
  #             value is true.
  #   - "in-memory-format":
  #       Specifies in which format data will be stored in your Near Cache. Note that a map's in-memory format
  #       can be different from that of its Near Cache.
  #       Available values are as follows:
  #         - BINARY:
  #             Data will be stored in serialized binary format. It is the default option.
  #         - OBJECT:
  #             Data will be stored in deserialized form.
  #         - NATIVE:
  #             Data will be stored in the Near Cache that uses Hazelcast's High-Density Memory Store feature.
  #             This option is available only in Hazelcast Enterprise HD. Note that a map and its Near Cache
  #             can independently use High-Density Memory Store. For example, while your map does not use
  #             High-Density Memory Store, its Near Cache can use it.
  #   - "invalidate-on-change":
  #       Specifies whether the cached entries are evicted when the entries are updated or removed.
  #       Its default value is true.
  #   - "serialize-keys":
  #       Specifies if the keys of a Near Cache entry should be serialized or not. Serializing the keys has
  #       a big impact on the read performance of the Near Cache. It should just be activated when you have
  #       mutable keys, which are changed after use for the Near Cache. Its default value is false.
  #   - "eviction":
  #       Configuration for the eviction when the in-memory format of the Near Cache is NATIVE. It has the
  #       following attributes:
  #         - size: Maximum size (entry count) of the Near Cache.
  #         - max-size-policy: Maximum size policy for eviction of the Near Cache. Available values are as follows:
  #                              * ENTRY_COUNT: Maximum entry count per member.
  #                              * USED_NATIVE_MEMORY_SIZE: Maximum used native memory size in megabytes.
  #                              * USED_NATIVE_MEMORY_PERCENTAGE: Maximum used native memory percentage.
  #                              * FREE_NATIVE_MEMORY_SIZE: Minimum free native memory size to trigger cleanup.
  #                              * FREE_NATIVE_MEMORY_PERCENTAGE: Minimum free native memory percentage to trigger cleanup.
  #         - eviction-policy: See the "eviction-policy" element above.
  #
  # Note that the Near Cache eviction configuration is different for NATIVE in-memory format.
  # Proper eviction configuration example for NATIVE in-memory can be seen under 'NearCacheEvictionConfigExample'.
  near-cache:
    default:
      time-to-live-seconds: 90
      max-idle-seconds: 100
      invalidate-on-change: true
      in-memory-format: OBJECT
      serialize-keys: true
      local-update-policy: INVALIDATE
      preloader:
        enabled: true
        directory: directory
        store-initial-delay-seconds: 50
        store-interval-seconds: 10

    NearCacheEvictionConfigExample:
      eviction:
        eviction-policy: LRU
        max-size-policy: ENTRY_COUNT
        size: 10000
        comparator-class-name: com.hazelcast.examples.MyEvictionComparator

  #
  # ===== HAZELCAST FLAKE ID GENERATOR CONFIGURATION =====
  #
  # Configuration element's name is "flake-id-generator". The name of the Flake ID generator is defined by the name
  # of the key right under the "flake-id-generator" node.
  # It has the following sub-ndoes:
  #
  # * "prefetch-count":
  #     Sets how many IDs are pre-fetched on the background when one call to
  #     FlakeIdGenerator.newId() is made. Value must be in the range 1..100,000, default
  #     is 100.
  #
  #     This setting pertains only to newId() calls made on the member that configured it.
  #
  # * "prefetch-validity-millis":
  #     Sets for how long the pre-fetched IDs can be used. If this time elapses, a new batch of IDs
  #     will be fetched. Time unit is milliseconds, default is 600,000 (10 minutes).
  #
  #     The IDs contain timestamp component, which ensures rough global ordering of IDs. If an
  #     ID is assigned to an object that was created much later, it will be much out of order. If you
  #     don't care about ordering, set this value to 0.
  #
  #     This setting pertains only to newId() calls made on the member that configured it.
  #
  flake-id-generator:
    default:
      prefetch-count: 100
      prefetch-validity-millis: 600000

  #
  # ===== HAZELCAST CONTINUOUS QUERY CACHE CONFIGURATION =====
  #
  # Configuration element's name is "query-caches".
  # You can create your query caches by defining mappings with the key used as the name of the query cache.
  # It has the following sub-elements:
  # * "map-name": Specifies the name of the map the query cache is used for.
  # * "predicate":
  #     Predicate to filter events which will be applied to the query cache.
  # * "entry-listeners":
  #     Adds listeners (listener classes) for your query cache entries. See "entry-listeners" in the map configuration above.
  # * "include-value":
  #     Set to true if you want to cache the value too. Its default value is true.
  # * "batch-size":
  #     Batch size used to determine the number of events sent in a batch to your query cache. Its default value is 1.
  # * "buffer-size":
  #     Maximum number of events which can be stored in a partition buffer. Its default value is 16.
  # * "delay-seconds":
  #     Minimum time in seconds that an event waits in the member's buffer. Its default value is 0.
  # * "in-memory-format":
  #     Type of the data to be stored in your query cache. See "in-memory-format" in the map configuration above.
  # * "coalesce":
  #     Set to true if you want to enable the coalescing of your query cache. Its default value is false.
  # * "populate":
  #     Set to true if you want to enable the initial population of your query cache. Its default value is true.
  # * "serialize-keys":
  #     Defines if the Query Cache keys should be serialized or not. Keys should be serialized if they are mutable
  #     and need to be cloned via serialization. Default value is false.
  # * "eviction":
  #     Configuration for the eviction of your query cache.
  #     It has the following attributes:
  #         - size: Maximum size (entry count) of the Near Cache.
  #         - max-size-policy: Maximum size policy for eviction of the Near Cache. Available values are as follows:
  #                               * ENTRY_COUNT: Maximum entry count per member.
  #                               * USED_NATIVE_MEMORY_SIZE: Maximum used native memory size in megabytes.
  #                               * USED_NATIVE_MEMORY_PERCENTAGE: Maximum used native memory percentage.
  #                               * FREE_NATIVE_MEMORY_SIZE: Minimum free native memory size to trigger cleanup.
  #                               * FREE_NATIVE_MEMORY_PERCENTAGE: Minimum free native memory percentage to trigger cleanup.
  #          - eviction-policy: Eviction policy configuration. Its default values is NONE. Available values are as follows:
  #                               - NONE:
  #                                   No items will be evicted and the property max-size will be ignored. You still
  #                                   can combine it with time-to-live-seconds and max-idle-seconds.
  #                               - LRU: 	Least Recently Used.
  #                               - LFU: 	Least Frequently Used.
  #          - comparator-class-name: The comparator to be used while comparing entries to be evicted.
  #
  # * "indexes":
  #     You can define indexes for your map using the "indexes" mapping. Index definition consists of type, optional
  #     name and the list of columns to be indexed. Valid types are SORTED (default) and HASH.
  #
  query-caches:
    query-cache-class-name-predicate:
      map-name: map-name
      predicate:
        class-name: com.hazelcast.examples.ExamplePredicate
      entry-listeners:
        - include-value: true
          local: false
          class-name: com.hazelcast.examples.EntryListener
      include-value: true
      batch-size: 1
      buffer-size: 16
      delay-seconds: 0
      in-memory-format: BINARY
      coalesce: false
      populate: true
      serialize-keys: true
      eviction:
        eviction-policy: LRU
        max-size-policy: ENTRY_COUNT
        size: 10000
        comparator-class-name: com.hazelcast.examples.MyEvictionComparator
      indexes:
        - type: HASH
          attributes:
            - "name"
    query-cache-sql-predicate:
      map-name: map-name
      predicate:
        sql: "%age=40"
  #
  # ===== HAZELCAST CONNECTION STRATEGY CONFIGURATION =====
  #
  # Configuration node's name is "connection-strategy".
  # It has the following sub-nodes:
  #   - "async-start": If set to true, creating Hazelcast client does not wait for connecting to the cluster.
  #   - "reconnect-mode": Defines the reconnection mode. The valid values are:
  #     - "ON":
  #         Enables reconnection in a blocking manner where all the waiting invocations are blocked until a
  #         cluster connection is established or failed. This is the default value.
  #     - "OFF": Disables the reconnection.
  #     - "ASYNC":
  #         Enables reconnection in a non-blocking manner where all the waiting invocations receive a
  #         HazelcastClientOfflineException.
  #   - "connection-retry":
  #         Defines the configuration used when retrying to connect to the cluster.
  #         It has the following sub-nodes:
  #   * "enabled": Specifies if retrying is enabled
  #   * "initial-backoff-millis":
  #       Specifies how long to wait (backoff) after the first failure before retrying in milliseconds.
  #       Its default value is 1000 ms.
  #   * "max-backoff-millis": Specifies the upper limit for the backoff in milliseconds. Its default value is 30000 ms.
  #   * "multiplier": Factor to multiply the backoff after a failed retry. Its default value is 1.05.
  #   * "cluster-connect-timeout-millis": Timeout value in milliseconds for the client to give up to connect to the current cluster
  #      Depending on FailoverConfig, a client can shutdown or start trying on alternative cluster after reaching the timeout.
  #      Its default value is -1. For the default value, the client will not stop trying to connect to the cluster.
  #      If the failover client is used, the client will start trying to connect alternative clusters after
  #      120000 ms. For any other value, both the failover and non-failover client will use that as it is.
  #   * "jitter": Specifies by how much to randomize backoffs. Its default value is 0.
  #
  connection-strategy:
    async-start: true
    reconnect-mode: ASYNC
    connection-retry:
      initial-backoff-millis: 2000
      max-backoff-millis: 60000
      multiplier: 3
      cluster-connect-timeout-millis: 5000
      jitter: 0.5

  #
  # ===== HAZELCAST RELIABLE TOPIC CONFIGURATION =====
  #
  # Reliable Topic uses the same ITopic interface. The main difference is that it is backed up by
  # Hazelcast Ringbuffer data structure. Reliable Topic messages are stored in the Ringbuffer
  # Configuration element's name is "reliable-topic". It has the optional attribute "name" with which you
  # can specify the name of your Reliable Topic, which is the same name you give to your Ringbuffer.
  # This attribute's default value is "default".
  # It has the following sub-elements:
  # * "read-batch-size":
  #     Sets the read batch size.
  #     The ReliableTopic tries to read a batch of messages from the ringbuffer.
  #     It will get at least one, but if there are more available, then it will
  #     try to get more to increase throughput. The maximum read batch size can
  #     be influenced using the read batch size.
  #     Apart from influencing the number of messages to retrieve, the
  #     readBatchSize also determines how many messages will be processed
  #     by the thread running the MessageListener before it returns back
  #     to the pool to look for other MessageListeners that need to be
  #     processed. The problem with returning to the pool and looking for new work
  #     is that interacting with an executor is quite expensive due to contention
  #     on the work-queue. The more work that can be done without retuning to the
  #     pool, the smaller the overhead.
  #     If the readBatchSize is 10 and there are 50 messages available,
  #     10 items are retrieved and processed consecutively before the thread goes
  #     back to the pool and helps out with the processing of other messages.
  #     If the readBatchSize is 10 and there are 2 items available,
  #     2 items are retrieved and processed consecutively.
  #     If the readBatchSize is an issue because a thread will be busy
  #     too long with processing a single MessageListener and it can't
  #     help out other MessageListeners, increase the size of the
  #     threadpool so the other MessageListeners don't need to wait for
  #     a thread, but can be processed in parallel.
  # * "topic-overload-policy":
  #     A policy to deal with an overloaded topic; so topic where there is no place to store new messages.
  #     This policy can only be used in combination with the
  #     com.hazelcast.core.HazelcastInstance#getReliableTopic(String).
  #     The reliable topic uses a com.hazelcast.ringbuffer.Ringbuffer to
  #     store the messages. A ringbuffer doesn't track where readers are, so
  #     it has no concept of a slow consumers. This provides many advantages like
  #     high performance reads, but it also gives the ability to the reader to
  #     re-read the same message multiple times in case of an error.
  #     A ringbuffer has a limited, fixed capacity. A fast producer may overwrite
  #     old messages that are still being read by a slow consumer. To prevent
  #     this, we may configure a time-to-live on the ringbuffer (see
  #     com.hazelcast.config.RingbufferConfig#setTimeToLiveSeconds(int).
  #     Once the time-to-live is configured, the TopicOverloadPolicy
  #     controls how the publisher is going to deal with the situation that a
  #     ringbuffer is full and the oldest item in the ringbuffer is not old
  #     enough to get overwritten.
  #     Keep in mind that this retention period (time-to-live) can keep messages
  #     from being overwritten, even though all readers might have already completed reading.
  #     Its default value is BLOCK. Available values are as follows:
  #     - DISCARD_OLDEST:
  #         Using this policy, a message that has not expired can be overwritten.
  #         No matter the retention period set, the overwrite will just overwrite
  #         the item.
  #         This can be a problem for slow consumers because they were promised a
  #         certain time window to process messages. But it will benefit producers
  #         and fast consumers since they are able to continue. This policy sacrifices
  #         the slow producer in favor of fast producers/consumers.
  #     - DISCARD_NEWEST:
  #         Message that was to be published is discarded.
  #     - BLOCK:
  #         The caller will wait until there is space in the Ringbuffer.
  #     - ERROR:
  #         The publish call fails immediately.
  #
  reliable-topic:
    rel-topic:
      read-batch-size: 100
      topic-overload-policy: DISCARD_NEWEST
  #
  # ===== HAZELCAST USER CODE DEPLOYMENT CONFIGURATION =====
  #
  # Configuration element's name is "user-code-deployment".
  # It has the following sub-nodes:
  # * "enabled": If set to true, user code deployment is enabled.
  # * "jarPaths": Sequence lists the jar files containing the classes to load.
  # * "classNames": Sequence lists the classes available in the client class path to load.
  user-code-deployment:
    enabled: true
    jarPaths:
      - /User/test/sample.jar
      - https://hazelcast.com/
      - file://User/test/sample.jar
    classNames:
      - test.sampleClassName

  #
  # ===== HAZELCAST METRICS CONFIGURATION =====
  #
  # Configuration element's name is "metrics".
  #
  # It has the following sub-elements:
  #     * "enabled":
  #         The master-switch for the metrics collection. If this is set
  #         to false no metrics collection is done, regardless of the other
  #         settings. Its default value is true.
  #
  # It has the following sub-elements:
  # * "jmx":
  #     Defines the JMX related metrics configuration.
  #
  #       It has the following attributes:
  #     * "enabled":
  #         Controls whether the metrics collected are exposed to
  #         through JMX. It is enabled by default.
  #         In order to expose the metrics, the metrics system need
  #         to be enabled via the enabled master-switch attribute.
  #
  # * "collection-frequency-seconds":
  #     Sets the metrics collection frequency in seconds.
  #     By default, metrics are collected every 5 seconds.
  #
  #
  metrics:
    enabled: false
    jmx:
      enabled: false
    collection-frequency-seconds: 42

  #
  # ===== HAZELCAST INSTANCE TRACKING CONFIGURATION =====
  #
  # Configuration element's name is "instance-tracking".
  #
  # It has the following sub-elements:
  #     * "enabled":
  #         Enables or disables instance tracking.
  #
  # * "format-pattern":
  #     Sets the pattern used to render the contents of the instance tracking file.
  #     It may contain placeholders for these properties:
  #     - "product": The instance product name, e.g. "Hazelcast" or "Hazelcast Enterprise".
  #     - "version": The instance version.
  #     - "mode": The instance mode which can be "server", "embedded" or "client".
  #     - "start_timestamp": The timestamp of when the instance was started expressed the difference,
  #     measured in milliseconds, between the current time and midnight, January 1, 1970 UTC
  #     - "licensed": If this instance is using a license or not. The value 0 signifies
  #     that there is no license set and the value 1 signifies that a license is in use.
  #     - "pid": Attempts to get the process ID value. The algorithm does not guarantee to get the
  #     process ID on all JVMs and operating systems so please test before use. In case we are unable to
  #     get the PID, the value will be -1.
  #     The placeholders are defined by a $HZ_INSTANCE_TRACKING{ prefix and followed by }.
  #     For instance, a placeholder for the "start_timestamp" would be $HZ_INSTANCE_TRACKING{start_timestamp}.
  #     The placeholders are resolved in a fail-safe manner. Any incorrect syntax
  #     is ignored and only the known properties are resolved, placeholders for
  #     any parameters which do not have defined values will be ignored. This also
  #     means that if there is a missing closing bracket in one of the placeholders,
  #     the property name will be resolved as anything from the opening bracket
  #     to the next closing bracket, which might contain additional opening brackets.
  #     If unset, a JSON formatted output will be used.
  #
  # * "file-name":
  #     Sets the name of the file which will contain the tracking metadata. If left unset
  #     a file named "Hazelcast.process" will be created in the directory as returned by
  #     System.getProperty("java.io.tmpdir").
  #     The filename can contain placeholders that will be resolved in the same way
  #     as placeholders for the format pattern.
  #
  instance-tracking:
    enabled: false
    file-name: hazelcast.process
    format-pattern: $HZ_INSTANCE_TRACKING{product}:$HZ_INSTANCE_TRACKING{version}
