<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Copyright (c) 2008-2016, Hazelcast, Inc. All Rights Reserved.
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~ http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<!--
This is a full example hazelcast.xml that includes all the configuration elements and attributes of Hazelcast.
To use this, rename it to hazelcast.xml and place it in the directory where you start Hazelcast.
Please see the schema to learn how to configure Hazelcast at 
https://hazelcast.com/schema/config/hazelcast-config-3.7.xsd or the Reference Manual at
https://hazelcast.org/documentation/.
-->
<hazelcast xsi:schemaLocation="http://www.hazelcast.com/schema/config hazelcast-config-3.7.xsd"
           xmlns="http://www.hazelcast.com/schema/config"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<!--
    You can use the <import> element to load different Hazelcast declarative configuration files you prepared.
    You can import as many XML files as you want and hence compose your Hazelcast configuration
    out of those XML files. If you want to use the <import> element, it should be placed at the top of your
    Hazelcast XML file right after the <hazelcast> element, and it should have the required attribute "resource".
    
    Below is an example where the configuration files you want to include are located at your 
    Hazelcast working directory:
    <import resource="your-configuration-file.xml"/>
    
    Below are examples showing a classpath or filesystem location:
    <import resource="file:///etc/hazelcast/your-configuration-file-1.xml"/> 
    <import resource="classpath:your-configuration-file-2.xml"/> 
    
    Below is an example showing property placeholders:
    <import resource="${environment}-your-configuration-file.xml"/>
    
-->    
    <import resource="your-configuration-XML-file"/>
<!--
    Specifies the name and password for a cluster group you create.
    Cluster groups allow you to create separate sub-clusters within your Hazelcast cluster to 
    create a simple security. They are also referenced in the WAN Replication configuration. 
-->
    <group>
        <name>dev</name>
        <password>dev-pass</password>
    </group>
<!--
    ===== HAZELCAST LICENSE CONFIGURATION =====
    
    If you have an Enterprise or Enterprise HD license, you can enter it here.
    You can also set your license key programmatically; please refer to 
    http://docs.hazelcast.org/docs/latest/manual/html-single/index.html#setting-the-license-key
-->    
    <license-key>Your Hazelcast Enterprise or Enterprise HD License Key</license-key>
<!--
    When Hazelcast instances are created, they are put in a global registry with their creation names.
    <instance-name> elements gives you the ability to get a specific Hazelcast instance from this registry
    by giving the instance's name.
-->    
    <instance-name>hzInstance1</instance-name>
<!--
    ===== HAZELCAST MANAGEMENT CENTER CONFIGURATION =====
    
    The value for the element <management-center> is the URL where you deploy the Management Center.
    It has two optional attributes:
    * enabled: 
	Set to true to be able to use the Management Center. Its default value is false.
    * update-interval: 
	The time frequency (in seconds) for which Management Center will take information from Hazelcast cluster. 
	Its default value is 3 seconds. Hazelcast's Open Source edition provides the Management Center with monitoring 
	at most 2 members in your cluster. To use it for more members, you need to have either a Management Center, 
	Hazelcast Enterprise or Hazelcast Enterprise HD license. 
-->        
    <management-center enabled="true" update-interval="2">http://localhost:8080/mancenter</management-center>
<!--
    The <properties> element lets you add properties to some of the Hazelcast elements used to configure some of 
    the Hazelcast modules. 
    You can define the name and value of these properties using the sub-element <property>.
    You can use <properties> for the following Hazelcast configuration elements:
    * <discovery-strategy>
    * <map-store>
    * <queue-store>
    * <ssl>
    * <service>
    * <login-module>
    * <security-object>
    * <socket-interceptor>
-->        
    <properties>
    	<property name="your-property">Value of the property</property>
    </properties>
<!--
    ===== HAZELCAST WAN REPLICATION CONFIGURATION ===== 
    
    The WAN replication feature is available only in Hazelcast Enterprise.
    The configuration element's name is <wan-replication>. It has two attributes:
    * name: 
	Name of your WAN Replication. This name is referenced in IMap or ICache configuration when you add WAN 
	Replication for these data structures (using the element <wan-replication-ref> in the configuration of 
	IMap or ICache). Please see the <map> and <cache> configuration descriptions in this XML.
    * snapshot-enabled: 
	This attribute is valid when you use `WanBatchReplication` as the WAN Replication implementation. When
	set to true, only the latest events (based on key) are selected and sent to the target cluster in a batch.
    
    The <wan-replication> element has the following sub-elements:
    * <wan-publisher>:
	Fully qualified class name of WAN Replication implementation. Hazelcast Enterprise comes with;
    	- com.hazelcast.enterprise.wan.replication.WanBatchReplication:
		Waits until a batch size is reached or a delay time is passed.
		Please see the `batch.size and batch.max.delay.millis configuration descriptions below.
    * <wan-consumer>:
	Name of the custom class implementation that is responsible for incoming WAN events.
    * "endpoints":
	Comma separated list of IP addresses of the target cluster members for which the WAN replication is implemented.
    * "batch.size":
	This element is valid when you set <class-name> (the WAN Replication implementation) to
	`WanBatchReplication`. It changes the maximum size of events that are sent to the target cluster in a 
	single batch. The batch of events is not sent until this size is reached. Its default value is 500.
    * "batch.max.delay.millis":
	This element is valid when you set <class-name> (the WAN Replication implementation) to
	`WanBatchReplication`. If the number of events generated does not reach the "batch.size", they are sent to the
	target cluster after a certain amount of time is passed. You can set this time in milliseconds using this 
	element. Its default value is 1000 milliseconds.
    * "response.timeout.millis":
	After a replication event is sent to the target cluster, the source member waits for a confirmation 
	that says the event has reached the target. If confirmation is not received for a period of 
	`response.timeout.millis`, the event is resent to the target cluster. The default value is 60000 milliseconds.
    * <queue-capacity>: 
	Size of the queue of events. Its default value is 10000. If you exceed this queue size, then the 
	oldest, not yet replicated updates might get lost. Therefore, if you have a large rate of 
	put/update/remove operations, you should increase <queue-capacity>.
    * <queue-full-behavior>: 
	Policy to be applied when WAN Replication event queues are full. You can set it to the following values:
	- DISCARD_AFTER_MUTATION: 
		The new WAN events generated are dropped and not replicated to the target cluster.
	- THROW_EXCEPTION: 
		The WAN queue size is checked before each supported mutating operation. If one of the queues of the target 
		cluster is full, WANReplicationQueueFullException is thrown and the operation is not allowed.
    * <acknowledge-type>: 
	Acknowledgment type for each target cluster when the events are replicated. You can set it to the following values:
	- ACK_ON_RECEIPT: 
		Guarantees that events are received by the target cluster. It does not guarantee that 
		the received event is actually applied, but it is faster.
	- ACK_ON_OPERATION_COMPLETE: 
		Guarantees that the event is both received and applied by the target cluster. 
		It is more time consuming, but it is the best way if you have strong consistency requirements.
-->        
    <wan-replication name="my-wan-cluster-batch">
        <wan-publisher group-name="nyc">
            <class-name>com.hazelcast.enterprise.wan.replication.WanBatchReplication</class-name>
            <queue-capacity>15000</queue-capacity>
            <queue-full-behavior>DISCARD_AFTER_MUTATION</queue-full-behavior>
            <properties>
                <property name="endpoints">10.3.5.1:5701,10.3.5.2:5701</property>
                <property name="batch.size">1000</property>
                <property name="batch.max.delay.millis">2000</property>
                <property name="response.timeout.millis">60000</property>
                <property name="ack.type">ACK_ON_OPERATION_COMPLETE</property>
                <property name="snapshot.enabled">false</property>
                <property name="group.password">nyc-pass</property>
            </properties>
        </wan-publisher>
    </wan-replication>
<!--
    ===== HAZELCAST NETWORK CONFIGURATION =====
    
    The configuration to build your Hazelcast's network includes configuration for port, interface, discovery 
    mechanism, SSL, encryption, etc. The configuration element's name is <network>. 
    It has the following sub-elements:
    * <public address>:  
	This optional element overrides the public address of a member. It is useful when 
	you have a private cloud. Normally, a member selects its socket address as its public address. But behind a NAT, 
	two members may not be able to see/access each other. In this case, you can set their public addresses to their 
	defined addresses on NAT. The value should be given in the format "host IP address:port number".
    * <port>: 
	Specifies the ports that Hazelcast will use to communicate between cluster members. It is optional and 
	its default value is 5701. It has the following attributes:
	- port-count: 
		By default, Hazelcast will try 100 ports to bind (i.e. the ports between 5701 and 5801). You can 
		change the port count in such cases as having large instances on a single machine or you are
		willing to have only a few ports assigned. port-count is optional and its default value is 100.
	- auto-increment:
		By default, Hazelcast tries to find a port by automatically incrementing the port numbers. If you 
		don't want this (for example, you want to use a specific port), set auto-increment to false. If it is 
		set to false, the port-count attribute is ignored. auto-increment is optional and its default value is true.
		Examples:
		The example below looks for ports between 5701 and 5721, incrementing the ports starting from 5701.	
		<port port-count="20">5701</port>
		The example below forces Hazelcast to use only the port 5701.
		<port auto-increment="false">5701</port>
    * <outbound-ports>:
	By default, Hazelcast lets the system pick up an ephemeral port during socket bind operation. But security 
	policies/firewalls may require you to restrict outbound ports to be used by Hazelcast-enabled applications. 
	You can specify these ports using <ports> under the element <outbound-ports>. You can give a single 
	port number, comma separated multiple ports or port ranges. See the example below.
	<outbound-ports>
		<ports>33000-35000</ports>
		<ports>37000,37001,37002,37003</ports> 
		<ports>38000,38500-38600</ports>
	</outbound-ports>
    * <reuse-address>:
	If you set this to true, Hazelcast will use the same port when you restart a member right after you 
	shut it down. It is optional and its default value is false.
    * <join>:
	This configuration lets you choose a discovery mechanism that Hazelcast will use to form a cluster. 
	Hazelcast can find members by multicast, TCP/IP lists and in the clouds supported by jclouds API. 
	The following are the elements of <join>:
	- <multicast>:
		Set its "enabled" attribute to true for discovery by multicast. It has another attribute
		("loopbackModeEnabled") which enables or disables the loopback mode in the multicast discovery
		mechanism. 
		It has the following sub-elements to fine tune the multicast discovery.
		- <multicast-group>:
			Specifies the multicast group IP address when you want to create clusters within 
			the same network. Its default value is 224.2.2.3.
		- <multicast-port>: 
			Specifies the multicast socket port that the Hazelcast member listens to and 
			sends discovery messages through. Its default value is 54327.
		- <multicast-time-to-live>: 
			Time-to-live value for multicast packets sent out to control the scope of multicasts.
		- <multicast-timeout-seconds>: 
			Only when the members are starting up, this timeout (in seconds) specifies the 
			period during which a member waits for a multicast response from another node. 
			For example, if you set it as 60 seconds, each node will wait for 60 seconds until a 
			leader node is selected. Its default value is 2 seconds.
		- <trusted-interfaces>: 
			Includes IP addresses of trusted members. When a node wants to join to the cluster, 
			its join request will be rejected if it is not a trusted member. 
			You can give an IP addresses range using the wildcard (*) on the last digit of 
			IP address (e.g. 192.168.1.* or 192.168.1.100-110).
	- <tcp>:
		Set its "enabled" attribute to true for discovery by TCP/IP. It has the following sub-elements
		to fine tune the multicast discovery.
		- <required-member>:
			IP address of the required member. Cluster will only be formed if the member with this 
			IP address is found.
		- <member>:
			IP address(es) of one or more well known members. Once members are connected to these 
			well known ones, all member addresses will be communicated with each other. You can 
			also give comma separated IP addresses using the <members> element.
		- <connection-timeout-seconds>:
			Defines the connection timeout. This is the maximum amount of time Hazelcast is going 
			to try to connect to a well known member before giving up. Increasing this value is 
			recommended if you have many IPs listed and the members cannot properly build up the 
			cluster. Its default value is 5.
	- <aws>:
		Set its "enabled" attribute to true for discovery within Amazon EC2. It has the following sub-elements:
		- <access-key>:
			Access key of your account on EC2.
		- <secret-key>:
			Secret key of your account on EC2.
		- <iam-role>:
			IAM role that binds with your instance.
		- <region>:
			The region where your Hazelcast members run. Default value is us-east-1.
                        It needs to be specified if the region is other than the default one.
		- <host-header>:
			The URL that is the entry point for a web service. It is optional.
		- <security-group-name>:
			Name of the security group you specified at the EC2 management console.
                        It is used to narrow the Hazelcast members to be within this group. It is optional.
		- <tag-key>:
			To narrow the members in the cloud down to only Hazelcast members, you can set
                        this to the one you specified in the EC2 console. It is optional.
		- <tag-value>:
			To narrow the members in the cloud down to only Hazelcast members, you can set
                        this to the one you specified in the EC2 console. It is optional.
	- <discovery-strategies>:
		Set its "enabled" attribute to true for discovery in a jclouds backed cloud. You also need to set the
		value of "hazelcast.discovery.enabled" property to true. See the description of the <properties> element
		to learn how to do this.
		You can define multiple discovery strategies using the <discovery-strategy> sub-element and its 
		properties. Please refer to 
		http://docs.hazelcast.org/docs/latest/manual/html-single/index.html#discovering-members-with-jclouds
		to see the properties you can use.
		The following is an example for EC2 cloud.
		<discovery-strategies>
			<discovery-strategy class="com.hazelcast.jclouds.JCloudsDiscoveryStrategy" enabled="true">
			<properties>
				<property name="provider">aws-ec2</property>
				<property name="identity">AWS_IDENTITY</property>
				<property name="credential">AWS_CREDENTIAL</property>
			</properties>
			</discovery-strategy>
		</discovery-strategies>
    * <interfaces>:
	Specifies which network interfaces Hazelcast should use. You need to set its "enabled" attribute
	to true to be able to use your defined interfaces. You can define multiple interfaces
	using its <interface> sub-element. By default, it is disabled.
    * <ssl>:
	Lets you configure SSL using the SSL context factory. This feature is available only in Hazelcast
	Enterprise. To be able to use it, encryption should NOT be enabled and you should first implement 
	your SSLContextFactory class. Its configuration contains the factory class and SSL properties. 
	By default, it is disabled. The following is an example:
	<ssl enabled="true">
		<factory-class-name>
			com.hazelcast.nio.ssl.BasicSSLContextFactory
		</factory-class-name>
		<properties>
			<property name="keyStore">keyStore</property>
			<property name="keyStorePassword">keyStorePassword</property>
			<property name="keyManagerAlgorithm">SunX509</property>
			<property name="trustManagerAlgorithm">SunX509</property>
			<property name="protocol">TLS</property>
		</properties>
	</ssl>
    * <socket-interceptor>:
	Lets you add custom hooks to join and perform connection procedures (like identity checking using 
	Kerberos, etc.). This feature is available only in Hazelcast Enterprise. To be able to use it, you 
	should first implement the MemberSocketInterceptor (for members joining to a cluster) or 
	SocketInterceptor (for clients connecting to a member) class. Its configuration contains the class you 
	implemented and socket interceptor properties. By default, it is disabled. The following is an example:
	<socket-interceptor enabled="true">
		<class-name>
			com.hazelcast.examples.MySocketInterceptor
		</class-name>
		<properties>
			<property name="kerberos-host">kerb-host-name</property>
			<property name="kerberos-config-file">kerb.conf</property>
		</properties>
	</socket-interceptor>
    * <symmetric-encryption>:
	Lets you encrypt the entire socket level communication among all Hazelcast members.
	This feature is available only in Hazelcast Enterprise.  Its configuration contains the encryption 
	properties and the same configuration must be placed to all members. By default, it is disabled. 
	The following is an example:
	<symmetric-encryption enabled="true">
		<algorithm>PBEWithMD5AndDES</algorithm>
		<salt>thesalt</salt>
		<password>thepass</password>
		<iteration-count>19</iteration-count>
	</symmetric-encryption>
-->        
   <network>
        <public-address>11.22.33.44:5555</public-address>
        <port auto-increment="true" port-count="100">5701</port>
        <outbound-ports>
            <ports>34500</ports>
        </outbound-ports>
        <reuse-address>false</reuse-address>
        <join>
            <multicast enabled="true">
                <multicast-group>224.2.2.3</multicast-group>
                <multicast-port>54327</multicast-port>
            </multicast>
            <tcp-ip enabled="false">
                <interface>127.0.0.1</interface>
            </tcp-ip>
            <discovery-strategies>
		<discovery-strategy class="com.hazelcast.jclouds.JCloudsDiscoveryStrategy" enabled="true">
			<properties>
				<property name="provider">google-compute-engine</property>
				<property name="identity">GCE_IDENTITY</property>
				<property name="credential">GCE_CREDENTIAL</property>
			</properties>
		</discovery-strategy>
            </discovery-strategies>
        </join>
        <interfaces enabled="true">
            <interface>10.10.1.*</interface>
        </interfaces>
        <ssl enabled="false" />
        <socket-interceptor enabled="false" />
        <symmetric-encryption enabled="false" />
    </network>
<!--
    ===== PARTITION GROUPING CONFIGURATION =====
    
    Configuration element's name is <partition-group>. You can enable it and specify the type using 
    the "enabled" and "group-type" attributes. For CUSTOM type, you can define groups using its 
    <member-group> and <interface> sub-elements. You can group the members with one of the following types:
    * HOST_AWARE: 
	Members sharing the same network interface are grouped together. All members on the same host will be a 
	single partition group.
    * CUSTOM: 
	You can add different and multiple members to a group.
    * PER_MEMBER: 
	Each member is a group of its own and primary/backup partitions are distributed 
	randomly (not on the same physical member).
    * ZONE_AWARE: 
	Backups are created in the other zones. Each zone will be accepted as one partition group. 
	It can be used when you make use of Hazelcast's jclouds or Azure discovery service plugins. 
    * SPI: 
	You can provide your own partition group implementation using the SPI grouping type. Please see 
	Partition Group Configuration section in Hazelcast Reference Manual.
-->
    <partition-group enabled="true" group-type="CUSTOM">
	<member-group>
	   <interface>10.10.0.*</interface>
	   <interface>10.10.3.*</interface>
	   <interface>10.10.5.*</interface>
	</member-group>
	<member-group>
	   <interface>10.10.10.10-100</interface>
	   <interface>10.10.1.*</interface>
	   <interface>10.10.2.*</interface>
	</member-group>
    </partition-group>
<!--
    ===== HAZELCAST EXECUTOR SERVICE CONFIGURATION =====
    
    Configuration element's name is <executor-service>. It has the optional attribute "name" with which you 
    can specify the name of your executor service. Its default value is "default". 
    It has the following sub-elements:
    * <statistics-enabled>: 
	When you enable it, you can retrieve executor service statistics such as pending operations count, 
	started operations count, completed operations count, and cancelled operations count. Its default 
	value is true.
    * <pool-size>: 
	The number of executor threads per member for the executor. Its default value is 8.
    * <queue-capacity>: 
	Task queue capacity of the executor. Its default value is 0, meaning Integer.MAX_VALUE.
-->
    <executor-service name="default">
        <statistics-enabled>true</statistics-enabled>
        <pool-size>16</pool-size>
        <queue-capacity>0</queue-capacity>
    </executor-service>
<!--
    ===== HAZELCAST DURABLE EXECUTOR SERVICE CONFIGURATION =====
    
    Configuration element's name is <durable-executor-service>. It has the optional attribute "name" with which you 
    can specify the name of your durable executor service. Its default value is "default". 
    It has the following sub-elements:
    * <pool-size>: 
	The number of executor threads per member for the executor. Its default value is 8.
    * <durability>:
    	Durability of the executor.
    * <capacity>: 
	Capacity of the executor task per partition.
-->
    <executor-service name="default">
        <statistics-enabled>true</statistics-enabled>
        <pool-size>16</pool-size>
        <queue-capacity>0</queue-capacity>
    </executor-service>
<!--
    ===== HAZELCAST QUEUE CONFIGURATION =====
    
    Configuration element's name is <queue>. It has the optional attribute "name" with which you 
    can specify the name of your queue. Its default value is "default".
    It has the following elements:
    * <statistics-enabled>: 
	When you enable it, you can retrieve queue statistics. Its default value is true.
    * <max-size>: 
	Maximum size of the queue. When a JVM's local queue size reaches the maximum, all put/offer operations 
	will be blocked until the queue size of the JVM goes below this maximum. Its default value is 0, 
	meaning Integer.MAX_VALUE.
    * <backup-count>:
	Number of synchronous backups. Queue is a non-partitioned data structure, so all entries of a Queue 
	resides in one partition. When this parameter is '1', it means there will be 1 backup of that Queue in 
	another member in the cluster. When it is '2', 2 members will have the backup. 0 means there will be no 
	backups. Its default value is 1.
    * <async-backup-count>:
	Number of asynchronous backups. Its default value is 0.
    * <empty-queue-ttl>:
	Used to purge unused or empty queues. If you define a value (time in seconds) for this element, then 
	your queue will be destroyed if it stays empty or unused for that time.
    * <item-listeners>:
	Adds listeners (listener classes) for the queue items using its sub-element <item-listener>. You can 
	also set its attribute "include-value" to true if you want the item event to contain the item values, 
	and you can set its attribute "local" to true if you want to listen to the items on the local member. 
    * <queue-store>:
	Includes configuration elements and attributes for your queue store implementation. When you want to 
	load/store the distributed queue items from/to a persistent datastore, first implement Hazelcast's 
	QueueStore interface and then configure it using this element. It includes your implemented class name 
	and the following property configurations:
	- binary: 
		If you do not reach the queue store from an external application, you might prefer to insert the items 
		in binary form. To do so, set this property to true and skip the deserialization step, which is a 
		performance optimization. Its default value is false.
	- memory-limit:
		Number of items after which Hazelcast will store items only to datastore. For example, 
		if the memory limit is 1000, then the 1001st item will be put only to datastore. 
		This feature is useful when you want to avoid out-of-memory conditions. If you want to 
		always use memory, you can set it to Integer.MAX_VALUE. Its default value is 1000.
	- bulk-load:
		Size of the bulks loaded from QueueStore when the queue is initialized. Its default 
		value is 250.
-->    
    <queue name="default">
        <statistics-enabled>true</statistics-enabled>
        <max-size>0</max-size>
        <backup-count>1</backup-count>
        <async-backup-count>0</async-backup-count>
        <empty-queue-ttl>-1</empty-queue-ttl>
        <item-listeners>
        	<item-listener>
        		com.hazelcast.examples.ItemListener
        	</item-listener>
        </item-listeners>
        <queue-store>
  		<class-name>com.hazelcast.QueueStoreImpl</class-name>
  		<properties>
    			<property name="binary">false</property>
    			<property name="memory-limit">1000</property>
    			<property name="bulk-load">500</property>
  		</properties>
	</queue-store>
    </queue>
<!--
    ===== HAZELCAST MAP CONFIGURATION =====
    
    Configuration element's name is <map>. It has the optional attribute "name" with which you 
    can specify the name of your map. Its default value is "default".
    It has the following sub-elements:
    * <in-memory-format>: 
	Specifies in which format data will be stored in your map. Available values are as follows:
	- BINARY:
		Data will be stored in serialized binary format. It is the default option.
	- OBJECT:
		Data will be stored in deserialized form.
	- NATIVE:
		Data will be stored in the map that uses Hazelcast's High-Density Memory Store feature. This 
		option is available only in Hazelcast Enterprise HD.
    * <statistics-enabled>: 
    	When you enable it, you can retrieve map entry statistics such as creation time, expiration time,  
    	number of hits, key, value, etc. Its default value is true.
    * <optimize-queries>:
	It is deprecated as of Hazelcast 3.6. Use the <cache-deserialized-values> element instead. When  
	<optimize-queries> and <cache-deserialized-values> are used at the same time, Hazelcast will do its 
	best to detect possible conflicts. Conflict detection is done on best-effort basis and you should not 
	rely on it. If true, it increases the speed of query processes in the map. It only works when 
	<in-memory-format> is set to BINARY and performs a pre-caching on the entries queried. Its default 
	value is false.
    * <cache-deserialized-values>:
	Controls caching of deserialized values. Caching makes the query evaluation faster, but it costs memory.
	Available values are as follows:
	- NEVER: Deserialized values will never be cached.
	- INDEX-ONLY: Deserialized values will be cached only when they are inserted into an index.
	- ALWAYS: Deserialized values will always be cached.
    * <backup-count>:
    	Count of synchronous backups. When this count is 1, a map entry will have its backup on one other node in 
    	the cluster. If you set it to 2, then a map entry will have its backup on two other nodes. You can set it 
    	to 0 if you do not want your entries to be backed up. The maximum value for the backup count is 6.
    	Its default value is 1.
    * <async-backup-count>:
	Number of asynchronous backups. Unlike the synchronous backup process, asynchronous backup process does not
	block the map operations. Its default value is 0, meaning there will be no asynchronous backups.
    * <time-to-live-seconds>:
	Maximum time in seconds for each entry to stay in the map. If it is not 0, entries that are older than 
	this time and not updated for this time are evicted automatically. Valid values are integers between 0 and 
	Integer.MAX VALUE. Its default value is 0, which means infinite. If it is not 0, entries are evicted regardless 
	of the set eviction-policy.
    * <max-idle-seconds>:
	Maximum time in seconds for each entry to stay idle in the map. Entries that are idle for more than 
	this time are evicted automatically. An entry is idle if no get, put, EntryProcessor.process or 
	containsKey is called.  Valid values are integers between 0 and Integer.MAX VALUE. Its default value 
	is 0, which means infinite.
    * <eviction-policy>:
	Eviction policy configuration. Its default values is NONE. Available values are as follows:
	- NONE:
		No items will be evicted and the property max-size will be ignored. You still 
		can combine it with time-to-live-seconds and max-idle-seconds.
	- LRU: 	Least Recently Used.
	- LFU: 	Least Frequently Used.
    * <max-size>:
	Maximum size of the map depending on the given policy specified by its "policy" attribute. When maximum 
	size is reached, the map is evicted based on the policy defined. Valid values are integers between 0 and 
	Integer.MAX VALUE. Its default value is 0 and its default policy attribute is "PER_NODE". If you want 
	max-size to work, set the <eviction-policy> to a value other than NONE. Available max-size policies are 
	as follows:
	- PER_NODE:
		Maximum number of map entries in each cluster member. You cannot set the max-size to a value lower 
		than the partition count (which is 271 by default).
	- PER_PARTITION:
		Maximum number of map entries within each partition.
	- USED_HEAP_SIZE: 
		Maximum used heap size in megabytes per map for each Hazelcast instance. It does not work when
		<in-memory-format> is set to OBJECT.
	- USED_HEAP_PERCENTAGE: 
		Maximum used heap size percentage per map for each Hazelcast instance. If, for example, JVM is 
		configured to have 1000 MB and this value is 10, then the map entries will be evicted when used heap size 
		exceeds 100 MB. It does not work when <in-memory-format> is set to OBJECT.
	- FREE_HEAP_SIZE: 
		Minimum free heap size in megabytes for each Hazelcast instance.
	- FREE_HEAP_PERCENTAGE: 
		Minimum free heap size percentage for each Hazelcast instance. If, for example, JVM is configured to 
		have 1000 MB and this value is 10, then the map entries will be evicted when free heap size is below 100 MB.
	- USED_NATIVE_MEMORY_SIZE: 
		Maximum used native memory size in megabytes per map for each Hazelcast instance. It is available only in 
		Hazelcast Enterprise HD.
	- USED_NATIVE_MEMORY_PERCENTAGE: 
		Maximum used native memory size percentage per map for each Hazelcast instance. It is available only in 
		Hazelcast Enterprise HD.
	- FREE_NATIVE_MEMORY_SIZE: 
		Minimum free native memory size in megabytes for each Hazelcast instance. It is available only in 
		Hazelcast Enterprise HD.
	- FREE_NATIVE_MEMORY_PERCENTAGE:
		Minimum free native memory size percentage for each Hazelcast instance. It is available only in 
		Hazelcast Enterprise HD.
    * <eviction-percentage>:
	When <max-size> is reached, the specified percentage of the map will be evicted. For example, if set to 25, 
	25% of the entries will be evicted. Valid values are integers between 0 and 100. Its default value is 25.
    * <min-eviction-check-millis>:
	Specifies the frequency of the eviction process, i.e. minimum time in milliseconds which should elapse before 
	checking whether a partition of the map is evictable or not. Its default value is 100. Setting it to 0 (zero) 
	makes the eviction process run for every put operation.
    * <merge-policy>:
	Policy that specifies how the map entries in the small cluster will merge with the bigger cluster after a 
	split-brain syndrome. Its default values is "com.hazelcast.map.merge.PutIfAbsentMapMergePolicy". Available 
	built-in policies are as follows:
	- com.hazelcast.map.merge.PassThroughMergePolicy:
		Entry will be added if there is no existing entry for the key.
	- com.hazelcast.map.merge.PutIfAbsentMapMergePolicy: 
		Entry will be added if the merging entry does not exist in the cluster.
	- com.hazelcast.map.merge.HigherHitsMapMergePolicy: 
		Entry with the higher number of hits wins.
	- com.hazelcast.map.merge.LatestUpdateMapMergePolicy: 
		Entry with the latest update wins. 
    * <read-backup-data>:
	Used to enable reading from local backup map entries. Its default value is false. It can be used if there is 
	at least 1 sync or async backup.
    * <hot-restart>:
	Used to enable Hazelcast's Hot Restart Persistence feature for the map. It is available only in Hazelcast 
	Enterprise HD. Set its "enabled" to true to enable the feature. By default, it is disabled. It has the following
	sub-element.
	- <fsync>:
		Set to true if the writing to disk should be followed by an fsync() system call. Its default value is false.
    * <map-store>:
	Configuration options when you want to load/store the map entries from/to a persistent data store such as a 
	relational database. Before configuring <map-store>, you need to implement Hazelcast's MapStore or MapLoader 
	interfaces.
	It has the following attributes:
	- enabled:
		Set to true to enable the map store functionality for your map. Its default value is true.
	- initial-mode: 
		Sets the initial entry loading mode. Available values are as follows:
	 	- LAZY: The loading is asynchronous. It is the default mode.
	 	- EAGER: The loading is blocked until all partitions are loaded.
	 
	It has the following sub-elements:
	- <class-name>:
		The name of your class implementing MapLoader and/or MapStore interface.
	- <write-delay-seconds>:
		Number of seconds to delay the storing of entries. If the value is 0, then it is write-through.
		Otherwise, it is write-behind so updates will be stored after this period. Its default value is 0.
	- <write-batch-size>:
		Used to create batches when writing to map store. In default mode, all map entries will try 
		to be written in one go. To create batches, the minimum meaningful value is 2. For values smaller than 2, 
		it works as in default mode. Its default value is 1.
	- <write-coalescing>:
		It is meaningful if you are using write behind in MapStore. When it is set to true,
		only the latest store operation on a key during the write-delay-seconds will be
		reflected to MapStore. Its default value is true.
	- <properties>:
		While you are implementing MapStore or MapLoader you can define specific properties to be configured.
		It can be your store's URL, credentials, etc. Please see the example map configuration snippet below.
    * <near-cache>:
	Configuration options when you want to use a near cache for your map.
	It has the following attributes:
	- name: You can give a name for your near cache. It is optional and its default value is "default".
	
	It has the following sub-elements:
    	- <max-size>:
    		Maximum size of the near cache. When this is reached, near cache is evicted based on the policy defined.
			Any integer between 0 and Integer.MAX_VALUE. 0 means Integer.MAX_VALUE. Its default value is 0.
    	- <time-to-live-seconds>:
    		Maximum number of seconds for each entry to stay in the near cache. Entries that are older than this 
    		period are automatically evicted from the near cache. Any integer between 0 and Integer.MAX_VALUE. 
    		0 means infinite. Its default value is 0.
    	- <max-idle-seconds>:
    		Maximum number of seconds each entry can stay in the near cache as untouched (not read). Entries that 
    		are not read more than this period are removed from the near cache. Any integer between 0 and 
    		Integer.MAX_VALUE. 0 means Integer.MAX_VALUE. Its default value is 0.
    	- <eviction-policy>:
    		Eviction policy configuration. Its default values is NONE. Available values are as follows:
		- NONE:
			No items will be evicted and the property max-size will be ignored. You still 
			can combine it with time-to-live-seconds and max-idle-seconds.
		- LRU: 	Least Recently Used.
		- LFU: 	Least Frequently Used.
    	- <invalidate-on-change>:
    		Specifies whether the cached entries are evicted when the entries are updated or removed. Its default 
    		value is true.
    	- <in-memory-format>:
		Specifies in which format data will be stored in your near cache. Note that a map's in-memory format
		can be different from that of its near cache.
		Available values are as follows:
		- BINARY:
			Data will be stored in serialized binary format. It is the default option.
		- OBJECT:
			Data will be stored in deserialized form.
		- NATIVE:
			Data will be stored in the near cache that uses Hazelcast's High-Density Memory Store feature. 
			This option is available only in Hazelcast Enterprise HD. Note that a map and its near cache 
			can independently use High-Density Memory Store. For example, while your map does not use 
			High-Density Memory Store, its near cache can use it.
    	- <cache-local-entries>:
    		Specifies whether the local entries will be cached. It can be useful when in-memory format for 
    		near cache is different from that of the map. By default, it is disabled.
    	- <eviction>:
    		Configuration for the eviction when the in-memory format of the near cache is NATIVE. It has the 
    		following attributes:
    		- size: Maximum size (entry count) of the near cache.
    		- max-size-policy: Maximum size policy for eviction of the near cache. Available values are as follows:
    			* ENTRY_COUNT: Maximum entry count per member.
         		* USED_NATIVE_MEMORY_SIZE: Maximum used native memory size in megabytes.
         		* USED_NATIVE_MEMORY_PERCENTAGE: Maximum used native memory percentage.
         		* FREE_NATIVE_MEMORY_SIZE: Minimum free native memory size to trigger cleanup.
         		* FREE_NATIVE_MEMORY_PERCENTAGE: Minimum free native memory percentage to trigger cleanup.
    		- eviction-policy: See the <eviction-policy> element above.
    * <wan-replication-ref>:
	Configuration of the WAN replication for your map.
	It has the following attributes:
	- name: 
		Name of the WAN replication configuration specified in the "name" attribute of the 
		<wan-replication> element. See the <wan-replication> element above.
	
	It has the following sub-elements:
	- <merge-policy>:
		Policy to resolve conflicts that are occurred when target cluster already has the replicated entry key.
		Available policies are as follows.
		* com.hazelcast.map.merge.PutIfAbsentMapMergePolicy
		* com.hazelcast.map.merge.HigherHitsMapMergePolicy
		* com.hazelcast.map.merge.PassThroughMergePolicy
		* com.hazelcast.map.merge.LatestUpdateMapMergePolicy
	- <filters>:
		Filters to intercept WAN replication events before they are placed to WAN event replication 
		queues by providing a filtering API. Just implement Hazelcast's MapWanEventFilter interface 
		to create your filters. You can define multiple filters and add to the configuration using the 
		<filter> sub-elements within the <filters> element.
	- <republishing-enabled>:
		When enabled, an incoming event to a member is forwarded to target cluster of that member. Its
		default value is true.
    * <indexes>:
	You can define indexes for your map using this element's <index> sub-elements. Each <index> has 
	only the boolean "ordered" attribute. For example, if you will have a ranged query for a field of a map 
	entry, then this attribute should be set to true. But if the field has a boolean value, then it should 
	be set to false. Its default value is false.
    * <attributes>:
	You can define attributes that may be referenced in predicates, queries and indexes using this element's 
	<attribute> sub-elements. Each <attribute> has only the "extractor" attribute which you should define beforehand
	by implementing Hazelcast's ValueExtractor class.
    * <entry-listeners>:
    	Adds listeners (listener classes) for the map entries using the <entry-listener> sub-elements. You can also set its 
    	attribute "include-value" to true if you want the entry event to contain the item values, and you can set its attribute 
    	"local" to true if you want to listen to the entries on the local member. 
    * <partition-lost-listeners>:
    	Adds the partition lost listeners that you created by implementing Hazelcast's PartitionLostListener interface. 
    * <quorum-ref>:
	Adds the quorum for this map which you configure using the <quorum> element. You should set the <quorum-ref>'s value
	as the <quorum>'s name. 
 -->    
    <map name="default">
        <in-memory-format>BINARY</in-memory-format>
        <statistics-enabled>true</statistics-enabled>
        <optimize-queries>true</optimize-queries>
        <cache-deserialized-values>INDEX-ONLY</cache-deserialized-values>
        <backup-count>1</backup-count>
        <async-backup-count>0</async-backup-count>
        <time-to-live-seconds>0</time-to-live-seconds>
        <max-idle-seconds>0</max-idle-seconds>
        <eviction-policy>NONE</eviction-policy>
        <max-size policy="PER_NODE">0</max-size>
        <eviction-percentage>25</eviction-percentage>
        <min-eviction-check-millis>100</min-eviction-check-millis>
        <merge-policy>com.hazelcast.map.merge.PutIfAbsentMapMergePolicy</merge-policy>
        <cache-deserialized-values>INDEX-ONLY</cache-deserialized-values>
        <read-backup-data>false</read-backup-data>
	<hot-restart enabled="false">
		<fsync>false</fsync>
	</hot-restart>
	<map-store enabled="true" initial-mode="LAZY">
		<class-name>com.hazelcast.examples.DummyStore</class-name>
		<write-delay-seconds>60</write-delay-seconds>
		<write-batch-size>1000</write-batch-size>
		<write-coalescing>true</write-coalescing>
		<properties>
    			<property name="jdbc_url">my.jdbc.com</property>
		</properties>
	</map-store>
	<near-cache>
		<max-size>5000</max-size>
		<time-to-live-seconds>0</time-to-live-seconds>
		<max-idle-seconds>60</max-idle-seconds>
		<eviction-policy>LRU</eviction-policy>
		<invalidate-on-change>true</invalidate-on-change>
		<in-memory-format>BINARY</in-memory-format>
		<cache-local-entries>false</cache-local-entries>
		<eviction size="1000" max-size-policy="ENTRY_COUNT" eviction-policy="LFU"/>
	</near-cache>
	<wan-replication-ref name="my-wan-cluster-batch">
		<merge-policy>com.hazelcast.map.merge.PassThroughMergePolicy</merge-policy>
		<filters>
			<filter-impl>com.example.SampleFilter</filter-impl>
			<filter-impl>com.example.SampleFilter2</filter-impl>
		</filters>
		<republishing-enabled>false</republishing-enabled>
	</wan-replication-ref>
	<indexes>
		<index ordered="false">name</index>
		<index ordered="true">age</index>
	</indexes>
	<attributes>
		<attribute extractor="com.bank.CurrencyExtractor">currency</attribute>
	</attributes>
	<entry-listeners>
		<entry-listener include-value="false" local="false">
			com.your-package.MyEntryListener
		</entry-listener>
	</entry-listeners>
	<partition-lost-listeners>
		<partition-lost-listener>
			com.your-package.YourPartitionLostListener
		</partition-lost-listener>
	</partition-lost-listeners>
	<quorum-ref>quorumRuleWithThreeNodes</quorum-ref>
    </map>
<!--
    ===== HAZELCAST CONTINUOUS QUERY CACHE CONFIGURATION =====
    
    This feature is available only in Hazelcast Enterprise. Configuration element's name is <query-caches>. 
    You can create your query caches using its  <query-cache> sub-element. Its parent element is <map>, 
    i.e. it should be placed within the <map> configuration. Each <query-cache> has the attribute "name" with which you 
    can specify the name of your query cache. 
    It has the following sub-elements:
    * <include-value>:
    	Set to true if you want to cache the value too. Its default value is true.
    * <predicate>:
    	Predicate to filter events which will be applied to the query cache.
    * <entry-listeners>:
    	Adds listeners (listener classes) for your query cache entries. See <entry-listeners> in the map configuration above.
    * <in-memory-format>:
    	Type of the data to be stored in your query cache. See <in-memory-format> in the map configuration above.
    * <populate>:
    	Set to true if you want to enable the initial population of your query cache. Its default value is true.
    * <coalesce>:
    	Set to true if you want to enable the coalescing of your query cache. Its default value is false.
    * <delay-seconds>:
    	Minimum time in seconds that an event waits in the member's buffer. Its default value is 0.
    * <batch-size>:
    	Batch size used to determine the number of events sent in a batch to your query cache. Its default value is 1.
    * <buffer-size>:
    	Maximum number of events which can be stored in a partition buffer. Its default value is 16.
    * <eviction>:
    	Configuration for the eviction of your query cache. See <eviction> in the map configuration above.
    * <indexes>:
    	You can define indexes for your query cache using this element's <index> sub-elements. See <index> in the
    	map configuration above.
-->
	<query-caches>
		<query-cache name="myContQueryCache">
			<include-value>true</include-value>
			<predicate type="class-name">com.hazelcast.examples.ExamplePredicate</predicate>
			<entry-listeners>...</entry-listeners>
			<in-memory-format>NATIVE</in-memory-format>
			<populate>true</populate>
			<coalesce>false</coalesce>
			<delay-seconds>3</delay-seconds>
			<batch-size>2</batch-size>
			<buffer-size>32</buffer-size>
			<eviction size="1000" max-size-policy="ENTRY_COUNT" eviction-policy="LFU"/>
			<indexes>...</indexes>
		</query-cache>
	</query-caches>

<!--
    ===== HAZELCAST MULTIMAP CONFIGURATION =====
    
    Configuration element's name is <multimap>. It has the optional attribute "name" with which you 
    can specify the name of your multimap. Its default value is "default".
    All sub-elements of <multimap> except <value-collection-type> have the same meaning as in <map> configuration.
    You can specify the type of the value collection using <value-collection-type>. Available values are SET and LIST.
-->
    <multimap name="default">
        <backup-count>1</backup-count>
        <async-backup-count>0</async-backup-count>
        <value-collection-type>SET</value-collection-type>
        <entry-listeners>
            <entry-listener include-value="true" local="true">com.hazelcast.examples.EntryListener</entry-listener>
        </entry-listeners>
    </multimap>
<!--
    ===== HAZELCAST REPLICATED MAP CONFIGURATION =====
    
    Configuration element's name is <replicatedmap>. It has the required attribute "name" with which you 
    can specify the name of your replicated map.
    It has the following sub-elements:
    * <in-memory-format>:
	Specifies in which format data will be stored in your replicated map.
	Available values are as follows:
	- BINARY:
		Data will be stored in serialized binary format. It is the default option.
	- OBJECT:
		Data will be stored in deserialized form.
    * <concurrency-level>:
    	Number of parallel mutexes to minimize contention on keys. Its default value is 32.
    	If higher contention is seen on writes to values inside the replicated map, this value can 
    	be adjusted to the needs.
    * <replication-delay-millis>:
    	Time in milliseconds after a put is executed before the value is replicated
	to other members. During this time, multiple puts can be operated and cached up to be sent
	out all at once after the delay. Default value is 100ms. If set to 0, no delay is used and
	all values are replicated one by one.
    * <replication-delay-millis>:
    * <async-fillup>:
    	Specifies whether the replicated map is available for reads before the initial
	replication is completed. Its default value is true. If false, no Exception will be
	thrown when the replicated map is not yet ready, but call is blocked until the initial 
	replication is completed.
    * <statistics-enabled>:
	When you enable it, you can retrieve replicated map entry statistics such as creation time,
	expiration time, number of hits, key, value, etc. Its default value is true.
    * <entry-listeners>:
    	Adds listeners (listener classes) for the replicated map entries using the <entry-listener> sub-elements. 
    	You can also set its attribute "include-value" to true if you want the entry event to contain the item values, 
    	and you can set its attribute "local" to true if you want to listen to the entries on the local member. 
-->
    <replicatedmap name="replicatedMap1">
        <in-memory-format>BINARY</in-memory-format>
        <concurrency-level>32</concurrency-level>
        <replication-delay-millis>200</replication-delay-millis>
        <async-fillup>true</async-fillup>
        <statistics-enabled>true</statistics-enabled>
	<entry-listeners>
	    <entry-listener include-value="true" local="true">com.hazelcast.examples.EntryListener</entry-listener>
        </entry-listeners>
    </replicatedmap>
<!--
    ===== HAZELCAST CACHE CONFIGURATION =====
    
    Configuration element's name is <cache>. It has the required attribute "name" with which you 
    can specify the name of your cache.
    It has the following sub-elements:
    * <key-type>:
	Type of the cache entries' keys. The fully qualified class name of the cache key type should be given 
	using its "class-name" attribute.
    * <value-type>:
	Type of the cache entries' values. The fully qualified class name of the cache value type should be given 
	using its "class-name" attribute.    
    * <statistics-enabled>:
    	When you enable it, you can retrieve cache entry statistics such as creation time, expiration time,  
    	number of hits, key, value, etc. Its default value is false.    
    * <management-enabled>:
	If set to true, JMX beans are enabled and collected statistics are provided. It doesn't automatically 
	enable statistics collection. Its default value is false.
    * <read-through>:
	If set to true, enables read-through behavior of the cache to an underlying configured 
	javax.cache.integration.CacheLoader which is also known as lazy-loading. Its default value is false.
    * <write-through>:
	If set to true, enables write-through behavior of the cache to an underlying configured 
	javax.cache.integration.CacheWriter which passes any changed value to the external backend resource. Its default 
	value is false.
    * <cache-loader-factory>:
	Fully qualified class name of the javax.cache.configuration.Factory implementation providing a 
	javax.cache.integration.CacheLoader instance to the cache. Provide this class name by using its "class-name"
	attribute.
    * <cache-writer-factory>:
	Fully qualified class name of the javax.cache.configuration.Factory implementation providing a 
	javax.cache.integration.CacheWriter instance to the cache. Provide this class name using its "class-name"
	attribute.
    * <expiry-policy-factory>:
	Fully qualified class name of the javax.cache.configuration.Factory implementation providing a 
	javax.cache.expiry.ExpiryPolicy instance to the cache. Provide this class name using its "class-name"
	attribute.
    * <cache-entry-listeners>:
	List of cache entry listeners given by its <cache-entry-listener> sub-element. Each <cache-entry-listener>
	has the following attributes:
	- old-value-required: 
		If set to true, previously assigned values for the affected keys will be sent to the 
		javax.cache.event.CacheEntryListener implementation. Setting this attribute to true creates additional 
		traffic. Its default value is false.
	- synchronous: 
		If set to true, the javax.cache.event.CacheEntryListener implementation will be called in a synchronous 
		manner. Its default value is false.
	It has the following sub-elements:
	- cache-entry-listener-factory: 
		Fully qualified class name of the javax.cache.configuration.Factory implementation providing a 
		javax.cache.event.CacheEntryListener instance.
	- cache-entry-event-filter-factory:
		Fully qualified class name of the javax.cache.configuration.Factory implementation providing a 
		javax.cache.event.CacheEntryEventFilter instance.
    * <in-memory-format>:
    	Specifies in which format data will be stored in your cache. Available values are as follows:
	- BINARY:
		Data will be stored in serialized binary format. It is the default option.
	- OBJECT:
		Data will be stored in deserialized form.
	- NATIVE:
		Data will be stored in the cache that uses Hazelcast's High-Density Memory Store feature. 
		This option is available only in Hazelcast Enterprise HD.
    * <backup-count>:
	Number of synchronous backups. If it is 1, for example, then all entries of the cache are copied to 
	one other instance as synchronous for fail-safety. Its default value is 1.
    * <async-backup-count>:
    	Number of asynchronous backups. For example, if it is 1, then all entries of the cache are copied to 
    	one other instance as asynchronous for fail-safety. The sum of <backup-count> and <async-backup-count> 
    	cannot be larger than 6. Its default value is 0.
    * <eviction>:
	Configuration for the eviction of your cache. It has the following attributes:
	- size: Maximum size (entry count) of the cache.
	- max-size-policy: Maximum size policy for eviction of the cache. Available values are as follows:
		* ENTRY_COUNT: Maximum entry count per member.
		* USED_NATIVE_MEMORY_SIZE: Maximum used native memory size in megabytes.
		* USED_NATIVE_MEMORY_PERCENTAGE: Maximum used native memory percentage.
		* FREE_NATIVE_MEMORY_SIZE: Minimum free native memory size to trigger cleanup.
		* FREE_NATIVE_MEMORY_PERCENTAGE: Minimum free native memory percentage to trigger cleanup.
	- eviction-policy: See the <eviction-policy> element above.
    * <wan-replication-ref>:
	Configuration of the WAN replication for your cache.
	It has the following attributes:
	- name: 
		Name of the WAN replication configuration specified in the "name" attribute of the 
		<wan-replication> element. See the <wan-replication> element above.
	
	It has the following sub-elements:
	- <merge-policy>:
		Policy to resolve conflicts that are occurred when target cluster already has the replicated entry key.
		Available policies are as follows.
		* com.hazelcast.cache.merge.HigherHitsCacheMergePolicy
		* com.hazelcast.cache.merge.PassThroughCacheMergePolicy
	- <filters>:
		Filters to intercept WAN replication events before they are placed to WAN event replication 
		queues by providing a filtering API. Just implement Hazelcast's CacheWanEventFilter interface 
		to create your filters. You can define multiple filters and add to the configuration using the 
		<filter> sub-elements within the <filters> element.
	- <republishing-enabled>:
		When enabled, an incoming event to a member is forwarded to target cluster of that member. Its
		default value is true.
    * <quorum-ref>:
    	Adds the quorum for this cache which you configure using the <quorum> element. You should set the 
    	<quorum-ref>'s value as the <quorum>'s name.     
    * <partition-lost-listeners>:
    	Adds the partition lost listeners that you created by implementing Hazelcast's PartitionLostListener interface. 
    * <merge-policy>:
    	The following are the built-in merge policies for cache. You can either use their full class names or constant 
    	names (given in parentheses).
	- com.hazelcast.cache.merge.PassThroughCacheMergePolicy (PASS_THROUGH)
	- com.hazelcast.cache.merge.PutIfAbsentCacheMergePolicy (PUT_IF_ABSENT)
	- com.hazelcast.cache.merge.HigherHitsCacheMergePolicy (HIGHER_HITS)
	- com.hazelcast.cache.merge.LatestAccessCacheMergePolicy (LATEST_ACCESS)
    * <hot-restart>:
	Used to enable Hazelcast's Hot Restart Persistence feature for the cache. It is available only in Hazelcast 
	Enterprise HD. Set its "enabled" to true to enable the feature. By default, it is disabled. It has the following
	sub-element.
	- <fsync>:
		Set as true if the writing to disk should be followed by an fsync() system call. Its default value is false.    
    * <disable-per-entry-invalidation-events>:
	Disables invalidation events for each entry; but full-flush invalidation events are still enabled. 
	Full-flush invalidation means the invalidation of events for all entries when clear is called. 
	The default value is false.
-->
    <cache name="default">
        <key-type class-name="java.lang.Object"/>
        <value-type class-name="java.lang.Object"/>
        <statistics-enabled>false</statistics-enabled>
        <management-enabled>false</management-enabled>
        <read-through>true</read-through>
        <write-through>true</write-through>
        <cache-loader-factory
                class-name="com.example.cache.MyCacheLoaderFactory"/>
        <cache-writer-factory
                class-name="com.example.cache.MyCacheWriterFactory"/>
        <expiry-policy-factory
                class-name="com.example.cache.MyExpirePolicyFactory"/>
        <cache-entry-listeners>
            <cache-entry-listener old-value-required="false" synchronous="false">
                <cache-entry-listener-factory
                        class-name="com.example.cache.MyEntryListenerFactory"/>
                <cache-entry-event-filter-factory
                        class-name="com.example.cache.MyEntryEventFilterFactory"/>
            </cache-entry-listener>
        </cache-entry-listeners>
        <in-memory-format>NATIVE</in-memory-format>
        <backup-count>1</backup-count>
        <async-backup-count>0</async-backup-count>
        <eviction size="1000" max-size-policy="ENTRY_COUNT" eviction-policy="LFU"/>
	<wan-replication-ref name="my-wan-cluster-batch">
	    <merge-policy>com.hazelcast.cache.merge.PassThroughCacheMergePolicy</merge-policy>
	    <republishing-enabled>true</republishing-enabled>
	    <filters>
		<filter-impl>com.example.SampleFilter</filter-impl>
	    </filters>
	</wan-replication-ref>
        <quorum-ref>quorumRuleWithThreeNodes</quorum-ref>
	<partition-lost-listeners>
		<partition-lost-listener>
			com.your-package.YourPartitionLostListener
		</partition-lost-listener>
	</partition-lost-listeners>
        <merge-policy>com.hazelcast.cache.merge.LatestAccessCacheMergePolicy</merge-policy>
	<hot-restart enabled="false">
		<fsync>false</fsync>
	</hot-restart>
	<disable-per-entry-invalidation-events>true</<disable-per-entry-invalidation-events>
    </cache>

<!--
    ===== HAZELCAST LIST CONFIGURATION =====
    
    Configuration element's name is <list>. It has the optional attribute "name" with which you 
    can specify the name of your list. This attribute's default value is "default".
    It has the following sub-elements:
    * <statistics-enabled>: 
	When you enable it, you can retrieve list statistics. Its default value is true.
    * <max-size>: 
	Maximum size of the list (item count). Its default value is 0, meaning Integer.MAX_VALUE.
    * <backup-count>:
	Number of synchronous backups. List is a non-partitioned data structure, so all entries of a 
	List reside in one partition. If it is set to 1, there will be 1 backup of that List in another 
	member in the cluster. When it is 2, 2 members will have the backup. Its default value is 1.
    * <async-backup-count>:
	Number of asynchronous backups. Its default value is 0.
    * <item-listeners>:
	Adds listeners (listener classes) for the List items using its sub-element <item-listener>. You can 
	also set its attribute "include-value" to true if you want the item event to contain the item values.
-->
    <list name="default">
        <statistics-enabled>false</statistics-enabled>
        <max-size>0</max-size>
        <backup-count>1</backup-count>
        <async-backup-count>0</async-backup-count>
        <item-listeners>
            <item-listener include-value="true">com.hazelcast.examples.ItemListener</item-listener>
        </item-listeners>
    </list>
<!--
    ===== HAZELCAST SET CONFIGURATION =====
    
    Configuration element's name is <set>. It has the optional attribute "name" with which you 
    can specify the name of your set. This attribute's default value is "default".
    It has the following sub-elements:
    * <statistics-enabled>: 
	When you enable it, you can retrieve set statistics. Its default value is true.
    * <max-size>: 
	Maximum size of the set (item count). Its default value is 0, meaning Integer.MAX_VALUE.
    * <backup-count>:
	Number of synchronous backups. Set is a non-partitioned data structure, so all entries of a 
	Set reside in one partition. If it is set to 1, there will be 1 backup of that Set in another 
	member in the cluster. When it is 2, 2 members will have the backup. Its default value is 1.
    * <async-backup-count>:
	Number of asynchronous backups. Its default value is 0.
    * <item-listeners>:
	Adds listeners (listener classes) for the Set items using its sub-element <item-listener>. You can 
	also set its attribute "include-value" to true if you want the item event to contain the item values.
-->
    <set name="default">
	<backup-count>1</backup-count>
	<async-backup-count>0</async-backup-count>
	<max-size>10</max-size>
        <item-listeners>
            <item-listener include-value="true">com.hazelcast.examples.ItemListener</item-listener>
        </item-listeners>
   </set>
<!--
    ===== HAZELCAST TOPIC CONFIGURATION =====
    
    Configuration element's name is <topic>. It has the optional attribute "name" with which you 
    can specify the name of your topic. This attribute's default value is "default".
    It has the following sub-elements:
    * <global-ordering-enabled>:
	When it is set to true, all cluster members that listen to a topic will receive the messages in the 
	same order they were published by all members. This way, Hazelcast guarantees that all members will 
	see the in the same order. Its default value is false.
    * <statistics-enabled>: 
	When you enable it, you can retrieve topic statistics such as total number of published and 
	received messages. Its default value is true.
    * <message-listeners>:
	Adds listeners (listener classes) for the Topic messages using its sub-element <message-listener>.
-->
   <topic name="default">
	<global-ordering-enabled>true</global-ordering-enabled>
	<statistics-enabled>true</statistics-enabled>
	<message-listeners>
	    <message-listener>com.hazelcast.examples.MessageListener</message-listener>
	</message-listeners>
   </topic>
<!--
    ===== HAZELCAST RELIABLE TOPIC CONFIGURATION =====
    
    Reliable Topic uses the same ITopic interface. The main difference is that it is backed up by
    Hazelcast Ringbuffer data structure. Reliable Topic messages are stored in the Ringbuffer
    Configuration element's name is <reliable-topic>. It has the optional attribute "name" with which you 
    can specify the name of your Reliable Topic, which is the same name you give to your Ringbuffer. 
    This attribute's default value is "default".
    It has the following sub-elements:
    * <statistics-enabled>: 
	When you enable it, you can retrieve Reliable Topic statistics. Its default value is true.
    * <topic-overload-policy>:
	Policy to handle an overloaded topic. Its default value is BLOCK. Available values are as follows:
	- DISCARD_OLDEST:
		A message that has not expired can be overwritten. It does not matter if the retention period is set,
     	the overwrite will just overwrite the message.
	- DISCARD_NEWEST:
		Message that was to be published is discarded.
	- BLOCK:
		The caller will wait until there is space in the Ringbuffer.
	- ERROR
		The publish call fails immediately.
    * <message-listeners>:
	Adds listeners (listener classes) for the Reliable Topic messages using its sub-element <message-listener>.
-->
   <reliable-topic name="default">
        <statistics-enabled>true</statistics-enabled>
        <topic-overload-policy>ERROR</topic-overload-policy>
        <read-batch-size>10</read-batch-size>
        <message-listeners>
            <message-listener>com.hazelcast.examples.MessageListener</message-listener>
        </message-listeners>
    </reliable-topic>
<!--
    ===== HAZELCAST MAPREDUCE JOBTRACKER CONFIGURATION =====
    
    Configuration element's name is <jobtracker>. It has the required attribute "name" with which you 
    can specify the name of your MapReduce JobTracker. This attribute's default value is "default".
    It has the following sub-elements:
    * <max-thread-size>: 
	Maximum thread pool size of the JobTracker. Its default value is 0.
    * <queue-size>:
    	Maximum number of tasks that can wait to be processed. A value of 0 means an unbounded queue. 
    	Very low numbers can prevent successful execution since job might not be correctly scheduled or intermediate 
    	chunks might be lost. Its default value is 0.
    * <retry-count>:
    	Currently not used. Reserved for later use where the framework will automatically try to restart / retry 
    	operations from an available saved point.
    * <chunk-size>:
    	Number of emitted values before a chunk is sent to the reducers. If your emitted values are big or you want to 
    	better balance your work, you might want to change this to a lower or higher value. A value of 0 means immediate 
    	transmission, but remember that low values mean higher traffic costs. A very high value might cause an 
    	OutOfMemoryError to occur if the emitted values do not fit into heap memory before being sent to the reducers. 
    	To prevent this, you might want to use a combiner to pre-reduce values on mapping members. Its default 
    	value is 1000.
    * <communicate-stats>:
    	Specifies whether the statistics (for example, statistics about processed entries) are transmitted to 
    	the job emitter. This can show progress to a user inside of an UI system, but it produces additional traffic. 
    	If not needed, you might want to deactivate this. Its default value is true.
    * <topology-changed-strategy>:
    	Specifies how the MapReduce framework reacts on topology changes while executing a job. Currently, only 
    	CANCEL_RUNNING_OPERATION is fully supported, which throws an exception to the job emitter 
    	(will throw a com.hazelcast.mapreduce.TopologyChangedException).
-->
    <jobtracker name="default">
        <max-thread-size>0</max-thread-size>
        <queue-size>0</queue-size>
        <retry-count>0</retry-count>
        <chunk-size>1000</chunk-size>
        <communicate-stats>true</communicate-stats>
        <topology-changed-strategy>CANCEL_RUNNING_OPERATION</topology-changed-strategy>
    </jobtracker>
<!--
    ===== HAZELCAST SEMAPHORE CONFIGURATION =====
    
    Configuration element's name is <semaphore>. It has the required attribute "name" with which you 
    can specify the name of your Semaphore. This attribute's default value is "default".
    It has the following sub-elements:
    * <initial-permits>:
    	The thread count to which the concurrent access is limited. For example, if you set
	it to 3, concurrent access to the object is limited to 3 threads.
    * <backup-count>:
    	Number of synchronous backups. For example, if it is set to 1, all permits of the semaphore 
    	are copied to one other member for fail-safety. Its default value is 1.
    * <async-backup-count>:
	Number of asynchronous backups. Its default value is 0.
-->
    <semaphore name="default">
        <initial-permits>0</initial-permits>
        <backup-count>1</backup-count>
        <async-backup-count>0</async-backup-count>
    </semaphore>
<!--
    ===== HAZELCAST RINGBUFFER CONFIGURATION =====
    
    Configuration element's name is <ringbuffer>. It has the required attribute "name" with which you 
    can specify the name of your Ringbuffer. This attribute's default value is "default".
    It has the following sub-elements:
    * <capacity>:
    	Number of items in the Ringbuffer. If no <time-to-live-seconds> is set, this value will always
	be equal to the capacity after the head completes the first loop around the ring. This is
	because no items are getting retired. Its default value is 10000.
    * <time-to-live-seconds>:	
	Maximum number of seconds for each entry to stay in the Ringbuffer. Entries that are older than 
	this value and are not updated for this period  are automatically evicted from the Ringbuffer. 
	Any integer between 0 and Integer.MAX_VALUE. 0 means infinite. Its default value is 0.
    * <backup-count>:
    	Number of synchronous backups. For example, if it is set to 1, then the Ringbuffer items 
    	are copied to one other member for fail-safety. Its default value is 1.
    * <async-backup-count>:
	Number of asynchronous backups. Its default value is 0.
    * <in-memory-format>:
	Specifies in which format data will be stored in your Ringbuffer.
	Available values are as follows:
	- BINARY:
		Data will be stored in serialized binary format. It is the default option.
	- OBJECT:
		Data will be stored in deserialized form.
-->

    <ringbuffer name="default">
        <capacity>10000</capacity>
        <time-to-live-seconds>30</time-to-live-seconds>
        <backup-count>1</backup-count>
        <async-backup-count>0</async-backup-count>
        <in-memory-format>BINARY</in-memory-format>
    </ringbuffer>
<!--
    Configuration used to register the listeners that you created by implementing Hazelcast's
    MembershipListener, DistributedObjectListener, MigrationListener and PartitionLostListener interfaces.
-->
    <listeners>
        <listener>your-package.YourMembershipListener</listener>
        <listener>your-package.YourDistributedObjectListener</listener>
        <listener>your-package.YourMigrationListener</listener>
        <listener>your-package.YourPartitionLostListener</listener>
    </listeners>
<!--
    ===== HAZELCAST SERIALIZATION CONFIGURATION =====
    
    Configuration element's name is <serialization>.
    It has the following sub-elements:
    * <portable-version>:
    	Version of the portable serialization. Portable version is used to differentiate two
		of the same classes that have changes such as a new field or a new field type.
    * <use-native-byte-order>:
    	Set as true if you want to use the native byte order of the underlying platform. Its default value is false.
    * <byte-order>:
    	Specifies the byte order that the serialization will use. Its default value is BIG_ENDIAN. Available values
    	are BIG_ENDIAN and LITTLE_ENDIAN.
    * <enable-compression>:
    	Set as true to enable compression when default Java serialization is used. Its default value is false.
    * <enable-shared-object>:
    	Set as true to enable shared object when default Java serialization is used. Its default value is false.
    * <allow-unsafe>:
    	Set as true to allow the usage of unsafe. Its default value is false.
    * <data-serializable-factories>:
    	Lists your class implementations of Hazelcast's DataSerializableFactory using the <data-serializable-factory>
    	sub-elements. Each factory has the required "factory-id" attribute that you should give as the ID of your 
    	factory.
    * <portable-factories>:
    	Lists your class implementations of Hazelcast's PortableFactory using the <portable-factory>
    	sub-elements. Each factory has the required "factory-id" attribute that you should give as the ID of your 
    	factory.
    * <serializers>:
    	Lists the serializers (classes) that you implement using Hazelcast's StreamSerializer, ByteArraySerializer, 
    	Global Serializer, etc. Global serializer should be specified using the <global-serializer> sub-element.
    	For others, use the <serializer> sub-element. 
    	
    	The <serializer> sub-element has two required attributes:
    	- class-name: Full class name of the serializer you implemented.
    	- type-class: Type of your serializer class implementation.
    	
    	The <global-serializer> sub-element has an optional boolean "override-java-serialization" attribute. If you set
    	it as true, the Java serialization step will be handled by the global serializer, not by the Java Serializable or
    	Externalizable.
    * <check-class-def-errors>:
    	If set to true, serialization system will check the class definitions error at the start of serialization process
    	and throw a Serialization Exception with the error definition.
-->
    <serialization>
        <portable-version>0</portable-version>
        <use-native-byte-order>false</use-native-byte-order>
        <byte-order>BIG_ENDIAN</byte-order>
        <data-serializable-factories>
            <data-serializable-factory factory-id="1">com.hazelcast.examples.DataSerializableFactory
            </data-serializable-factory>
        </data-serializable-factories>
        <portable-factories>
            <portable-factory factory-id="1">com.hazelcast.examples.PortableFactory</portable-factory>
        </portable-factories>
        <serializers>
            <global-serializer>com.hazelcast.examples.GlobalSerializerFactory</global-serializer>
            <serializer type-class="com.hazelcast.examples.DummyType"
                        class-name="com.hazelcast.examples.SerializerFactory"/>
        </serializers>
        <check-class-def-errors>true</check-class-def-errors>
    </serialization>
<!--
    ===== HAZELCAST HIGH-DENSITY MEMORY STORE CONFIGURATION =====
    
    This feature is available only in Hazelcast Enterprise HD. Configuration element's name is 
    <native-memory>. 
    It has the following attributes:
    - enabled: 
    	Set as true to enable the High-Density Memory Store usage. Its default value is false.
    - allocator-type: 
    	Type of the memory allocator. Its default value is POOLED. Available values are as follows:
	* STANDARD: Allocates/frees the memory using default OS memory manager.
	* POOLED: Manages memory blocks in thread local pools.

    It has the following sub-elements:
    - <size>:
    	Size of the total native memory to allocate. You can give the size using its "value" attribute and the unit
    	using its "unit" attribute. Unit can be bytes, kilobytes, megabytes and gigabytes. Default value is 128 and 
    	default unit is MEGABYTES.
    - <min-block-size>:
    	Minimum size of the blocks in bytes to split and fragment a page block to assign to an allocation request. 
    	It is used only by the POOLED memory allocator. Its default value is 16.
    - <page-size>:
    	Size of the page in bytes to allocate memory as a block. It is used only by the POOLED memory allocator. Its 
    	default value is 1 << 22 (about 4 MB).
    - <metadata-space-percentage>:
    	Percentage of the allocated native memory that is used for the metadata such as indexes, offsets, etc. It is 
    	used only by the POOLED memory allocator. Its default value is 12.5.
-->
    <native-memory allocator-type="POOLED" enabled="true">
        <size unit="MEGABYTES" value="256"/>
        <min-block-size>24</min-block-size>
        <page-size>4194304</page-size>
        <metadata-space-percentage>12.5</metadata-space-percentage>
    </native-memory>
<!--
    ===== HAZELCAST USER DEFINED SERVICES CONFIGURATION =====
    
    This part is used to perform configurations after you develop your own data structure or service using 
    Hazelcast's Service Provider Interface (SPI). Configuration element's name is <services>. You can list
    your services using its <service>.
    It has the following attribute:
    * enable-defaults: 
    	Set as true if you want to use Hazelcast's services and operations (getMap, putAsync, etc.) 
    	in your own service implementation. Its default value is true.
    
    Each <service> has the following attributes and sub-elements:
    * enabled: 
    	Specifies whether the service is enabled.
    * <name>:
    	Name of your service to be registered.
    * <class-name>:
    	Full name of the class that you developed for your service on top of Hazelcast SPI.
    * <properties>:
    	Lists the properties using its <property> element, with which you can specify the name and value of your
    	custom service properties.
    * <configuration>:
    	Lists the configuration elements that you defined for your service using Hazelcast's "Config" object.
-->
    <services enable-defaults="false">
        <service enabled="true">
            <name>custom-service</name>
            <class-name>com.hazelcast.examples.MyService</class-name>
            <properties>
                <property name="prop1">prop1-value</property>
                <property name="prop2">prop2-value</property>
            </properties>
        </service>
    </services>
<!--
    ===== HAZELCAST SECURITY CONFIGURATION =====
    
    This feature is available only in Hazelcast Enterprise. Configuration element's name is <security>. 
    It has the following attributes and sub-elements:
    * enabled:
    	Set to true to enable Hazelcast's security features.
    * <member-credentials-factory>:
    	Specifies the name and properties of your class that you developed by implementing Hazelcast's Credentials 
    	interface.
    * <member-login-modules>:
    	Specifies the name and properties of your class that you developed by implementing Hazelcast's LoginModule 
    	interface. Each login module class can be given by using the <login-module> element. This element has the 
    	attribute "usage" that specifies the way you want to use the LoginModule's  behavior during the 
    	authentication process for Hazelcast members. Available values for this attribute are REQUIRED, REQUISITE, 
    	SUFFICIENT and OPTIONAL.
    * <client-login-modules>:
	It has the same purpose as <member-login-modules> explained above. However, instead of Hazelcast members,
	it is used for Hazelcast native clients.
    * <client-permission-policy>:
    	Specifies the name and properties of your class that you developed by implementing Hazelcast's 
    	IPermissionPolicy interface, which is the default permission policy (com.hazelcast.security.IPermissionPolicy).
    	This policy defines the client authorization specifications.
    * <client-permissions>:
    	Lists the client permissions that can be accessed by the client permission policy. For each permission, you 
    	need to provide the end points and actions to be permitted. Also, the name and principal for each permission 
    	should be given using the "name" and "principal" attributes. Please see 
    	http://docs.hazelcast.org/docs/latest/manual/html-single/index.html#permissions for all permissions and actions.
    * <security-interceptor>
    	Specifies the security interceptor class that you developed by implementing Hazelcast's SecurityInterceptor
    	interface to intercept every remote operation executed by a client.
-->
    <security enabled="false">
        <member-credentials-factory class-name="com.hazelcast.examples.MyCredentialsFactory">
            <properties>
                <property name="property">value</property>
            </properties>
        </member-credentials-factory>
        <member-login-modules>
            <login-module class-name="com.hazelcast.examples.MyRequiredLoginModule" usage="REQUIRED">
                <properties>
                    <property name="property">value</property>
                </properties>
            </login-module>
        </member-login-modules>
        <client-login-modules>
            <login-module class-name="com.hazelcast.examples.MyOptionalLoginModule" usage="OPTIONAL">
                <properties>
                    <property name="property">value</property>
                </properties>
            </login-module>
            <login-module class-name="com.hazelcast.examples.MyRequiredLoginModule" usage="REQUIRED">
                <properties>
                    <property name="property">value</property>
                </properties>
            </login-module>
        </client-login-modules>
        <client-permission-policy class-name="com.hazelcast.examples.MyPermissionPolicy">
            <properties>
                <property name="property">value</property>
            </properties>
        </client-permission-policy>
        <client-permissions>
            <all-permissions principal="admin">
                <endpoints>
                    <endpoint>127.0.0.1</endpoint>
                </endpoints>
            </all-permissions>
            <map-permission name="custom" principal="dev">
                <endpoints>
                    <endpoint>127.0.0.1</endpoint>
                </endpoints>
                <actions>
                    <action>create</action>
                    <action>destroy</action>
                    <action>put</action>
                    <action>read</action>
                </actions>
            </map-permission>
        </client-permissions>
        <security-interceptors>
        	<interceptor class-name="com.your-package.YourSecurityInterceptorImplementation"/>
        </security-interceptors>
    </security>
<!--
    ===== HAZELCAST MEMBER ATTRIBUTE CONFIGURATION =====
    
    You can define member attributes for your Hazelcast members to tag your members according to your 
    business logic requirements. Configuration element's name is <member-attributes>. You can list 
    each member attribute using its <attribute> sub-element. For each <attribute>, you need to provide its
    name, type and value.
-->
    <member-attributes>
        <attribute name="CPU_CORE_COUNT" type="int">4</attribute>
        <attribute name="CPU_CORE_FREQ" type="int">1033</attribute>
    </member-attributes>
<!--
    ===== HAZELCAST QUORUM CONFIGURATION =====
    
    Configuration element's name is <quorum>.
    It has the following attributes:
    * name: 
    	Name of your quorum. This name will be given as the value for <quorum-ref> element in the data structure
    	configuration for which you want to define a quorum. Currently, IMap, TransactionalMap and Cache 
    	structures support quorum.
    * enabled:
    	Specifies whether this quorum is enabled.
    	
    It has the following sub-elements:
    * <quorum-size>:
    	The minimum number of members required in a cluster for the cluster to remain in an
	operational state. If the number of members is below the defined minimum at any time,
	the operations are rejected and the rejected operations return a QuorumException to
	their callers.
    * <quorum-type>:
    	Specifies for which operations the quorum will be applied. Available values are
    	READ, WRITE and READ_WRITE.
    * <quorum-function-class-name>:
    	Name of the class that you develop by implementing Hazelcast's QuorumFunction interface to 
    	conclude the absence/presence of your quorum. This function is triggered when any change happens to
    	the member list.
    * <quorum-listeners>:
    	Provides the list of quorum listeners that you can register to be notified about quorum results. 
    	Each listener is specified by <quorum-listener> sub-element. Quorum listeners are local to the member 
    	that they are registered, so they receive only events occurred on that local member.
-->
    <quorum name="quorumRuleWithThreeMembers" enabled="true">
        <quorum-size>3</quorum-size>
        <quorum-type>READ_WRITE</quorum-type>
        <quorum-function-class-name>
        	com.your-package.AbsPresMyQuorum
        </quorum-function-class-name>
        <quorum-listeners>
            <quorum-listener>
            	com.your-package.ThreeMemberQuorumListener
            </quorum-listener>
        </quorum-listeners>
    </quorum>
<!--
    ===== HAZELCAST LITE MEMBER CONFIGURATION =====
    
    Configuration element's name is <lite-member>. When you want to use a Hazelcast member as a lite member,
    set this element's "enabled" attribute to true in that member's XML configuration. Lite members do not store 
    data and are used mainly to execute tasks and register listeners. They do not have partitions.
-->    
    <lite-member enabled="true"/>
<!--    
    ===== HAZELCAST HOT RESTART PERSISTENCE CONFIGURATION =====
    
    This feature is available only in Hazelcast Enterprise HD. Configuration element's name is 
    <hot-restart-persistence>. It has the required attribute "enabled" to specify whether this feature will be enabled
    on your cluster. This part is the feature's configuration itself and you define the general specifications for 
    the feature. However, note that <map> and <cache> have a sub-element called <hot-restart> with which you should 
    enable its usage on those data structures. Keep in mind that the Hot Restart feature is currently supported for 
    Hazelcast's map and cache data structures.
    It has the following sub-elements:
    * <base-dir>:
    	Specifies the directory where the Hot Restart data will be stored. Its default value is hot-restart. 
    	You can use the default value, or you can specify another folder.
    	This directory will be created automatically if it does not exist.
    * <parallelism>:
    	Level of parallelism in Hot Restart Persistence. There will be this many IO threads,
    	each writing in parallel to its own files. During the Hot Restart procedure, this many 
    	IO threads will be reading the files and this many Rebuilder threads will be rebuilding 
    	the Hot Restart metadata.
    * <validation-timeout-seconds>:
    	Validation timeout for the Hot Restart process when validating the cluster members expected to join and the partition 
    	table on the whole cluster.
    * <data-load-timeout-seconds>:
    	Data load timeout for the Hot Restart process. All members in the cluster should finish restoring their local data 
    	before this timeout period.
-->
    <hot-restart-persistence enabled="true">
       <base-dir>/mnt/hot-restart</base-dir>
       <validation-timeout-seconds>120</validation-timeout-seconds>
       <data-load-timeout-seconds>900</data-load-timeout-seconds>
   </hot-restart-persistence>
</hazelcast>
