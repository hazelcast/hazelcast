/*
 * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hazelcast.sql.jdbc;

import com.hazelcast.sql.jdbc.impl.JdbcCursor;
import com.hazelcast.sql.jdbc.impl.JdbcGateway;
import com.hazelcast.sql.jdbc.impl.JdbcUtils;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.Collections;
import java.util.List;

import static com.hazelcast.sql.jdbc.impl.JdbcUtils.unsupported;

/**
 * JDBC statement.
 */
@SuppressWarnings({"RedundantThrows", "checkstyle:MethodCount"})
public class HazelcastJdbcStatement implements Statement {
    /** Number of milliseconds in second. */
    private static final int MILLIS_IN_SECOND = 1_000;

    /** Parent connection. */
    protected final HazelcastJdbcConnection connection;

    /** Result of execution. */
    protected HazelcastJdbcResultSet resultSet;

    /** Gateway. */
    private final JdbcGateway gateway;

    /** Whether the statement is closed. */
    private boolean closed;

    /** Page size. */
    private int pageSize;

    /** Query timeout. */
    private int queryTimeout;

    /** Whether to close the statement when the result set is closed. */
    private boolean closeOnCompletion;

    /** Fetch direction hint. */
    private int fetchDirection = ResultSet.FETCH_FORWARD;

    /** Poolable flag. */
    private boolean poolable;

    public HazelcastJdbcStatement(JdbcGateway gateway, HazelcastJdbcConnection connection, int pageSize, boolean poolable) {
        assert pageSize >= 0;

        this.gateway = gateway;
        this.connection = connection;
        this.pageSize = pageSize;
        this.poolable = poolable;
    }

    @Override
    public ResultSet executeQuery(String sql) throws SQLException {
        boolean res = execute(sql);

        if (!res) {
            throw new SQLException("Query didn't produce result set.");
        }

        return resultSet;
    }

    @Override
    public int executeUpdate(String sql) throws SQLException {
        throw unsupportedUpdate();
    }

    @Override
    public boolean execute(String sql) throws SQLException {
        execute0(sql, Collections.emptyList());

        return true;
    }

    @Override
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        throw unsupportedAutoGeneratedKeys();
    }

    @Override
    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        throw unsupportedAutoGeneratedKeys();
    }

    @Override
    public boolean execute(String sql, String[] columnNames) throws SQLException {
        throw unsupportedAutoGeneratedKeys();
    }

    @Override
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        throw unsupportedAutoGeneratedKeys();
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        throw unsupportedAutoGeneratedKeys();
    }

    @Override
    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        throw unsupportedAutoGeneratedKeys();
    }

    /**
     * Core execution routine.
     *
     * @param sql SQL query.
     * @param args Query arguments.
     */
    protected void execute0(String sql, List<Object> args) throws SQLException {
        checkClosed();

        if (args == null) {
            args = Collections.emptyList();
        }

        // TODO: OOPS! Is this correct? Should we really close other result sets in this case? Consult to docs.
        if (resultSet != null) {
            closeResultSet(false);
        }

        assert resultSet == null;

        JdbcCursor page = gateway.execute(sql, args, pageSize, queryTimeout * MILLIS_IN_SECOND);

        resultSet = new HazelcastJdbcResultSet(this, page, fetchDirection);
    }

    @Override
    public void addBatch(String sql) throws SQLException {
        throw unsupportedBatch();
    }

    @Override
    public void clearBatch() throws SQLException {
        throw unsupportedBatch();
    }

    @Override
    public int[] executeBatch() throws SQLException {
        throw unsupportedBatch();
    }

    @Override
    public void cancel() throws SQLException {
        // TODO: Implement cancellation support. Careful synchronization is required here.
    }

    @Override
    public void close() throws SQLException {
        if (!closed) {
            closeResultSet(false);

            closed = true;
        }
    }

    @Override
    public boolean isClosed() throws SQLException {
        return closed;
    }

    @Override
    public void closeOnCompletion() throws SQLException {
        checkClosed();

        closeOnCompletion = true;
    }

    @Override
    public boolean isCloseOnCompletion() throws SQLException {
        checkClosed();

        return closeOnCompletion;
    }

    @Override
    public int getQueryTimeout() throws SQLException {
        checkClosed();

        return queryTimeout;
    }

    @Override
    public void setQueryTimeout(int queryTimeout) throws SQLException {
        checkClosed();

        if (queryTimeout < 0) {
            throw new SQLException("Query timeout cannot be negative: " + queryTimeout);
        }

        this.queryTimeout = queryTimeout;
    }

    @Override
    public ResultSet getResultSet() throws SQLException {
        checkClosed();

        return resultSet;
    }

    @Override
    public int getUpdateCount() throws SQLException {
        checkClosed();

        return -1;
    }

    @Override
    public boolean getMoreResults() throws SQLException {
        return getMoreResults(CLOSE_CURRENT_RESULT);
    }

    @Override
    public boolean getMoreResults(int current) throws SQLException {
        checkClosed();

        switch (current) {
            case CLOSE_CURRENT_RESULT:
                break;

            case KEEP_CURRENT_RESULT:
            case CLOSE_ALL_RESULTS:
                throw unsupported("Unsupported value: " + current);

            default:
                throw new SQLException("Invalid value: " + current);
        }

        closeResultSet(true);

        return false;
    }

    /**
     * Close the current result set.
     *
     * @param propagateBack Whether the close should be propagated back from the result set to this connection (required for
     *                      {@link #isCloseOnCompletion()} support.
     */
    private void closeResultSet(boolean propagateBack) throws SQLException {
        if (resultSet != null) {
            resultSet.close(propagateBack);

            resultSet = null;
        }
    }

    @Override
    public Connection getConnection() throws SQLException {
        checkClosed();

        return connection;
    }

    @Override
    public int getMaxFieldSize() throws SQLException {
        checkClosed();

        return 0;
    }

    @Override
    public void setMaxFieldSize(int max) throws SQLException {
        checkClosed();

        if (max < 0) {
            throw new SQLException("Max field size cannot be negative: " + max);
        }

        if (max != 0) {
            throw unsupported("Positive max field size is not supported");
        }
    }

    @Override
    public int getMaxRows() throws SQLException {
        checkClosed();

        throw unsupported("getMaxRows is not supported");
    }

    @Override
    public void setMaxRows(int maxRows) throws SQLException {
        checkClosed();

        if (maxRows < 0) {
            throw new SQLException("Max rows cannot be negative: " + maxRows);
        }

        throw unsupported("setMaxRows is not supported");
    }

    @Override
    public void setEscapeProcessing(boolean enable) throws SQLException {
        checkClosed();
    }

    @Override
    public void setCursorName(String name) throws SQLException {
        checkClosed();

        throw unsupported("setCursorName is not supported.");
    }

    @Override
    public void setFetchDirection(int fetchDirection) throws SQLException {
        checkClosed();

        switch (fetchDirection) {
            case ResultSet.FETCH_FORWARD:
            case ResultSet.FETCH_REVERSE:
            case ResultSet.FETCH_UNKNOWN:
                this.fetchDirection = fetchDirection;

                break;

            default:
                throw new SQLException("Invalid value: " + fetchDirection);
        }
    }

    @Override
    public int getFetchDirection() throws SQLException {
        checkClosed();

        return fetchDirection;
    }

    @Override
    public void setFetchSize(int pageSize) throws SQLException {
        checkClosed();

        if (pageSize < 0) {
            throw new SQLException("pageSize cannot be negative: " + pageSize);
        }

        this.pageSize = pageSize;
    }

    @Override
    public int getFetchSize() throws SQLException {
        checkClosed();

        return pageSize;
    }

    @Override
    public void setPoolable(boolean poolable) throws SQLException {
        checkClosed();

        this.poolable = poolable;
    }

    @Override
    public boolean isPoolable() throws SQLException {
        checkClosed();

        return poolable;
    }

    @Override
    public int getResultSetType() throws SQLException {
        checkClosed();

        return ResultSet.TYPE_FORWARD_ONLY;
    }

    @Override
    public int getResultSetConcurrency() throws SQLException {
        checkClosed();

        return ResultSet.CONCUR_READ_ONLY;
    }

    @Override
    public int getResultSetHoldability() throws SQLException {
        checkClosed();

        return ResultSet.CLOSE_CURSORS_AT_COMMIT;
    }

    @Override
    public ResultSet getGeneratedKeys() throws SQLException {
        checkClosed();

        throw unsupported("getGeneratedKeys is not supported.");
    }

    @Override
    public SQLWarning getWarnings() throws SQLException {
        checkClosed();

        return null;
    }

    @Override
    public void clearWarnings() throws SQLException {
        checkClosed();
    }

    @Override
    public <T> T unwrap(Class<T> iface) throws SQLException {
        return JdbcUtils.unwrap(this, iface);
    }

    @Override
    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        return JdbcUtils.isWrapperFor(this, iface);
    }

    protected void checkClosed() throws SQLException {
        if (closed) {
            throw new SQLException("Statement is closed", "STATE", -1);
        }
    }

    protected SQLFeatureNotSupportedException unsupportedUpdate() throws SQLException {
        checkClosed();

        return unsupported("executeUpdate is not supported.");
    }

    protected SQLFeatureNotSupportedException unsupportedBatch() throws SQLException {
        checkClosed();

        throw unsupported("Batched execution is not supported.");
    }

    private SQLFeatureNotSupportedException unsupportedAutoGeneratedKeys() throws SQLException {
        checkClosed();

        return unsupported("Auto-generated keys are not supported.");
    }
}
