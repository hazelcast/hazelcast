# Matching the SQL query to the Jet job

|                                |                                                           |
|--------------------------------|-----------------------------------------------------------|
| Related Jira                   | [HZ-2859](https://hazelcast.atlassian.net/browse/HZ-2859) |
| Document Status / Completeness | IN PROGRESS                                               |
| Requirement owner              | Saumitra Sahi                                             |
| Developer(s)                   | Sasha Syrotenko                                           |
| Quality Engineer               | Isaac Sumner                                              |
| Technical Reviewers            | Krzystof Jamroz                                           |
| Version                        | 5.4                                                       |

## Background

In Hazelcast Platform 5.3, the sole SQL job metrics report can be accessed exclusively through
the `getJobAndSqlSummaryList()` method within the Java client. This approach doesn't align with
the idea of SQL serving as the self-sufficient Hazelcast interface. Consequently, there is currently
no ability to monitor the status of a running interactive SQL query, because it's impossible
to associate it automatically with the corresponding Jet job.

To address this issue, we aim to enable the match of interactive SQL queries with their running Jet jobs,
allowing to show live metrics for a query user just started.

## Terminology

**Query runtime** - query execution time; time between query submission and query completion.

## Goals

The goals of that initiative are:

- open a possibility to capture live metrics by matching SQL query with running Jet job.
- ability to cancel a query by cancelling the corresponding job.

Non-goals are:

- expose live metrics for non-Jet SQL query executions.
- support`CREATE JOB` as part of this initiative. It is created with name, so it is already exposed.

New features should be available in the following clients:

| Feature                     | Member-side API | MC  | CLC  | JDBC | Java client | Other clients |
|-----------------------------|-----------------|-----|------|------|-------------|---------------|
| Query metrics (interactive) | not needed      | yes | no?  | no   | yes         | yes           |
| Query metrics (ANALYZE)     | not needed      | yes | yes? | no   | yes         | yes           |
| Cancel                      | not needed?     | yes | yes  | yes? | yes         | yes           |

Above table gives only initial overview where we might want to use new possibilities
enabled by this TDD.

## Technical Design

We can provide multiple approaches to solve given problem:

### Approach 1 : reuse existing QueryId

`QueryId` class appears to be a data structure for representing a query identifier. In fact, it is a 256-bit value,
where upper 128 bit represents the query coordinator, and lower 128 bit represents the actual query id, which is
generated by `UuidUtil.newUnsecureUUID()`. On the client, it should be stored locally in set or map, and used by
metrics consumer.

The basic idea of this approach is simple : we may take lower 64 bits of `QueryId` and use them as **Jet job**
identifier during job creation in `PlanExecutor`:

java
class PlanExecutor {
// ...
SqlResult execute(SelectPlan plan, QueryId queryId, List<Object> arguments, long timeout, SqlSecurityContext ssc) {
// ...
long jobId = queryId.getLocalIdLow();
// ...
Job job = jet.newLightJob(jobId, plan.getDag(), jobConfig, ssc.subject());
}
// ...
}

One significant drawback of this approach, which cannot be easily addressed, is that Jet depends on a cluster-wide
flake ID generator to produce job IDs, thereby ensuring their uniqueness across the entire cluster. However, if
the client utilizes `UuidUtil.newUnsecureUUID()`, it cannot guarantee the same level of uniqueness. To prevent
ID collisions, our solution involves storing all job IDs in a cluster-wide, consistent data store. Regrettably,
the Hazelcast CP subsystem is not available for the SQL engine and Jet.

In this scenario, we must consider the possibility that the client may be under the control of potentially malicious
parties.

### Approach 2 : return `jobId` to the client as a part of `SqlResult`

This approach differs from the previous one in that it doesn't use `QueryId` at all. Instead, we are making an
additional field in `SqlResult` (or `SqlClientResult`) class, which will contain `jobId` of the corresponding Jet job.

This seemingly minor alteration, when examined closely, carries significant implications:
we must now match Jet jobs with SQL queries during query execution, ideally even before the Jet job start its execution.
The challenge with this approach is that presently (as of HZ 5.3), for small batch queries, as well as for all DML
queries, the `SqlResult` is not available until after the job has finished. To address this predicament, we need
to rework our query lifecycle to operate asynchronously: we'll return an empty `SqlResult` (or empty analogue
of `SqlResult`) to the client and prompt the client to `fetch` the results. Worth noticing, it also solves a problem
of query thread blocking during DML query execution.

The primary difficulty with this method lies in the fact that, when executing DML queries, we cannot ensure
the existence of the job entity after receiving the job ID as part of a SQL result. This means that if the query fails,
the end user won't be able to determine its status â€“ whether it was successful or not. This is not acceptable behaviour,
and this limitation encouraged us to explore an alternative solution:

### Approach 3 : return `jobId` to the client as a part of `SqlExecuteResponce`

As described in section header, this approach is a variation of the previous one: instead of sending `jobId` as a part
of `SqlResult`, we will do it even earlier, as a part of `execute` command. But support it, we need to introduce same
job workflow for DML queries inside `PlanExecutor` as for `SELECT` queries : we will track job completion future in
`QueryClientStateRegistry` and by this, we can eliminate the problem of job existence after query failure. Other aspects
won't change much: it is still would be a new, separate asynchronous execution mode.

Return of `jobId` to the client as a part of `SqlExecuteResponce` with introduction of asynchronous query execution mode
was chosen as main direction to implement.

### Solution design

#### Existing client - member communication protocol

![Client - Member communication protocol](https://svgshare.com/i/z9v.svg)

#### Client protocol

To enable asynchronous query handling, we propose adding a field to the `SqlExecuteCodec.RequestParameters` to mark
requests that should be handled asynchronously. In order to support [Flexible Async Mode](#flexible-async-mode)
it will be an integer field with the following values:

- `-1` - synchronous mode (default and for backwards compatibility)
- `0` - asynchronous mode
- `> 0` - timeout for flexible async mode before returning async response

Initially only the first 2 values will be supported. Flexible async mode may be implemented in the future if
the performance tests confirm that latency for short DML queries might be improved that way.

#### Java APIs

The proposed Java API changes are as follows:

java
public interface SqlService {
// ...

    /**
     * Execute the statement in asynchronous way if possible.
     * @param statement
     * @return
     */
    // also additional convenience variants similar to `execute`
    // supported only on client-side (SqlClientService).
    @Nonnull
    SqlResult executeAsync(@Nonnull SqlStatement statement);
}

public interface AsyncSqlResult extends SqlResult {
/**
* @return If the query uses/used Jet job
*/
boolean isJob();

    /**
     * Returns job id of job used to execute this query.
     * <p>
     * If the job was a light job (interactive query without {@code ANALYZE})
     * it will be impossible to find the job after the query finished
     * which requires caution or error handling to avoid race conditions.
     *
     * @throws UnsupportedOperationException if the query did not a use Jet job (isJob() returns false)
     */
    long getJobId();

    /**
     * Wait for query finish.
     * If the job does not exist it assumes that it already finished.
     *
     * @return Final result of the query. It might be `this` or different object containing eg. final `updateCount` 
     * @throws UnsupportedOperationException if the query did not a use Jet job (isJob() returns false)
     */
    SqlResult join();
}

// Only client-side API implements async execution mode
public class SqlClientResult implements AsyncSqlResult {
// ...
}

Within the SqlService, we're implementing a new method named `executeAsync`. When using this method, the client can
indicate that a query should be executed asynchronously by setting an asynchronous flag. Afterward, `execute` task
is sent via calling `executeAsync`, the client will receive an initial `AsyncSqlResult` as part of the
`SqlExecuteResponse`. This result will include the `jobId` of the corresponding Jet job. If the query produces rows,
it will proceed with the regular execution process. However, if the user wishes to wait for query completion,
they must explicitly call`AsyncSqlResult.join()`.

The proposed async execution changes a response on DML query: after this change, the response will contain an
empty cursor, which is tracked by `QueryClientState`.

Also, it's important to note that asynchronous execution won't be the default mode, at least for the time being. This is
because, without a flexible asynchronous mode, it could potentially introduce additional latency for short DML queries,
as it involves an extra round-trip to the member.

##### QueryClientStateRegistry

Introduce `registerDml` for DML queries tracking by `QueryClientState`.

##### PlanExecutor

We should to introduce the same job workflow for DML queries for `PlanExecutor` as for `SELECT` queries : set up a
job completion future in `QueryClientStateRegistry`.

##### SqlExecuteMessageTask

Encode response message with `jobId` if the query uses Jet job.

#### JDBC driver

For the time being JDBC driver will use sync execution mode. It may use flexible mode in the future if available.

#### Additional Ideas

##### Use SqlFetchMessageTask to wait for query finish

As a further development of this idea in the future, we may replace the job joining approach with a more efficient one:
instead of joining job directly, we may send a `SqlFetchMessageTask` to get the final update count,
and wait for job completion.

##### Flexible Async Mode

We also propose an additional concept called "flexible async" mode. This mode will automatically determine whether
to switch to asynchronous query handling based on the query execution time. If the query takes longer than a specified
duration (configurable or passed in the request), it will switch to async mode and unblock the member query thread.
For short DML queries, it will return the final result immediately. The asyncMode parameter will control this behavior,
offering options like sync, async or timeout to provide flexibility in handling queries.

## Conclusion

For given period of time the author proposition is to
implement  [Return `jobId` to the client as a part of `SqlResult`](#return-jobid-to-the-client-as-a-part-of-sqlresult)
approach.